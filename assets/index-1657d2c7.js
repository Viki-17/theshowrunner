(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
  new MutationObserver((i) => {
    for (const s of i)
      if (s.type === "childList")
        for (const o of s.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && r(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(i) {
    const s = {};
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function r(i) {
    if (i.ep) return;
    i.ep = !0;
    const s = t(i);
    fetch(i.href, s);
  }
})();
var sl =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function Nc(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
var Db = { exports: {} },
  Wg = {},
  Fb = { exports: {} },
  Mt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Qh = Symbol.for("react.element"),
  $D = Symbol.for("react.portal"),
  eF = Symbol.for("react.fragment"),
  tF = Symbol.for("react.strict_mode"),
  nF = Symbol.for("react.profiler"),
  rF = Symbol.for("react.provider"),
  iF = Symbol.for("react.context"),
  sF = Symbol.for("react.forward_ref"),
  oF = Symbol.for("react.suspense"),
  aF = Symbol.for("react.memo"),
  lF = Symbol.for("react.lazy"),
  HE = Symbol.iterator;
function uF(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (HE && n[HE]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var Nb = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  Ob = Object.assign,
  Ub = {};
function Oc(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = Ub),
    (this.updater = t || Nb);
}
Oc.prototype.isReactComponent = {};
Oc.prototype.setState = function (n, e) {
  if (typeof n != "object" && typeof n != "function" && n != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, n, e, "setState");
};
Oc.prototype.forceUpdate = function (n) {
  this.updater.enqueueForceUpdate(this, n, "forceUpdate");
};
function kb() {}
kb.prototype = Oc.prototype;
function XS(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = Ub),
    (this.updater = t || Nb);
}
var JS = (XS.prototype = new kb());
JS.constructor = XS;
Ob(JS, Oc.prototype);
JS.isPureReactComponent = !0;
var GE = Array.isArray,
  zb = Object.prototype.hasOwnProperty,
  KS = { current: null },
  Hb = { key: !0, ref: !0, __self: !0, __source: !0 };
function Gb(n, e, t) {
  var r,
    i = {},
    s = null,
    o = null;
  if (e != null)
    for (r in (e.ref !== void 0 && (o = e.ref),
    e.key !== void 0 && (s = "" + e.key),
    e))
      zb.call(e, r) && !Hb.hasOwnProperty(r) && (i[r] = e[r]);
  var a = arguments.length - 2;
  if (a === 1) i.children = t;
  else if (1 < a) {
    for (var l = Array(a), u = 0; u < a; u++) l[u] = arguments[u + 2];
    i.children = l;
  }
  if (n && n.defaultProps)
    for (r in ((a = n.defaultProps), a)) i[r] === void 0 && (i[r] = a[r]);
  return {
    $$typeof: Qh,
    type: n,
    key: s,
    ref: o,
    props: i,
    _owner: KS.current,
  };
}
function cF(n, e) {
  return {
    $$typeof: Qh,
    type: n.type,
    key: e,
    ref: n.ref,
    props: n.props,
    _owner: n._owner,
  };
}
function YS(n) {
  return typeof n == "object" && n !== null && n.$$typeof === Qh;
}
function fF(n) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    n.replace(/[=:]/g, function (t) {
      return e[t];
    })
  );
}
var VE = /\/+/g;
function nv(n, e) {
  return typeof n == "object" && n !== null && n.key != null
    ? fF("" + n.key)
    : e.toString(36);
}
function Tm(n, e, t, r, i) {
  var s = typeof n;
  (s === "undefined" || s === "boolean") && (n = null);
  var o = !1;
  if (n === null) o = !0;
  else
    switch (s) {
      case "string":
      case "number":
        o = !0;
        break;
      case "object":
        switch (n.$$typeof) {
          case Qh:
          case $D:
            o = !0;
        }
    }
  if (o)
    return (
      (o = n),
      (i = i(o)),
      (n = r === "" ? "." + nv(o, 0) : r),
      GE(i)
        ? ((t = ""),
          n != null && (t = n.replace(VE, "$&/") + "/"),
          Tm(i, e, t, "", function (u) {
            return u;
          }))
        : i != null &&
          (YS(i) &&
            (i = cF(
              i,
              t +
                (!i.key || (o && o.key === i.key)
                  ? ""
                  : ("" + i.key).replace(VE, "$&/") + "/") +
                n
            )),
          e.push(i)),
      1
    );
  if (((o = 0), (r = r === "" ? "." : r + ":"), GE(n)))
    for (var a = 0; a < n.length; a++) {
      s = n[a];
      var l = r + nv(s, a);
      o += Tm(s, e, t, l, i);
    }
  else if (((l = uF(n)), typeof l == "function"))
    for (n = l.call(n), a = 0; !(s = n.next()).done; )
      (s = s.value), (l = r + nv(s, a++)), (o += Tm(s, e, t, l, i));
  else if (s === "object")
    throw (
      ((e = String(n)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(n).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return o;
}
function vp(n, e, t) {
  if (n == null) return n;
  var r = [],
    i = 0;
  return (
    Tm(n, r, "", "", function (s) {
      return e.call(t, s, i++);
    }),
    r
  );
}
function hF(n) {
  if (n._status === -1) {
    var e = n._result;
    (e = e()),
      e.then(
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 1), (n._result = t));
        },
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 2), (n._result = t));
        }
      ),
      n._status === -1 && ((n._status = 0), (n._result = e));
  }
  if (n._status === 1) return n._result.default;
  throw n._result;
}
var br = { current: null },
  bm = { transition: null },
  dF = {
    ReactCurrentDispatcher: br,
    ReactCurrentBatchConfig: bm,
    ReactCurrentOwner: KS,
  };
Mt.Children = {
  map: vp,
  forEach: function (n, e, t) {
    vp(
      n,
      function () {
        e.apply(this, arguments);
      },
      t
    );
  },
  count: function (n) {
    var e = 0;
    return (
      vp(n, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (n) {
    return (
      vp(n, function (e) {
        return e;
      }) || []
    );
  },
  only: function (n) {
    if (!YS(n))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return n;
  },
};
Mt.Component = Oc;
Mt.Fragment = eF;
Mt.Profiler = nF;
Mt.PureComponent = XS;
Mt.StrictMode = tF;
Mt.Suspense = oF;
Mt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = dF;
Mt.cloneElement = function (n, e, t) {
  if (n == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        n +
        "."
    );
  var r = Ob({}, n.props),
    i = n.key,
    s = n.ref,
    o = n._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((s = e.ref), (o = KS.current)),
      e.key !== void 0 && (i = "" + e.key),
      n.type && n.type.defaultProps)
    )
      var a = n.type.defaultProps;
    for (l in e)
      zb.call(e, l) &&
        !Hb.hasOwnProperty(l) &&
        (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) r.children = t;
  else if (1 < l) {
    a = Array(l);
    for (var u = 0; u < l; u++) a[u] = arguments[u + 2];
    r.children = a;
  }
  return { $$typeof: Qh, type: n.type, key: i, ref: s, props: r, _owner: o };
};
Mt.createContext = function (n) {
  return (
    (n = {
      $$typeof: iF,
      _currentValue: n,
      _currentValue2: n,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (n.Provider = { $$typeof: rF, _context: n }),
    (n.Consumer = n)
  );
};
Mt.createElement = Gb;
Mt.createFactory = function (n) {
  var e = Gb.bind(null, n);
  return (e.type = n), e;
};
Mt.createRef = function () {
  return { current: null };
};
Mt.forwardRef = function (n) {
  return { $$typeof: sF, render: n };
};
Mt.isValidElement = YS;
Mt.lazy = function (n) {
  return { $$typeof: lF, _payload: { _status: -1, _result: n }, _init: hF };
};
Mt.memo = function (n, e) {
  return { $$typeof: aF, type: n, compare: e === void 0 ? null : e };
};
Mt.startTransition = function (n) {
  var e = bm.transition;
  bm.transition = {};
  try {
    n();
  } finally {
    bm.transition = e;
  }
};
Mt.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
Mt.useCallback = function (n, e) {
  return br.current.useCallback(n, e);
};
Mt.useContext = function (n) {
  return br.current.useContext(n);
};
Mt.useDebugValue = function () {};
Mt.useDeferredValue = function (n) {
  return br.current.useDeferredValue(n);
};
Mt.useEffect = function (n, e) {
  return br.current.useEffect(n, e);
};
Mt.useId = function () {
  return br.current.useId();
};
Mt.useImperativeHandle = function (n, e, t) {
  return br.current.useImperativeHandle(n, e, t);
};
Mt.useInsertionEffect = function (n, e) {
  return br.current.useInsertionEffect(n, e);
};
Mt.useLayoutEffect = function (n, e) {
  return br.current.useLayoutEffect(n, e);
};
Mt.useMemo = function (n, e) {
  return br.current.useMemo(n, e);
};
Mt.useReducer = function (n, e, t) {
  return br.current.useReducer(n, e, t);
};
Mt.useRef = function (n) {
  return br.current.useRef(n);
};
Mt.useState = function (n) {
  return br.current.useState(n);
};
Mt.useSyncExternalStore = function (n, e, t) {
  return br.current.useSyncExternalStore(n, e, t);
};
Mt.useTransition = function () {
  return br.current.useTransition();
};
Mt.version = "18.2.0";
Fb.exports = Mt;
var te = Fb.exports;
const Rn = Nc(te);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var pF = te,
  mF = Symbol.for("react.element"),
  gF = Symbol.for("react.fragment"),
  _F = Object.prototype.hasOwnProperty,
  vF = pF.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  yF = { key: !0, ref: !0, __self: !0, __source: !0 };
function Vb(n, e, t) {
  var r,
    i = {},
    s = null,
    o = null;
  t !== void 0 && (s = "" + t),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
  for (r in e) _F.call(e, r) && !yF.hasOwnProperty(r) && (i[r] = e[r]);
  if (n && n.defaultProps)
    for (r in ((e = n.defaultProps), e)) i[r] === void 0 && (i[r] = e[r]);
  return {
    $$typeof: mF,
    type: n,
    key: s,
    ref: o,
    props: i,
    _owner: vF.current,
  };
}
Wg.Fragment = gF;
Wg.jsx = Vb;
Wg.jsxs = Vb;
Db.exports = Wg;
var J = Db.exports,
  ky = {},
  Wb = { exports: {} },
  pi = {},
  jb = { exports: {} },
  Xb = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(N, W) {
    var G = N.length;
    N.push(W);
    e: for (; 0 < G; ) {
      var X = (G - 1) >>> 1,
        Y = N[X];
      if (0 < i(Y, W)) (N[X] = W), (N[G] = Y), (G = X);
      else break e;
    }
  }
  function t(N) {
    return N.length === 0 ? null : N[0];
  }
  function r(N) {
    if (N.length === 0) return null;
    var W = N[0],
      G = N.pop();
    if (G !== W) {
      N[0] = G;
      e: for (var X = 0, Y = N.length, de = Y >>> 1; X < de; ) {
        var ae = 2 * (X + 1) - 1,
          ye = N[ae],
          we = ae + 1,
          Ne = N[we];
        if (0 > i(ye, G))
          we < Y && 0 > i(Ne, ye)
            ? ((N[X] = Ne), (N[we] = G), (X = we))
            : ((N[X] = ye), (N[ae] = G), (X = ae));
        else if (we < Y && 0 > i(Ne, G)) (N[X] = Ne), (N[we] = G), (X = we);
        else break e;
      }
    }
    return W;
  }
  function i(N, W) {
    var G = N.sortIndex - W.sortIndex;
    return G !== 0 ? G : N.id - W.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    u = [],
    h = 1,
    d = null,
    p = 3,
    m = !1,
    _ = !1,
    y = !1,
    x = typeof setTimeout == "function" ? setTimeout : null,
    g = typeof clearTimeout == "function" ? clearTimeout : null,
    S = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function A(N) {
    for (var W = t(u); W !== null; ) {
      if (W.callback === null) r(u);
      else if (W.startTime <= N)
        r(u), (W.sortIndex = W.expirationTime), e(l, W);
      else break;
      W = t(u);
    }
  }
  function E(N) {
    if (((y = !1), A(N), !_))
      if (t(l) !== null) (_ = !0), Z(C);
      else {
        var W = t(u);
        W !== null && Q(E, W.startTime - N);
      }
  }
  function C(N, W) {
    (_ = !1), y && ((y = !1), g(L), (L = -1)), (m = !0);
    var G = p;
    try {
      for (
        A(W), d = t(l);
        d !== null && (!(d.expirationTime > W) || (N && !D()));

      ) {
        var X = d.callback;
        if (typeof X == "function") {
          (d.callback = null), (p = d.priorityLevel);
          var Y = X(d.expirationTime <= W);
          (W = n.unstable_now()),
            typeof Y == "function" ? (d.callback = Y) : d === t(l) && r(l),
            A(W);
        } else r(l);
        d = t(l);
      }
      if (d !== null) var de = !0;
      else {
        var ae = t(u);
        ae !== null && Q(E, ae.startTime - W), (de = !1);
      }
      return de;
    } finally {
      (d = null), (p = G), (m = !1);
    }
  }
  var R = !1,
    P = null,
    L = -1,
    T = 5,
    B = -1;
  function D() {
    return !(n.unstable_now() - B < T);
  }
  function I() {
    if (P !== null) {
      var N = n.unstable_now();
      B = N;
      var W = !0;
      try {
        W = P(!0, N);
      } finally {
        W ? F() : ((R = !1), (P = null));
      }
    } else R = !1;
  }
  var F;
  if (typeof S == "function")
    F = function () {
      S(I);
    };
  else if (typeof MessageChannel < "u") {
    var k = new MessageChannel(),
      j = k.port2;
    (k.port1.onmessage = I),
      (F = function () {
        j.postMessage(null);
      });
  } else
    F = function () {
      x(I, 0);
    };
  function Z(N) {
    (P = N), R || ((R = !0), F());
  }
  function Q(N, W) {
    L = x(function () {
      N(n.unstable_now());
    }, W);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (N) {
      N.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      _ || m || ((_ = !0), Z(C));
    }),
    (n.unstable_forceFrameRate = function (N) {
      0 > N || 125 < N
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (T = 0 < N ? Math.floor(1e3 / N) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(l);
    }),
    (n.unstable_next = function (N) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var W = 3;
          break;
        default:
          W = p;
      }
      var G = p;
      p = W;
      try {
        return N();
      } finally {
        p = G;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (N, W) {
      switch (N) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          N = 3;
      }
      var G = p;
      p = N;
      try {
        return W();
      } finally {
        p = G;
      }
    }),
    (n.unstable_scheduleCallback = function (N, W, G) {
      var X = n.unstable_now();
      switch (
        (typeof G == "object" && G !== null
          ? ((G = G.delay), (G = typeof G == "number" && 0 < G ? X + G : X))
          : (G = X),
        N)
      ) {
        case 1:
          var Y = -1;
          break;
        case 2:
          Y = 250;
          break;
        case 5:
          Y = 1073741823;
          break;
        case 4:
          Y = 1e4;
          break;
        default:
          Y = 5e3;
      }
      return (
        (Y = G + Y),
        (N = {
          id: h++,
          callback: W,
          priorityLevel: N,
          startTime: G,
          expirationTime: Y,
          sortIndex: -1,
        }),
        G > X
          ? ((N.sortIndex = G),
            e(u, N),
            t(l) === null &&
              N === t(u) &&
              (y ? (g(L), (L = -1)) : (y = !0), Q(E, G - X)))
          : ((N.sortIndex = Y), e(l, N), _ || m || ((_ = !0), Z(C))),
        N
      );
    }),
    (n.unstable_shouldYield = D),
    (n.unstable_wrapCallback = function (N) {
      var W = p;
      return function () {
        var G = p;
        p = W;
        try {
          return N.apply(this, arguments);
        } finally {
          p = G;
        }
      };
    });
})(Xb);
jb.exports = Xb;
var xF = jb.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Jb = te,
  fi = xF;
function Se(n) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1;
    t < arguments.length;
    t++
  )
    e += "&args[]=" + encodeURIComponent(arguments[t]);
  return (
    "Minified React error #" +
    n +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var Kb = new Set(),
  ch = {};
function Ol(n, e) {
  hc(n, e), hc(n + "Capture", e);
}
function hc(n, e) {
  for (ch[n] = e, n = 0; n < e.length; n++) Kb.add(e[n]);
}
var po = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  zy = Object.prototype.hasOwnProperty,
  SF =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  WE = {},
  jE = {};
function AF(n) {
  return zy.call(jE, n)
    ? !0
    : zy.call(WE, n)
    ? !1
    : SF.test(n)
    ? (jE[n] = !0)
    : ((WE[n] = !0), !1);
}
function MF(n, e, t, r) {
  if (t !== null && t.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return r
        ? !1
        : t !== null
        ? !t.acceptsBooleans
        : ((n = n.toLowerCase().slice(0, 5)), n !== "data-" && n !== "aria-");
    default:
      return !1;
  }
}
function EF(n, e, t, r) {
  if (e === null || typeof e > "u" || MF(n, e, t, r)) return !0;
  if (r) return !1;
  if (t !== null)
    switch (t.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function Rr(n, e, t, r, i, s, o) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = r),
    (this.attributeNamespace = i),
    (this.mustUseProperty = t),
    (this.propertyName = n),
    (this.type = e),
    (this.sanitizeURL = s),
    (this.removeEmptyString = o);
}
var nr = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (n) {
    nr[n] = new Rr(n, 0, !1, n, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (n) {
  var e = n[0];
  nr[e] = new Rr(e, 1, !1, n[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) {
  nr[n] = new Rr(n, 2, !1, n.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (n) {
  nr[n] = new Rr(n, 2, !1, n, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (n) {
    nr[n] = new Rr(n, 3, !1, n.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (n) {
  nr[n] = new Rr(n, 3, !0, n, null, !1, !1);
});
["capture", "download"].forEach(function (n) {
  nr[n] = new Rr(n, 4, !1, n, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (n) {
  nr[n] = new Rr(n, 6, !1, n, null, !1, !1);
});
["rowSpan", "start"].forEach(function (n) {
  nr[n] = new Rr(n, 5, !1, n.toLowerCase(), null, !1, !1);
});
var QS = /[\-:]([a-z])/g;
function qS(n) {
  return n[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(QS, qS);
    nr[e] = new Rr(e, 1, !1, n, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(QS, qS);
    nr[e] = new Rr(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (n) {
  var e = n.replace(QS, qS);
  nr[e] = new Rr(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (n) {
  nr[n] = new Rr(n, 1, !1, n.toLowerCase(), null, !1, !1);
});
nr.xlinkHref = new Rr(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (n) {
  nr[n] = new Rr(n, 1, !1, n.toLowerCase(), null, !0, !0);
});
function ZS(n, e, t, r) {
  var i = nr.hasOwnProperty(e) ? nr[e] : null;
  (i !== null
    ? i.type !== 0
    : r ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (EF(e, t, i, r) && (t = null),
    r || i === null
      ? AF(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t))
      : i.mustUseProperty
      ? (n[i.propertyName] = t === null ? (i.type === 3 ? !1 : "") : t)
      : ((e = i.attributeName),
        (r = i.attributeNamespace),
        t === null
          ? n.removeAttribute(e)
          : ((i = i.type),
            (t = i === 3 || (i === 4 && t === !0) ? "" : "" + t),
            r ? n.setAttributeNS(r, e, t) : n.setAttribute(e, t))));
}
var So = Jb.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  yp = Symbol.for("react.element"),
  Fu = Symbol.for("react.portal"),
  Nu = Symbol.for("react.fragment"),
  $S = Symbol.for("react.strict_mode"),
  Hy = Symbol.for("react.profiler"),
  Yb = Symbol.for("react.provider"),
  Qb = Symbol.for("react.context"),
  eA = Symbol.for("react.forward_ref"),
  Gy = Symbol.for("react.suspense"),
  Vy = Symbol.for("react.suspense_list"),
  tA = Symbol.for("react.memo"),
  Go = Symbol.for("react.lazy"),
  qb = Symbol.for("react.offscreen"),
  XE = Symbol.iterator;
function pf(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (XE && n[XE]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var un = Object.assign,
  rv;
function kf(n) {
  if (rv === void 0)
    try {
      throw Error();
    } catch (t) {
      var e = t.stack.trim().match(/\n( *(at )?)/);
      rv = (e && e[1]) || "";
    }
  return (
    `
` +
    rv +
    n
  );
}
var iv = !1;
function sv(n, e) {
  if (!n || iv) return "";
  iv = !0;
  var t = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (u) {
          var r = u;
        }
        Reflect.construct(n, [], e);
      } else {
        try {
          e.call();
        } catch (u) {
          r = u;
        }
        n.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (u) {
        r = u;
      }
      n();
    }
  } catch (u) {
    if (u && r && typeof u.stack == "string") {
      for (
        var i = u.stack.split(`
`),
          s = r.stack.split(`
`),
          o = i.length - 1,
          a = s.length - 1;
        1 <= o && 0 <= a && i[o] !== s[a];

      )
        a--;
      for (; 1 <= o && 0 <= a; o--, a--)
        if (i[o] !== s[a]) {
          if (o !== 1 || a !== 1)
            do
              if ((o--, a--, 0 > a || i[o] !== s[a])) {
                var l =
                  `
` + i[o].replace(" at new ", " at ");
                return (
                  n.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", n.displayName)),
                  l
                );
              }
            while (1 <= o && 0 <= a);
          break;
        }
    }
  } finally {
    (iv = !1), (Error.prepareStackTrace = t);
  }
  return (n = n ? n.displayName || n.name : "") ? kf(n) : "";
}
function wF(n) {
  switch (n.tag) {
    case 5:
      return kf(n.type);
    case 16:
      return kf("Lazy");
    case 13:
      return kf("Suspense");
    case 19:
      return kf("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (n = sv(n.type, !1)), n;
    case 11:
      return (n = sv(n.type.render, !1)), n;
    case 1:
      return (n = sv(n.type, !0)), n;
    default:
      return "";
  }
}
function Wy(n) {
  if (n == null) return null;
  if (typeof n == "function") return n.displayName || n.name || null;
  if (typeof n == "string") return n;
  switch (n) {
    case Nu:
      return "Fragment";
    case Fu:
      return "Portal";
    case Hy:
      return "Profiler";
    case $S:
      return "StrictMode";
    case Gy:
      return "Suspense";
    case Vy:
      return "SuspenseList";
  }
  if (typeof n == "object")
    switch (n.$$typeof) {
      case Qb:
        return (n.displayName || "Context") + ".Consumer";
      case Yb:
        return (n._context.displayName || "Context") + ".Provider";
      case eA:
        var e = n.render;
        return (
          (n = n.displayName),
          n ||
            ((n = e.displayName || e.name || ""),
            (n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")),
          n
        );
      case tA:
        return (
          (e = n.displayName || null), e !== null ? e : Wy(n.type) || "Memo"
        );
      case Go:
        (e = n._payload), (n = n._init);
        try {
          return Wy(n(e));
        } catch {}
    }
  return null;
}
function CF(n) {
  var e = n.type;
  switch (n.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (n = e.render),
        (n = n.displayName || n.name || ""),
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Wy(e);
    case 8:
      return e === $S ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function ga(n) {
  switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return n;
    case "object":
      return n;
    default:
      return "";
  }
}
function Zb(n) {
  var e = n.type;
  return (
    (n = n.nodeName) &&
    n.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function TF(n) {
  var e = Zb(n) ? "checked" : "value",
    t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e),
    r = "" + n[e];
  if (
    !n.hasOwnProperty(e) &&
    typeof t < "u" &&
    typeof t.get == "function" &&
    typeof t.set == "function"
  ) {
    var i = t.get,
      s = t.set;
    return (
      Object.defineProperty(n, e, {
        configurable: !0,
        get: function () {
          return i.call(this);
        },
        set: function (o) {
          (r = "" + o), s.call(this, o);
        },
      }),
      Object.defineProperty(n, e, { enumerable: t.enumerable }),
      {
        getValue: function () {
          return r;
        },
        setValue: function (o) {
          r = "" + o;
        },
        stopTracking: function () {
          (n._valueTracker = null), delete n[e];
        },
      }
    );
  }
}
function xp(n) {
  n._valueTracker || (n._valueTracker = TF(n));
}
function $b(n) {
  if (!n) return !1;
  var e = n._valueTracker;
  if (!e) return !0;
  var t = e.getValue(),
    r = "";
  return (
    n && (r = Zb(n) ? (n.checked ? "true" : "false") : n.value),
    (n = r),
    n !== t ? (e.setValue(n), !0) : !1
  );
}
function ng(n) {
  if (((n = n || (typeof document < "u" ? document : void 0)), typeof n > "u"))
    return null;
  try {
    return n.activeElement || n.body;
  } catch {
    return n.body;
  }
}
function jy(n, e) {
  var t = e.checked;
  return un({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: t ?? n._wrapperState.initialChecked,
  });
}
function JE(n, e) {
  var t = e.defaultValue == null ? "" : e.defaultValue,
    r = e.checked != null ? e.checked : e.defaultChecked;
  (t = ga(e.value != null ? e.value : t)),
    (n._wrapperState = {
      initialChecked: r,
      initialValue: t,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function eR(n, e) {
  (e = e.checked), e != null && ZS(n, "checked", e, !1);
}
function Xy(n, e) {
  eR(n, e);
  var t = ga(e.value),
    r = e.type;
  if (t != null)
    r === "number"
      ? ((t === 0 && n.value === "") || n.value != t) && (n.value = "" + t)
      : n.value !== "" + t && (n.value = "" + t);
  else if (r === "submit" || r === "reset") {
    n.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? Jy(n, e.type, t)
    : e.hasOwnProperty("defaultValue") && Jy(n, e.type, ga(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (n.defaultChecked = !!e.defaultChecked);
}
function KE(n, e, t) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var r = e.type;
    if (
      !(
        (r !== "submit" && r !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + n._wrapperState.initialValue),
      t || e === n.value || (n.value = e),
      (n.defaultValue = e);
  }
  (t = n.name),
    t !== "" && (n.name = ""),
    (n.defaultChecked = !!n._wrapperState.initialChecked),
    t !== "" && (n.name = t);
}
function Jy(n, e, t) {
  (e !== "number" || ng(n.ownerDocument) !== n) &&
    (t == null
      ? (n.defaultValue = "" + n._wrapperState.initialValue)
      : n.defaultValue !== "" + t && (n.defaultValue = "" + t));
}
var zf = Array.isArray;
function $u(n, e, t, r) {
  if (((n = n.options), e)) {
    e = {};
    for (var i = 0; i < t.length; i++) e["$" + t[i]] = !0;
    for (t = 0; t < n.length; t++)
      (i = e.hasOwnProperty("$" + n[t].value)),
        n[t].selected !== i && (n[t].selected = i),
        i && r && (n[t].defaultSelected = !0);
  } else {
    for (t = "" + ga(t), e = null, i = 0; i < n.length; i++) {
      if (n[i].value === t) {
        (n[i].selected = !0), r && (n[i].defaultSelected = !0);
        return;
      }
      e !== null || n[i].disabled || (e = n[i]);
    }
    e !== null && (e.selected = !0);
  }
}
function Ky(n, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(Se(91));
  return un({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + n._wrapperState.initialValue,
  });
}
function YE(n, e) {
  var t = e.value;
  if (t == null) {
    if (((t = e.children), (e = e.defaultValue), t != null)) {
      if (e != null) throw Error(Se(92));
      if (zf(t)) {
        if (1 < t.length) throw Error(Se(93));
        t = t[0];
      }
      e = t;
    }
    e == null && (e = ""), (t = e);
  }
  n._wrapperState = { initialValue: ga(t) };
}
function tR(n, e) {
  var t = ga(e.value),
    r = ga(e.defaultValue);
  t != null &&
    ((t = "" + t),
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    r != null && (n.defaultValue = "" + r);
}
function QE(n) {
  var e = n.textContent;
  e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e);
}
function nR(n) {
  switch (n) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function Yy(n, e) {
  return n == null || n === "http://www.w3.org/1999/xhtml"
    ? nR(e)
    : n === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : n;
}
var Sp,
  rR = (function (n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, t, r, i) {
          MSApp.execUnsafeLocalFunction(function () {
            return n(e, t, r, i);
          });
        }
      : n;
  })(function (n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n)
      n.innerHTML = e;
    else {
      for (
        Sp = Sp || document.createElement("div"),
          Sp.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = Sp.firstChild;
        n.firstChild;

      )
        n.removeChild(n.firstChild);
      for (; e.firstChild; ) n.appendChild(e.firstChild);
    }
  });
function fh(n, e) {
  if (e) {
    var t = n.firstChild;
    if (t && t === n.lastChild && t.nodeType === 3) {
      t.nodeValue = e;
      return;
    }
  }
  n.textContent = e;
}
var Jf = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  bF = ["Webkit", "ms", "Moz", "O"];
Object.keys(Jf).forEach(function (n) {
  bF.forEach(function (e) {
    (e = e + n.charAt(0).toUpperCase() + n.substring(1)), (Jf[e] = Jf[n]);
  });
});
function iR(n, e, t) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : t || typeof e != "number" || e === 0 || (Jf.hasOwnProperty(n) && Jf[n])
    ? ("" + e).trim()
    : e + "px";
}
function sR(n, e) {
  n = n.style;
  for (var t in e)
    if (e.hasOwnProperty(t)) {
      var r = t.indexOf("--") === 0,
        i = iR(t, e[t], r);
      t === "float" && (t = "cssFloat"), r ? n.setProperty(t, i) : (n[t] = i);
    }
}
var RF = un(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function Qy(n, e) {
  if (e) {
    if (RF[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(Se(137, n));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(Se(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(Se(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(Se(62));
  }
}
function qy(n, e) {
  if (n.indexOf("-") === -1) return typeof e.is == "string";
  switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var Zy = null;
function nA(n) {
  return (
    (n = n.target || n.srcElement || window),
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
  );
}
var $y = null,
  ec = null,
  tc = null;
function qE(n) {
  if ((n = $h(n))) {
    if (typeof $y != "function") throw Error(Se(280));
    var e = n.stateNode;
    e && ((e = Yg(e)), $y(n.stateNode, n.type, e));
  }
}
function oR(n) {
  ec ? (tc ? tc.push(n) : (tc = [n])) : (ec = n);
}
function aR() {
  if (ec) {
    var n = ec,
      e = tc;
    if (((tc = ec = null), qE(n), e)) for (n = 0; n < e.length; n++) qE(e[n]);
  }
}
function lR(n, e) {
  return n(e);
}
function uR() {}
var ov = !1;
function cR(n, e, t) {
  if (ov) return n(e, t);
  ov = !0;
  try {
    return lR(n, e, t);
  } finally {
    (ov = !1), (ec !== null || tc !== null) && (uR(), aR());
  }
}
function hh(n, e) {
  var t = n.stateNode;
  if (t === null) return null;
  var r = Yg(t);
  if (r === null) return null;
  t = r[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (r = !r.disabled) ||
        ((n = n.type),
        (r = !(
          n === "button" ||
          n === "input" ||
          n === "select" ||
          n === "textarea"
        ))),
        (n = !r);
      break e;
    default:
      n = !1;
  }
  if (n) return null;
  if (t && typeof t != "function") throw Error(Se(231, e, typeof t));
  return t;
}
var ex = !1;
if (po)
  try {
    var mf = {};
    Object.defineProperty(mf, "passive", {
      get: function () {
        ex = !0;
      },
    }),
      window.addEventListener("test", mf, mf),
      window.removeEventListener("test", mf, mf);
  } catch {
    ex = !1;
  }
function PF(n, e, t, r, i, s, o, a, l) {
  var u = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(t, u);
  } catch (h) {
    this.onError(h);
  }
}
var Kf = !1,
  rg = null,
  ig = !1,
  tx = null,
  BF = {
    onError: function (n) {
      (Kf = !0), (rg = n);
    },
  };
function LF(n, e, t, r, i, s, o, a, l) {
  (Kf = !1), (rg = null), PF.apply(BF, arguments);
}
function IF(n, e, t, r, i, s, o, a, l) {
  if ((LF.apply(this, arguments), Kf)) {
    if (Kf) {
      var u = rg;
      (Kf = !1), (rg = null);
    } else throw Error(Se(198));
    ig || ((ig = !0), (tx = u));
  }
}
function Ul(n) {
  var e = n,
    t = n;
  if (n.alternate) for (; e.return; ) e = e.return;
  else {
    n = e;
    do (e = n), e.flags & 4098 && (t = e.return), (n = e.return);
    while (n);
  }
  return e.tag === 3 ? t : null;
}
function fR(n) {
  if (n.tag === 13) {
    var e = n.memoizedState;
    if (
      (e === null && ((n = n.alternate), n !== null && (e = n.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function ZE(n) {
  if (Ul(n) !== n) throw Error(Se(188));
}
function DF(n) {
  var e = n.alternate;
  if (!e) {
    if (((e = Ul(n)), e === null)) throw Error(Se(188));
    return e !== n ? null : n;
  }
  for (var t = n, r = e; ; ) {
    var i = t.return;
    if (i === null) break;
    var s = i.alternate;
    if (s === null) {
      if (((r = i.return), r !== null)) {
        t = r;
        continue;
      }
      break;
    }
    if (i.child === s.child) {
      for (s = i.child; s; ) {
        if (s === t) return ZE(i), n;
        if (s === r) return ZE(i), e;
        s = s.sibling;
      }
      throw Error(Se(188));
    }
    if (t.return !== r.return) (t = i), (r = s);
    else {
      for (var o = !1, a = i.child; a; ) {
        if (a === t) {
          (o = !0), (t = i), (r = s);
          break;
        }
        if (a === r) {
          (o = !0), (r = i), (t = s);
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === t) {
            (o = !0), (t = s), (r = i);
            break;
          }
          if (a === r) {
            (o = !0), (r = s), (t = i);
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(Se(189));
      }
    }
    if (t.alternate !== r) throw Error(Se(190));
  }
  if (t.tag !== 3) throw Error(Se(188));
  return t.stateNode.current === t ? n : e;
}
function hR(n) {
  return (n = DF(n)), n !== null ? dR(n) : null;
}
function dR(n) {
  if (n.tag === 5 || n.tag === 6) return n;
  for (n = n.child; n !== null; ) {
    var e = dR(n);
    if (e !== null) return e;
    n = n.sibling;
  }
  return null;
}
var pR = fi.unstable_scheduleCallback,
  $E = fi.unstable_cancelCallback,
  FF = fi.unstable_shouldYield,
  NF = fi.unstable_requestPaint,
  An = fi.unstable_now,
  OF = fi.unstable_getCurrentPriorityLevel,
  rA = fi.unstable_ImmediatePriority,
  mR = fi.unstable_UserBlockingPriority,
  sg = fi.unstable_NormalPriority,
  UF = fi.unstable_LowPriority,
  gR = fi.unstable_IdlePriority,
  jg = null,
  Rs = null;
function kF(n) {
  if (Rs && typeof Rs.onCommitFiberRoot == "function")
    try {
      Rs.onCommitFiberRoot(jg, n, void 0, (n.current.flags & 128) === 128);
    } catch {}
}
var ns = Math.clz32 ? Math.clz32 : GF,
  zF = Math.log,
  HF = Math.LN2;
function GF(n) {
  return (n >>>= 0), n === 0 ? 32 : (31 - ((zF(n) / HF) | 0)) | 0;
}
var Ap = 64,
  Mp = 4194304;
function Hf(n) {
  switch (n & -n) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return n & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return n;
  }
}
function og(n, e) {
  var t = n.pendingLanes;
  if (t === 0) return 0;
  var r = 0,
    i = n.suspendedLanes,
    s = n.pingedLanes,
    o = t & 268435455;
  if (o !== 0) {
    var a = o & ~i;
    a !== 0 ? (r = Hf(a)) : ((s &= o), s !== 0 && (r = Hf(s)));
  } else (o = t & ~i), o !== 0 ? (r = Hf(o)) : s !== 0 && (r = Hf(s));
  if (r === 0) return 0;
  if (
    e !== 0 &&
    e !== r &&
    !(e & i) &&
    ((i = r & -r), (s = e & -e), i >= s || (i === 16 && (s & 4194240) !== 0))
  )
    return e;
  if ((r & 4 && (r |= t & 16), (e = n.entangledLanes), e !== 0))
    for (n = n.entanglements, e &= r; 0 < e; )
      (t = 31 - ns(e)), (i = 1 << t), (r |= n[t]), (e &= ~i);
  return r;
}
function VF(n, e) {
  switch (n) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function WF(n, e) {
  for (
    var t = n.suspendedLanes,
      r = n.pingedLanes,
      i = n.expirationTimes,
      s = n.pendingLanes;
    0 < s;

  ) {
    var o = 31 - ns(s),
      a = 1 << o,
      l = i[o];
    l === -1
      ? (!(a & t) || a & r) && (i[o] = VF(a, e))
      : l <= e && (n.expiredLanes |= a),
      (s &= ~a);
  }
}
function nx(n) {
  return (
    (n = n.pendingLanes & -1073741825),
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
  );
}
function _R() {
  var n = Ap;
  return (Ap <<= 1), !(Ap & 4194240) && (Ap = 64), n;
}
function av(n) {
  for (var e = [], t = 0; 31 > t; t++) e.push(n);
  return e;
}
function qh(n, e, t) {
  (n.pendingLanes |= e),
    e !== 536870912 && ((n.suspendedLanes = 0), (n.pingedLanes = 0)),
    (n = n.eventTimes),
    (e = 31 - ns(e)),
    (n[e] = t);
}
function jF(n, e) {
  var t = n.pendingLanes & ~e;
  (n.pendingLanes = e),
    (n.suspendedLanes = 0),
    (n.pingedLanes = 0),
    (n.expiredLanes &= e),
    (n.mutableReadLanes &= e),
    (n.entangledLanes &= e),
    (e = n.entanglements);
  var r = n.eventTimes;
  for (n = n.expirationTimes; 0 < t; ) {
    var i = 31 - ns(t),
      s = 1 << i;
    (e[i] = 0), (r[i] = -1), (n[i] = -1), (t &= ~s);
  }
}
function iA(n, e) {
  var t = (n.entangledLanes |= e);
  for (n = n.entanglements; t; ) {
    var r = 31 - ns(t),
      i = 1 << r;
    (i & e) | (n[r] & e) && (n[r] |= e), (t &= ~i);
  }
}
var Ot = 0;
function vR(n) {
  return (n &= -n), 1 < n ? (4 < n ? (n & 268435455 ? 16 : 536870912) : 4) : 1;
}
var yR,
  sA,
  xR,
  SR,
  AR,
  rx = !1,
  Ep = [],
  ea = null,
  ta = null,
  na = null,
  dh = new Map(),
  ph = new Map(),
  Xo = [],
  XF =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function ew(n, e) {
  switch (n) {
    case "focusin":
    case "focusout":
      ea = null;
      break;
    case "dragenter":
    case "dragleave":
      ta = null;
      break;
    case "mouseover":
    case "mouseout":
      na = null;
      break;
    case "pointerover":
    case "pointerout":
      dh.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      ph.delete(e.pointerId);
  }
}
function gf(n, e, t, r, i, s) {
  return n === null || n.nativeEvent !== s
    ? ((n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: r,
        nativeEvent: s,
        targetContainers: [i],
      }),
      e !== null && ((e = $h(e)), e !== null && sA(e)),
      n)
    : ((n.eventSystemFlags |= r),
      (e = n.targetContainers),
      i !== null && e.indexOf(i) === -1 && e.push(i),
      n);
}
function JF(n, e, t, r, i) {
  switch (e) {
    case "focusin":
      return (ea = gf(ea, n, e, t, r, i)), !0;
    case "dragenter":
      return (ta = gf(ta, n, e, t, r, i)), !0;
    case "mouseover":
      return (na = gf(na, n, e, t, r, i)), !0;
    case "pointerover":
      var s = i.pointerId;
      return dh.set(s, gf(dh.get(s) || null, n, e, t, r, i)), !0;
    case "gotpointercapture":
      return (
        (s = i.pointerId), ph.set(s, gf(ph.get(s) || null, n, e, t, r, i)), !0
      );
  }
  return !1;
}
function MR(n) {
  var e = ll(n.target);
  if (e !== null) {
    var t = Ul(e);
    if (t !== null) {
      if (((e = t.tag), e === 13)) {
        if (((e = fR(t)), e !== null)) {
          (n.blockedOn = e),
            AR(n.priority, function () {
              xR(t);
            });
          return;
        }
      } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
        n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
        return;
      }
    }
  }
  n.blockedOn = null;
}
function Rm(n) {
  if (n.blockedOn !== null) return !1;
  for (var e = n.targetContainers; 0 < e.length; ) {
    var t = ix(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
    if (t === null) {
      t = n.nativeEvent;
      var r = new t.constructor(t.type, t);
      (Zy = r), t.target.dispatchEvent(r), (Zy = null);
    } else return (e = $h(t)), e !== null && sA(e), (n.blockedOn = t), !1;
    e.shift();
  }
  return !0;
}
function tw(n, e, t) {
  Rm(n) && t.delete(e);
}
function KF() {
  (rx = !1),
    ea !== null && Rm(ea) && (ea = null),
    ta !== null && Rm(ta) && (ta = null),
    na !== null && Rm(na) && (na = null),
    dh.forEach(tw),
    ph.forEach(tw);
}
function _f(n, e) {
  n.blockedOn === e &&
    ((n.blockedOn = null),
    rx ||
      ((rx = !0),
      fi.unstable_scheduleCallback(fi.unstable_NormalPriority, KF)));
}
function mh(n) {
  function e(i) {
    return _f(i, n);
  }
  if (0 < Ep.length) {
    _f(Ep[0], n);
    for (var t = 1; t < Ep.length; t++) {
      var r = Ep[t];
      r.blockedOn === n && (r.blockedOn = null);
    }
  }
  for (
    ea !== null && _f(ea, n),
      ta !== null && _f(ta, n),
      na !== null && _f(na, n),
      dh.forEach(e),
      ph.forEach(e),
      t = 0;
    t < Xo.length;
    t++
  )
    (r = Xo[t]), r.blockedOn === n && (r.blockedOn = null);
  for (; 0 < Xo.length && ((t = Xo[0]), t.blockedOn === null); )
    MR(t), t.blockedOn === null && Xo.shift();
}
var nc = So.ReactCurrentBatchConfig,
  ag = !0;
function YF(n, e, t, r) {
  var i = Ot,
    s = nc.transition;
  nc.transition = null;
  try {
    (Ot = 1), oA(n, e, t, r);
  } finally {
    (Ot = i), (nc.transition = s);
  }
}
function QF(n, e, t, r) {
  var i = Ot,
    s = nc.transition;
  nc.transition = null;
  try {
    (Ot = 4), oA(n, e, t, r);
  } finally {
    (Ot = i), (nc.transition = s);
  }
}
function oA(n, e, t, r) {
  if (ag) {
    var i = ix(n, e, t, r);
    if (i === null) _v(n, e, r, lg, t), ew(n, r);
    else if (JF(i, n, e, t, r)) r.stopPropagation();
    else if ((ew(n, r), e & 4 && -1 < XF.indexOf(n))) {
      for (; i !== null; ) {
        var s = $h(i);
        if (
          (s !== null && yR(s),
          (s = ix(n, e, t, r)),
          s === null && _v(n, e, r, lg, t),
          s === i)
        )
          break;
        i = s;
      }
      i !== null && r.stopPropagation();
    } else _v(n, e, r, null, t);
  }
}
var lg = null;
function ix(n, e, t, r) {
  if (((lg = null), (n = nA(r)), (n = ll(n)), n !== null))
    if (((e = Ul(n)), e === null)) n = null;
    else if (((t = e.tag), t === 13)) {
      if (((n = fR(e)), n !== null)) return n;
      n = null;
    } else if (t === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      n = null;
    } else e !== n && (n = null);
  return (lg = n), null;
}
function ER(n) {
  switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (OF()) {
        case rA:
          return 1;
        case mR:
          return 4;
        case sg:
        case UF:
          return 16;
        case gR:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var Ko = null,
  aA = null,
  Pm = null;
function wR() {
  if (Pm) return Pm;
  var n,
    e = aA,
    t = e.length,
    r,
    i = "value" in Ko ? Ko.value : Ko.textContent,
    s = i.length;
  for (n = 0; n < t && e[n] === i[n]; n++);
  var o = t - n;
  for (r = 1; r <= o && e[t - r] === i[s - r]; r++);
  return (Pm = i.slice(n, 1 < r ? 1 - r : void 0));
}
function Bm(n) {
  var e = n.keyCode;
  return (
    "charCode" in n
      ? ((n = n.charCode), n === 0 && e === 13 && (n = 13))
      : (n = e),
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
  );
}
function wp() {
  return !0;
}
function nw() {
  return !1;
}
function mi(n) {
  function e(t, r, i, s, o) {
    (this._reactName = t),
      (this._targetInst = i),
      (this.type = r),
      (this.nativeEvent = s),
      (this.target = o),
      (this.currentTarget = null);
    for (var a in n)
      n.hasOwnProperty(a) && ((t = n[a]), (this[a] = t ? t(s) : s[a]));
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? wp
        : nw),
      (this.isPropagationStopped = nw),
      this
    );
  }
  return (
    un(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var t = this.nativeEvent;
        t &&
          (t.preventDefault
            ? t.preventDefault()
            : typeof t.returnValue != "unknown" && (t.returnValue = !1),
          (this.isDefaultPrevented = wp));
      },
      stopPropagation: function () {
        var t = this.nativeEvent;
        t &&
          (t.stopPropagation
            ? t.stopPropagation()
            : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
          (this.isPropagationStopped = wp));
      },
      persist: function () {},
      isPersistent: wp,
    }),
    e
  );
}
var Uc = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (n) {
      return n.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  lA = mi(Uc),
  Zh = un({}, Uc, { view: 0, detail: 0 }),
  qF = mi(Zh),
  lv,
  uv,
  vf,
  Xg = un({}, Zh, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: uA,
    button: 0,
    buttons: 0,
    relatedTarget: function (n) {
      return n.relatedTarget === void 0
        ? n.fromElement === n.srcElement
          ? n.toElement
          : n.fromElement
        : n.relatedTarget;
    },
    movementX: function (n) {
      return "movementX" in n
        ? n.movementX
        : (n !== vf &&
            (vf && n.type === "mousemove"
              ? ((lv = n.screenX - vf.screenX), (uv = n.screenY - vf.screenY))
              : (uv = lv = 0),
            (vf = n)),
          lv);
    },
    movementY: function (n) {
      return "movementY" in n ? n.movementY : uv;
    },
  }),
  rw = mi(Xg),
  ZF = un({}, Xg, { dataTransfer: 0 }),
  $F = mi(ZF),
  e3 = un({}, Zh, { relatedTarget: 0 }),
  cv = mi(e3),
  t3 = un({}, Uc, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  n3 = mi(t3),
  r3 = un({}, Uc, {
    clipboardData: function (n) {
      return "clipboardData" in n ? n.clipboardData : window.clipboardData;
    },
  }),
  i3 = mi(r3),
  s3 = un({}, Uc, { data: 0 }),
  iw = mi(s3),
  o3 = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  a3 = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  l3 = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function u3(n) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(n) : (n = l3[n]) ? !!e[n] : !1;
}
function uA() {
  return u3;
}
var c3 = un({}, Zh, {
    key: function (n) {
      if (n.key) {
        var e = o3[n.key] || n.key;
        if (e !== "Unidentified") return e;
      }
      return n.type === "keypress"
        ? ((n = Bm(n)), n === 13 ? "Enter" : String.fromCharCode(n))
        : n.type === "keydown" || n.type === "keyup"
        ? a3[n.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: uA,
    charCode: function (n) {
      return n.type === "keypress" ? Bm(n) : 0;
    },
    keyCode: function (n) {
      return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    },
    which: function (n) {
      return n.type === "keypress"
        ? Bm(n)
        : n.type === "keydown" || n.type === "keyup"
        ? n.keyCode
        : 0;
    },
  }),
  f3 = mi(c3),
  h3 = un({}, Xg, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  sw = mi(h3),
  d3 = un({}, Zh, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: uA,
  }),
  p3 = mi(d3),
  m3 = un({}, Uc, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  g3 = mi(m3),
  _3 = un({}, Xg, {
    deltaX: function (n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function (n) {
      return "deltaY" in n
        ? n.deltaY
        : "wheelDeltaY" in n
        ? -n.wheelDeltaY
        : "wheelDelta" in n
        ? -n.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  v3 = mi(_3),
  y3 = [9, 13, 27, 32],
  cA = po && "CompositionEvent" in window,
  Yf = null;
po && "documentMode" in document && (Yf = document.documentMode);
var x3 = po && "TextEvent" in window && !Yf,
  CR = po && (!cA || (Yf && 8 < Yf && 11 >= Yf)),
  ow = String.fromCharCode(32),
  aw = !1;
function TR(n, e) {
  switch (n) {
    case "keyup":
      return y3.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function bR(n) {
  return (n = n.detail), typeof n == "object" && "data" in n ? n.data : null;
}
var Ou = !1;
function S3(n, e) {
  switch (n) {
    case "compositionend":
      return bR(e);
    case "keypress":
      return e.which !== 32 ? null : ((aw = !0), ow);
    case "textInput":
      return (n = e.data), n === ow && aw ? null : n;
    default:
      return null;
  }
}
function A3(n, e) {
  if (Ou)
    return n === "compositionend" || (!cA && TR(n, e))
      ? ((n = wR()), (Pm = aA = Ko = null), (Ou = !1), n)
      : null;
  switch (n) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return CR && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var M3 = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function lw(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return e === "input" ? !!M3[n.type] : e === "textarea";
}
function RR(n, e, t, r) {
  oR(r),
    (e = ug(e, "onChange")),
    0 < e.length &&
      ((t = new lA("onChange", "change", null, t, r)),
      n.push({ event: t, listeners: e }));
}
var Qf = null,
  gh = null;
function E3(n) {
  zR(n, 0);
}
function Jg(n) {
  var e = zu(n);
  if ($b(e)) return n;
}
function w3(n, e) {
  if (n === "change") return e;
}
var PR = !1;
if (po) {
  var fv;
  if (po) {
    var hv = "oninput" in document;
    if (!hv) {
      var uw = document.createElement("div");
      uw.setAttribute("oninput", "return;"),
        (hv = typeof uw.oninput == "function");
    }
    fv = hv;
  } else fv = !1;
  PR = fv && (!document.documentMode || 9 < document.documentMode);
}
function cw() {
  Qf && (Qf.detachEvent("onpropertychange", BR), (gh = Qf = null));
}
function BR(n) {
  if (n.propertyName === "value" && Jg(gh)) {
    var e = [];
    RR(e, gh, n, nA(n)), cR(E3, e);
  }
}
function C3(n, e, t) {
  n === "focusin"
    ? (cw(), (Qf = e), (gh = t), Qf.attachEvent("onpropertychange", BR))
    : n === "focusout" && cw();
}
function T3(n) {
  if (n === "selectionchange" || n === "keyup" || n === "keydown")
    return Jg(gh);
}
function b3(n, e) {
  if (n === "click") return Jg(e);
}
function R3(n, e) {
  if (n === "input" || n === "change") return Jg(e);
}
function P3(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var os = typeof Object.is == "function" ? Object.is : P3;
function _h(n, e) {
  if (os(n, e)) return !0;
  if (typeof n != "object" || n === null || typeof e != "object" || e === null)
    return !1;
  var t = Object.keys(n),
    r = Object.keys(e);
  if (t.length !== r.length) return !1;
  for (r = 0; r < t.length; r++) {
    var i = t[r];
    if (!zy.call(e, i) || !os(n[i], e[i])) return !1;
  }
  return !0;
}
function fw(n) {
  for (; n && n.firstChild; ) n = n.firstChild;
  return n;
}
function hw(n, e) {
  var t = fw(n);
  n = 0;
  for (var r; t; ) {
    if (t.nodeType === 3) {
      if (((r = n + t.textContent.length), n <= e && r >= e))
        return { node: t, offset: e - n };
      n = r;
    }
    e: {
      for (; t; ) {
        if (t.nextSibling) {
          t = t.nextSibling;
          break e;
        }
        t = t.parentNode;
      }
      t = void 0;
    }
    t = fw(t);
  }
}
function LR(n, e) {
  return n && e
    ? n === e
      ? !0
      : n && n.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? LR(n, e.parentNode)
      : "contains" in n
      ? n.contains(e)
      : n.compareDocumentPosition
      ? !!(n.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function IR() {
  for (var n = window, e = ng(); e instanceof n.HTMLIFrameElement; ) {
    try {
      var t = typeof e.contentWindow.location.href == "string";
    } catch {
      t = !1;
    }
    if (t) n = e.contentWindow;
    else break;
    e = ng(n.document);
  }
  return e;
}
function fA(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (n.type === "text" ||
        n.type === "search" ||
        n.type === "tel" ||
        n.type === "url" ||
        n.type === "password")) ||
      e === "textarea" ||
      n.contentEditable === "true")
  );
}
function B3(n) {
  var e = IR(),
    t = n.focusedElem,
    r = n.selectionRange;
  if (
    e !== t &&
    t &&
    t.ownerDocument &&
    LR(t.ownerDocument.documentElement, t)
  ) {
    if (r !== null && fA(t)) {
      if (
        ((e = r.start),
        (n = r.end),
        n === void 0 && (n = e),
        "selectionStart" in t)
      )
        (t.selectionStart = e), (t.selectionEnd = Math.min(n, t.value.length));
      else if (
        ((n = ((e = t.ownerDocument || document) && e.defaultView) || window),
        n.getSelection)
      ) {
        n = n.getSelection();
        var i = t.textContent.length,
          s = Math.min(r.start, i);
        (r = r.end === void 0 ? s : Math.min(r.end, i)),
          !n.extend && s > r && ((i = r), (r = s), (s = i)),
          (i = hw(t, s));
        var o = hw(t, r);
        i &&
          o &&
          (n.rangeCount !== 1 ||
            n.anchorNode !== i.node ||
            n.anchorOffset !== i.offset ||
            n.focusNode !== o.node ||
            n.focusOffset !== o.offset) &&
          ((e = e.createRange()),
          e.setStart(i.node, i.offset),
          n.removeAllRanges(),
          s > r
            ? (n.addRange(e), n.extend(o.node, o.offset))
            : (e.setEnd(o.node, o.offset), n.addRange(e)));
      }
    }
    for (e = [], n = t; (n = n.parentNode); )
      n.nodeType === 1 &&
        e.push({ element: n, left: n.scrollLeft, top: n.scrollTop });
    for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)
      (n = e[t]),
        (n.element.scrollLeft = n.left),
        (n.element.scrollTop = n.top);
  }
}
var L3 = po && "documentMode" in document && 11 >= document.documentMode,
  Uu = null,
  sx = null,
  qf = null,
  ox = !1;
function dw(n, e, t) {
  var r = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
  ox ||
    Uu == null ||
    Uu !== ng(r) ||
    ((r = Uu),
    "selectionStart" in r && fA(r)
      ? (r = { start: r.selectionStart, end: r.selectionEnd })
      : ((r = (
          (r.ownerDocument && r.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (r = {
          anchorNode: r.anchorNode,
          anchorOffset: r.anchorOffset,
          focusNode: r.focusNode,
          focusOffset: r.focusOffset,
        })),
    (qf && _h(qf, r)) ||
      ((qf = r),
      (r = ug(sx, "onSelect")),
      0 < r.length &&
        ((e = new lA("onSelect", "select", null, e, t)),
        n.push({ event: e, listeners: r }),
        (e.target = Uu))));
}
function Cp(n, e) {
  var t = {};
  return (
    (t[n.toLowerCase()] = e.toLowerCase()),
    (t["Webkit" + n] = "webkit" + e),
    (t["Moz" + n] = "moz" + e),
    t
  );
}
var ku = {
    animationend: Cp("Animation", "AnimationEnd"),
    animationiteration: Cp("Animation", "AnimationIteration"),
    animationstart: Cp("Animation", "AnimationStart"),
    transitionend: Cp("Transition", "TransitionEnd"),
  },
  dv = {},
  DR = {};
po &&
  ((DR = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete ku.animationend.animation,
    delete ku.animationiteration.animation,
    delete ku.animationstart.animation),
  "TransitionEvent" in window || delete ku.transitionend.transition);
function Kg(n) {
  if (dv[n]) return dv[n];
  if (!ku[n]) return n;
  var e = ku[n],
    t;
  for (t in e) if (e.hasOwnProperty(t) && t in DR) return (dv[n] = e[t]);
  return n;
}
var FR = Kg("animationend"),
  NR = Kg("animationiteration"),
  OR = Kg("animationstart"),
  UR = Kg("transitionend"),
  kR = new Map(),
  pw =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function wa(n, e) {
  kR.set(n, e), Ol(e, [n]);
}
for (var pv = 0; pv < pw.length; pv++) {
  var mv = pw[pv],
    I3 = mv.toLowerCase(),
    D3 = mv[0].toUpperCase() + mv.slice(1);
  wa(I3, "on" + D3);
}
wa(FR, "onAnimationEnd");
wa(NR, "onAnimationIteration");
wa(OR, "onAnimationStart");
wa("dblclick", "onDoubleClick");
wa("focusin", "onFocus");
wa("focusout", "onBlur");
wa(UR, "onTransitionEnd");
hc("onMouseEnter", ["mouseout", "mouseover"]);
hc("onMouseLeave", ["mouseout", "mouseover"]);
hc("onPointerEnter", ["pointerout", "pointerover"]);
hc("onPointerLeave", ["pointerout", "pointerover"]);
Ol(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
Ol(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
Ol("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Ol(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
Ol(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
Ol(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var Gf =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  F3 = new Set("cancel close invalid load scroll toggle".split(" ").concat(Gf));
function mw(n, e, t) {
  var r = n.type || "unknown-event";
  (n.currentTarget = t), IF(r, e, void 0, n), (n.currentTarget = null);
}
function zR(n, e) {
  e = (e & 4) !== 0;
  for (var t = 0; t < n.length; t++) {
    var r = n[t],
      i = r.event;
    r = r.listeners;
    e: {
      var s = void 0;
      if (e)
        for (var o = r.length - 1; 0 <= o; o--) {
          var a = r[o],
            l = a.instance,
            u = a.currentTarget;
          if (((a = a.listener), l !== s && i.isPropagationStopped())) break e;
          mw(i, a, u), (s = l);
        }
      else
        for (o = 0; o < r.length; o++) {
          if (
            ((a = r[o]),
            (l = a.instance),
            (u = a.currentTarget),
            (a = a.listener),
            l !== s && i.isPropagationStopped())
          )
            break e;
          mw(i, a, u), (s = l);
        }
    }
  }
  if (ig) throw ((n = tx), (ig = !1), (tx = null), n);
}
function Yt(n, e) {
  var t = e[fx];
  t === void 0 && (t = e[fx] = new Set());
  var r = n + "__bubble";
  t.has(r) || (HR(e, n, 2, !1), t.add(r));
}
function gv(n, e, t) {
  var r = 0;
  e && (r |= 4), HR(t, n, r, e);
}
var Tp = "_reactListening" + Math.random().toString(36).slice(2);
function vh(n) {
  if (!n[Tp]) {
    (n[Tp] = !0),
      Kb.forEach(function (t) {
        t !== "selectionchange" && (F3.has(t) || gv(t, !1, n), gv(t, !0, n));
      });
    var e = n.nodeType === 9 ? n : n.ownerDocument;
    e === null || e[Tp] || ((e[Tp] = !0), gv("selectionchange", !1, e));
  }
}
function HR(n, e, t, r) {
  switch (ER(e)) {
    case 1:
      var i = YF;
      break;
    case 4:
      i = QF;
      break;
    default:
      i = oA;
  }
  (t = i.bind(null, e, t, n)),
    (i = void 0),
    !ex ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (i = !0),
    r
      ? i !== void 0
        ? n.addEventListener(e, t, { capture: !0, passive: i })
        : n.addEventListener(e, t, !0)
      : i !== void 0
      ? n.addEventListener(e, t, { passive: i })
      : n.addEventListener(e, t, !1);
}
function _v(n, e, t, r, i) {
  var s = r;
  if (!(e & 1) && !(e & 2) && r !== null)
    e: for (;;) {
      if (r === null) return;
      var o = r.tag;
      if (o === 3 || o === 4) {
        var a = r.stateNode.containerInfo;
        if (a === i || (a.nodeType === 8 && a.parentNode === i)) break;
        if (o === 4)
          for (o = r.return; o !== null; ) {
            var l = o.tag;
            if (
              (l === 3 || l === 4) &&
              ((l = o.stateNode.containerInfo),
              l === i || (l.nodeType === 8 && l.parentNode === i))
            )
              return;
            o = o.return;
          }
        for (; a !== null; ) {
          if (((o = ll(a)), o === null)) return;
          if (((l = o.tag), l === 5 || l === 6)) {
            r = s = o;
            continue e;
          }
          a = a.parentNode;
        }
      }
      r = r.return;
    }
  cR(function () {
    var u = s,
      h = nA(t),
      d = [];
    e: {
      var p = kR.get(n);
      if (p !== void 0) {
        var m = lA,
          _ = n;
        switch (n) {
          case "keypress":
            if (Bm(t) === 0) break e;
          case "keydown":
          case "keyup":
            m = f3;
            break;
          case "focusin":
            (_ = "focus"), (m = cv);
            break;
          case "focusout":
            (_ = "blur"), (m = cv);
            break;
          case "beforeblur":
          case "afterblur":
            m = cv;
            break;
          case "click":
            if (t.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            m = rw;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            m = $F;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            m = p3;
            break;
          case FR:
          case NR:
          case OR:
            m = n3;
            break;
          case UR:
            m = g3;
            break;
          case "scroll":
            m = qF;
            break;
          case "wheel":
            m = v3;
            break;
          case "copy":
          case "cut":
          case "paste":
            m = i3;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            m = sw;
        }
        var y = (e & 4) !== 0,
          x = !y && n === "scroll",
          g = y ? (p !== null ? p + "Capture" : null) : p;
        y = [];
        for (var S = u, A; S !== null; ) {
          A = S;
          var E = A.stateNode;
          if (
            (A.tag === 5 &&
              E !== null &&
              ((A = E),
              g !== null && ((E = hh(S, g)), E != null && y.push(yh(S, E, A)))),
            x)
          )
            break;
          S = S.return;
        }
        0 < y.length &&
          ((p = new m(p, _, null, t, h)), d.push({ event: p, listeners: y }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((p = n === "mouseover" || n === "pointerover"),
          (m = n === "mouseout" || n === "pointerout"),
          p &&
            t !== Zy &&
            (_ = t.relatedTarget || t.fromElement) &&
            (ll(_) || _[mo]))
        )
          break e;
        if (
          (m || p) &&
          ((p =
            h.window === h
              ? h
              : (p = h.ownerDocument)
              ? p.defaultView || p.parentWindow
              : window),
          m
            ? ((_ = t.relatedTarget || t.toElement),
              (m = u),
              (_ = _ ? ll(_) : null),
              _ !== null &&
                ((x = Ul(_)), _ !== x || (_.tag !== 5 && _.tag !== 6)) &&
                (_ = null))
            : ((m = null), (_ = u)),
          m !== _)
        ) {
          if (
            ((y = rw),
            (E = "onMouseLeave"),
            (g = "onMouseEnter"),
            (S = "mouse"),
            (n === "pointerout" || n === "pointerover") &&
              ((y = sw),
              (E = "onPointerLeave"),
              (g = "onPointerEnter"),
              (S = "pointer")),
            (x = m == null ? p : zu(m)),
            (A = _ == null ? p : zu(_)),
            (p = new y(E, S + "leave", m, t, h)),
            (p.target = x),
            (p.relatedTarget = A),
            (E = null),
            ll(h) === u &&
              ((y = new y(g, S + "enter", _, t, h)),
              (y.target = A),
              (y.relatedTarget = x),
              (E = y)),
            (x = E),
            m && _)
          )
            t: {
              for (y = m, g = _, S = 0, A = y; A; A = su(A)) S++;
              for (A = 0, E = g; E; E = su(E)) A++;
              for (; 0 < S - A; ) (y = su(y)), S--;
              for (; 0 < A - S; ) (g = su(g)), A--;
              for (; S--; ) {
                if (y === g || (g !== null && y === g.alternate)) break t;
                (y = su(y)), (g = su(g));
              }
              y = null;
            }
          else y = null;
          m !== null && gw(d, p, m, y, !1),
            _ !== null && x !== null && gw(d, x, _, y, !0);
        }
      }
      e: {
        if (
          ((p = u ? zu(u) : window),
          (m = p.nodeName && p.nodeName.toLowerCase()),
          m === "select" || (m === "input" && p.type === "file"))
        )
          var C = w3;
        else if (lw(p))
          if (PR) C = R3;
          else {
            C = T3;
            var R = C3;
          }
        else
          (m = p.nodeName) &&
            m.toLowerCase() === "input" &&
            (p.type === "checkbox" || p.type === "radio") &&
            (C = b3);
        if (C && (C = C(n, u))) {
          RR(d, C, t, h);
          break e;
        }
        R && R(n, p, u),
          n === "focusout" &&
            (R = p._wrapperState) &&
            R.controlled &&
            p.type === "number" &&
            Jy(p, "number", p.value);
      }
      switch (((R = u ? zu(u) : window), n)) {
        case "focusin":
          (lw(R) || R.contentEditable === "true") &&
            ((Uu = R), (sx = u), (qf = null));
          break;
        case "focusout":
          qf = sx = Uu = null;
          break;
        case "mousedown":
          ox = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (ox = !1), dw(d, t, h);
          break;
        case "selectionchange":
          if (L3) break;
        case "keydown":
        case "keyup":
          dw(d, t, h);
      }
      var P;
      if (cA)
        e: {
          switch (n) {
            case "compositionstart":
              var L = "onCompositionStart";
              break e;
            case "compositionend":
              L = "onCompositionEnd";
              break e;
            case "compositionupdate":
              L = "onCompositionUpdate";
              break e;
          }
          L = void 0;
        }
      else
        Ou
          ? TR(n, t) && (L = "onCompositionEnd")
          : n === "keydown" && t.keyCode === 229 && (L = "onCompositionStart");
      L &&
        (CR &&
          t.locale !== "ko" &&
          (Ou || L !== "onCompositionStart"
            ? L === "onCompositionEnd" && Ou && (P = wR())
            : ((Ko = h),
              (aA = "value" in Ko ? Ko.value : Ko.textContent),
              (Ou = !0))),
        (R = ug(u, L)),
        0 < R.length &&
          ((L = new iw(L, n, null, t, h)),
          d.push({ event: L, listeners: R }),
          P ? (L.data = P) : ((P = bR(t)), P !== null && (L.data = P)))),
        (P = x3 ? S3(n, t) : A3(n, t)) &&
          ((u = ug(u, "onBeforeInput")),
          0 < u.length &&
            ((h = new iw("onBeforeInput", "beforeinput", null, t, h)),
            d.push({ event: h, listeners: u }),
            (h.data = P)));
    }
    zR(d, e);
  });
}
function yh(n, e, t) {
  return { instance: n, listener: e, currentTarget: t };
}
function ug(n, e) {
  for (var t = e + "Capture", r = []; n !== null; ) {
    var i = n,
      s = i.stateNode;
    i.tag === 5 &&
      s !== null &&
      ((i = s),
      (s = hh(n, t)),
      s != null && r.unshift(yh(n, s, i)),
      (s = hh(n, e)),
      s != null && r.push(yh(n, s, i))),
      (n = n.return);
  }
  return r;
}
function su(n) {
  if (n === null) return null;
  do n = n.return;
  while (n && n.tag !== 5);
  return n || null;
}
function gw(n, e, t, r, i) {
  for (var s = e._reactName, o = []; t !== null && t !== r; ) {
    var a = t,
      l = a.alternate,
      u = a.stateNode;
    if (l !== null && l === r) break;
    a.tag === 5 &&
      u !== null &&
      ((a = u),
      i
        ? ((l = hh(t, s)), l != null && o.unshift(yh(t, l, a)))
        : i || ((l = hh(t, s)), l != null && o.push(yh(t, l, a)))),
      (t = t.return);
  }
  o.length !== 0 && n.push({ event: e, listeners: o });
}
var N3 = /\r\n?/g,
  O3 = /\u0000|\uFFFD/g;
function _w(n) {
  return (typeof n == "string" ? n : "" + n)
    .replace(
      N3,
      `
`
    )
    .replace(O3, "");
}
function bp(n, e, t) {
  if (((e = _w(e)), _w(n) !== e && t)) throw Error(Se(425));
}
function cg() {}
var ax = null,
  lx = null;
function ux(n, e) {
  return (
    n === "textarea" ||
    n === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var cx = typeof setTimeout == "function" ? setTimeout : void 0,
  U3 = typeof clearTimeout == "function" ? clearTimeout : void 0,
  vw = typeof Promise == "function" ? Promise : void 0,
  k3 =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof vw < "u"
      ? function (n) {
          return vw.resolve(null).then(n).catch(z3);
        }
      : cx;
function z3(n) {
  setTimeout(function () {
    throw n;
  });
}
function vv(n, e) {
  var t = e,
    r = 0;
  do {
    var i = t.nextSibling;
    if ((n.removeChild(t), i && i.nodeType === 8))
      if (((t = i.data), t === "/$")) {
        if (r === 0) {
          n.removeChild(i), mh(e);
          return;
        }
        r--;
      } else (t !== "$" && t !== "$?" && t !== "$!") || r++;
    t = i;
  } while (t);
  mh(e);
}
function ra(n) {
  for (; n != null; n = n.nextSibling) {
    var e = n.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = n.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return n;
}
function yw(n) {
  n = n.previousSibling;
  for (var e = 0; n; ) {
    if (n.nodeType === 8) {
      var t = n.data;
      if (t === "$" || t === "$!" || t === "$?") {
        if (e === 0) return n;
        e--;
      } else t === "/$" && e++;
    }
    n = n.previousSibling;
  }
  return null;
}
var kc = Math.random().toString(36).slice(2),
  Ms = "__reactFiber$" + kc,
  xh = "__reactProps$" + kc,
  mo = "__reactContainer$" + kc,
  fx = "__reactEvents$" + kc,
  H3 = "__reactListeners$" + kc,
  G3 = "__reactHandles$" + kc;
function ll(n) {
  var e = n[Ms];
  if (e) return e;
  for (var t = n.parentNode; t; ) {
    if ((e = t[mo] || t[Ms])) {
      if (
        ((t = e.alternate),
        e.child !== null || (t !== null && t.child !== null))
      )
        for (n = yw(n); n !== null; ) {
          if ((t = n[Ms])) return t;
          n = yw(n);
        }
      return e;
    }
    (n = t), (t = n.parentNode);
  }
  return null;
}
function $h(n) {
  return (
    (n = n[Ms] || n[mo]),
    !n || (n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3) ? null : n
  );
}
function zu(n) {
  if (n.tag === 5 || n.tag === 6) return n.stateNode;
  throw Error(Se(33));
}
function Yg(n) {
  return n[xh] || null;
}
var hx = [],
  Hu = -1;
function Ca(n) {
  return { current: n };
}
function qt(n) {
  0 > Hu || ((n.current = hx[Hu]), (hx[Hu] = null), Hu--);
}
function Xt(n, e) {
  Hu++, (hx[Hu] = n.current), (n.current = e);
}
var _a = {},
  vr = Ca(_a),
  zr = Ca(!1),
  Tl = _a;
function dc(n, e) {
  var t = n.type.contextTypes;
  if (!t) return _a;
  var r = n.stateNode;
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === e)
    return r.__reactInternalMemoizedMaskedChildContext;
  var i = {},
    s;
  for (s in t) i[s] = e[s];
  return (
    r &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = e),
      (n.__reactInternalMemoizedMaskedChildContext = i)),
    i
  );
}
function Hr(n) {
  return (n = n.childContextTypes), n != null;
}
function fg() {
  qt(zr), qt(vr);
}
function xw(n, e, t) {
  if (vr.current !== _a) throw Error(Se(168));
  Xt(vr, e), Xt(zr, t);
}
function GR(n, e, t) {
  var r = n.stateNode;
  if (((e = e.childContextTypes), typeof r.getChildContext != "function"))
    return t;
  r = r.getChildContext();
  for (var i in r) if (!(i in e)) throw Error(Se(108, CF(n) || "Unknown", i));
  return un({}, t, r);
}
function hg(n) {
  return (
    (n =
      ((n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext) || _a),
    (Tl = vr.current),
    Xt(vr, n),
    Xt(zr, zr.current),
    !0
  );
}
function Sw(n, e, t) {
  var r = n.stateNode;
  if (!r) throw Error(Se(169));
  t
    ? ((n = GR(n, e, Tl)),
      (r.__reactInternalMemoizedMergedChildContext = n),
      qt(zr),
      qt(vr),
      Xt(vr, n))
    : qt(zr),
    Xt(zr, t);
}
var ro = null,
  Qg = !1,
  yv = !1;
function VR(n) {
  ro === null ? (ro = [n]) : ro.push(n);
}
function V3(n) {
  (Qg = !0), VR(n);
}
function Ta() {
  if (!yv && ro !== null) {
    yv = !0;
    var n = 0,
      e = Ot;
    try {
      var t = ro;
      for (Ot = 1; n < t.length; n++) {
        var r = t[n];
        do r = r(!0);
        while (r !== null);
      }
      (ro = null), (Qg = !1);
    } catch (i) {
      throw (ro !== null && (ro = ro.slice(n + 1)), pR(rA, Ta), i);
    } finally {
      (Ot = e), (yv = !1);
    }
  }
  return null;
}
var Gu = [],
  Vu = 0,
  dg = null,
  pg = 0,
  Pi = [],
  Bi = 0,
  bl = null,
  oo = 1,
  ao = "";
function el(n, e) {
  (Gu[Vu++] = pg), (Gu[Vu++] = dg), (dg = n), (pg = e);
}
function WR(n, e, t) {
  (Pi[Bi++] = oo), (Pi[Bi++] = ao), (Pi[Bi++] = bl), (bl = n);
  var r = oo;
  n = ao;
  var i = 32 - ns(r) - 1;
  (r &= ~(1 << i)), (t += 1);
  var s = 32 - ns(e) + i;
  if (30 < s) {
    var o = i - (i % 5);
    (s = (r & ((1 << o) - 1)).toString(32)),
      (r >>= o),
      (i -= o),
      (oo = (1 << (32 - ns(e) + i)) | (t << i) | r),
      (ao = s + n);
  } else (oo = (1 << s) | (t << i) | r), (ao = n);
}
function hA(n) {
  n.return !== null && (el(n, 1), WR(n, 1, 0));
}
function dA(n) {
  for (; n === dg; )
    (dg = Gu[--Vu]), (Gu[Vu] = null), (pg = Gu[--Vu]), (Gu[Vu] = null);
  for (; n === bl; )
    (bl = Pi[--Bi]),
      (Pi[Bi] = null),
      (ao = Pi[--Bi]),
      (Pi[Bi] = null),
      (oo = Pi[--Bi]),
      (Pi[Bi] = null);
}
var li = null,
  oi = null,
  $t = !1,
  es = null;
function jR(n, e) {
  var t = Ii(5, null, null, 0);
  (t.elementType = "DELETED"),
    (t.stateNode = e),
    (t.return = n),
    (e = n.deletions),
    e === null ? ((n.deletions = [t]), (n.flags |= 16)) : e.push(t);
}
function Aw(n, e) {
  switch (n.tag) {
    case 5:
      var t = n.type;
      return (
        (e =
          e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((n.stateNode = e), (li = n), (oi = ra(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = n.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((n.stateNode = e), (li = n), (oi = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((t = bl !== null ? { id: oo, overflow: ao } : null),
            (n.memoizedState = {
              dehydrated: e,
              treeContext: t,
              retryLane: 1073741824,
            }),
            (t = Ii(18, null, null, 0)),
            (t.stateNode = e),
            (t.return = n),
            (n.child = t),
            (li = n),
            (oi = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function dx(n) {
  return (n.mode & 1) !== 0 && (n.flags & 128) === 0;
}
function px(n) {
  if ($t) {
    var e = oi;
    if (e) {
      var t = e;
      if (!Aw(n, e)) {
        if (dx(n)) throw Error(Se(418));
        e = ra(t.nextSibling);
        var r = li;
        e && Aw(n, e)
          ? jR(r, t)
          : ((n.flags = (n.flags & -4097) | 2), ($t = !1), (li = n));
      }
    } else {
      if (dx(n)) throw Error(Se(418));
      (n.flags = (n.flags & -4097) | 2), ($t = !1), (li = n);
    }
  }
}
function Mw(n) {
  for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
    n = n.return;
  li = n;
}
function Rp(n) {
  if (n !== li) return !1;
  if (!$t) return Mw(n), ($t = !0), !1;
  var e;
  if (
    ((e = n.tag !== 3) &&
      !(e = n.tag !== 5) &&
      ((e = n.type),
      (e = e !== "head" && e !== "body" && !ux(n.type, n.memoizedProps))),
    e && (e = oi))
  ) {
    if (dx(n)) throw (XR(), Error(Se(418)));
    for (; e; ) jR(n, e), (e = ra(e.nextSibling));
  }
  if ((Mw(n), n.tag === 13)) {
    if (((n = n.memoizedState), (n = n !== null ? n.dehydrated : null), !n))
      throw Error(Se(317));
    e: {
      for (n = n.nextSibling, e = 0; n; ) {
        if (n.nodeType === 8) {
          var t = n.data;
          if (t === "/$") {
            if (e === 0) {
              oi = ra(n.nextSibling);
              break e;
            }
            e--;
          } else (t !== "$" && t !== "$!" && t !== "$?") || e++;
        }
        n = n.nextSibling;
      }
      oi = null;
    }
  } else oi = li ? ra(n.stateNode.nextSibling) : null;
  return !0;
}
function XR() {
  for (var n = oi; n; ) n = ra(n.nextSibling);
}
function pc() {
  (oi = li = null), ($t = !1);
}
function pA(n) {
  es === null ? (es = [n]) : es.push(n);
}
var W3 = So.ReactCurrentBatchConfig;
function qi(n, e) {
  if (n && n.defaultProps) {
    (e = un({}, e)), (n = n.defaultProps);
    for (var t in n) e[t] === void 0 && (e[t] = n[t]);
    return e;
  }
  return e;
}
var mg = Ca(null),
  gg = null,
  Wu = null,
  mA = null;
function gA() {
  mA = Wu = gg = null;
}
function _A(n) {
  var e = mg.current;
  qt(mg), (n._currentValue = e);
}
function mx(n, e, t) {
  for (; n !== null; ) {
    var r = n.alternate;
    if (
      ((n.childLanes & e) !== e
        ? ((n.childLanes |= e), r !== null && (r.childLanes |= e))
        : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e),
      n === t)
    )
      break;
    n = n.return;
  }
}
function rc(n, e) {
  (gg = n),
    (mA = Wu = null),
    (n = n.dependencies),
    n !== null &&
      n.firstContext !== null &&
      (n.lanes & e && (Ur = !0), (n.firstContext = null));
}
function ki(n) {
  var e = n._currentValue;
  if (mA !== n)
    if (((n = { context: n, memoizedValue: e, next: null }), Wu === null)) {
      if (gg === null) throw Error(Se(308));
      (Wu = n), (gg.dependencies = { lanes: 0, firstContext: n });
    } else Wu = Wu.next = n;
  return e;
}
var ul = null;
function vA(n) {
  ul === null ? (ul = [n]) : ul.push(n);
}
function JR(n, e, t, r) {
  var i = e.interleaved;
  return (
    i === null ? ((t.next = t), vA(e)) : ((t.next = i.next), (i.next = t)),
    (e.interleaved = t),
    go(n, r)
  );
}
function go(n, e) {
  n.lanes |= e;
  var t = n.alternate;
  for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null; )
    (n.childLanes |= e),
      (t = n.alternate),
      t !== null && (t.childLanes |= e),
      (t = n),
      (n = n.return);
  return t.tag === 3 ? t.stateNode : null;
}
var Vo = !1;
function yA(n) {
  n.updateQueue = {
    baseState: n.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function KR(n, e) {
  (n = n.updateQueue),
    e.updateQueue === n &&
      (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects,
      });
}
function co(n, e) {
  return {
    eventTime: n,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function ia(n, e, t) {
  var r = n.updateQueue;
  if (r === null) return null;
  if (((r = r.shared), Pt & 2)) {
    var i = r.pending;
    return (
      i === null ? (e.next = e) : ((e.next = i.next), (i.next = e)),
      (r.pending = e),
      go(n, t)
    );
  }
  return (
    (i = r.interleaved),
    i === null ? ((e.next = e), vA(r)) : ((e.next = i.next), (i.next = e)),
    (r.interleaved = e),
    go(n, t)
  );
}
function Lm(n, e, t) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (t & 4194240) !== 0))
  ) {
    var r = e.lanes;
    (r &= n.pendingLanes), (t |= r), (e.lanes = t), iA(n, t);
  }
}
function Ew(n, e) {
  var t = n.updateQueue,
    r = n.alternate;
  if (r !== null && ((r = r.updateQueue), t === r)) {
    var i = null,
      s = null;
    if (((t = t.firstBaseUpdate), t !== null)) {
      do {
        var o = {
          eventTime: t.eventTime,
          lane: t.lane,
          tag: t.tag,
          payload: t.payload,
          callback: t.callback,
          next: null,
        };
        s === null ? (i = s = o) : (s = s.next = o), (t = t.next);
      } while (t !== null);
      s === null ? (i = s = e) : (s = s.next = e);
    } else i = s = e;
    (t = {
      baseState: r.baseState,
      firstBaseUpdate: i,
      lastBaseUpdate: s,
      shared: r.shared,
      effects: r.effects,
    }),
      (n.updateQueue = t);
    return;
  }
  (n = t.lastBaseUpdate),
    n === null ? (t.firstBaseUpdate = e) : (n.next = e),
    (t.lastBaseUpdate = e);
}
function _g(n, e, t, r) {
  var i = n.updateQueue;
  Vo = !1;
  var s = i.firstBaseUpdate,
    o = i.lastBaseUpdate,
    a = i.shared.pending;
  if (a !== null) {
    i.shared.pending = null;
    var l = a,
      u = l.next;
    (l.next = null), o === null ? (s = u) : (o.next = u), (o = l);
    var h = n.alternate;
    h !== null &&
      ((h = h.updateQueue),
      (a = h.lastBaseUpdate),
      a !== o &&
        (a === null ? (h.firstBaseUpdate = u) : (a.next = u),
        (h.lastBaseUpdate = l)));
  }
  if (s !== null) {
    var d = i.baseState;
    (o = 0), (h = u = l = null), (a = s);
    do {
      var p = a.lane,
        m = a.eventTime;
      if ((r & p) === p) {
        h !== null &&
          (h = h.next =
            {
              eventTime: m,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
        e: {
          var _ = n,
            y = a;
          switch (((p = e), (m = t), y.tag)) {
            case 1:
              if (((_ = y.payload), typeof _ == "function")) {
                d = _.call(m, d, p);
                break e;
              }
              d = _;
              break e;
            case 3:
              _.flags = (_.flags & -65537) | 128;
            case 0:
              if (
                ((_ = y.payload),
                (p = typeof _ == "function" ? _.call(m, d, p) : _),
                p == null)
              )
                break e;
              d = un({}, d, p);
              break e;
            case 2:
              Vo = !0;
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((n.flags |= 64),
          (p = i.effects),
          p === null ? (i.effects = [a]) : p.push(a));
      } else
        (m = {
          eventTime: m,
          lane: p,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          h === null ? ((u = h = m), (l = d)) : (h = h.next = m),
          (o |= p);
      if (((a = a.next), a === null)) {
        if (((a = i.shared.pending), a === null)) break;
        (p = a),
          (a = p.next),
          (p.next = null),
          (i.lastBaseUpdate = p),
          (i.shared.pending = null);
      }
    } while (1);
    if (
      (h === null && (l = d),
      (i.baseState = l),
      (i.firstBaseUpdate = u),
      (i.lastBaseUpdate = h),
      (e = i.shared.interleaved),
      e !== null)
    ) {
      i = e;
      do (o |= i.lane), (i = i.next);
      while (i !== e);
    } else s === null && (i.shared.lanes = 0);
    (Pl |= o), (n.lanes = o), (n.memoizedState = d);
  }
}
function ww(n, e, t) {
  if (((n = e.effects), (e.effects = null), n !== null))
    for (e = 0; e < n.length; e++) {
      var r = n[e],
        i = r.callback;
      if (i !== null) {
        if (((r.callback = null), (r = t), typeof i != "function"))
          throw Error(Se(191, i));
        i.call(r);
      }
    }
}
var YR = new Jb.Component().refs;
function gx(n, e, t, r) {
  (e = n.memoizedState),
    (t = t(r, e)),
    (t = t == null ? e : un({}, e, t)),
    (n.memoizedState = t),
    n.lanes === 0 && (n.updateQueue.baseState = t);
}
var qg = {
  isMounted: function (n) {
    return (n = n._reactInternals) ? Ul(n) === n : !1;
  },
  enqueueSetState: function (n, e, t) {
    n = n._reactInternals;
    var r = Cr(),
      i = oa(n),
      s = co(r, i);
    (s.payload = e),
      t != null && (s.callback = t),
      (e = ia(n, s, i)),
      e !== null && (rs(e, n, i, r), Lm(e, n, i));
  },
  enqueueReplaceState: function (n, e, t) {
    n = n._reactInternals;
    var r = Cr(),
      i = oa(n),
      s = co(r, i);
    (s.tag = 1),
      (s.payload = e),
      t != null && (s.callback = t),
      (e = ia(n, s, i)),
      e !== null && (rs(e, n, i, r), Lm(e, n, i));
  },
  enqueueForceUpdate: function (n, e) {
    n = n._reactInternals;
    var t = Cr(),
      r = oa(n),
      i = co(t, r);
    (i.tag = 2),
      e != null && (i.callback = e),
      (e = ia(n, i, r)),
      e !== null && (rs(e, n, r, t), Lm(e, n, r));
  },
};
function Cw(n, e, t, r, i, s, o) {
  return (
    (n = n.stateNode),
    typeof n.shouldComponentUpdate == "function"
      ? n.shouldComponentUpdate(r, s, o)
      : e.prototype && e.prototype.isPureReactComponent
      ? !_h(t, r) || !_h(i, s)
      : !0
  );
}
function QR(n, e, t) {
  var r = !1,
    i = _a,
    s = e.contextType;
  return (
    typeof s == "object" && s !== null
      ? (s = ki(s))
      : ((i = Hr(e) ? Tl : vr.current),
        (r = e.contextTypes),
        (s = (r = r != null) ? dc(n, i) : _a)),
    (e = new e(t, s)),
    (n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = qg),
    (n.stateNode = e),
    (e._reactInternals = n),
    r &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = i),
      (n.__reactInternalMemoizedMaskedChildContext = s)),
    e
  );
}
function Tw(n, e, t, r) {
  (n = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(t, r),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(t, r),
    e.state !== n && qg.enqueueReplaceState(e, e.state, null);
}
function _x(n, e, t, r) {
  var i = n.stateNode;
  (i.props = t), (i.state = n.memoizedState), (i.refs = YR), yA(n);
  var s = e.contextType;
  typeof s == "object" && s !== null
    ? (i.context = ki(s))
    : ((s = Hr(e) ? Tl : vr.current), (i.context = dc(n, s))),
    (i.state = n.memoizedState),
    (s = e.getDerivedStateFromProps),
    typeof s == "function" && (gx(n, e, s, t), (i.state = n.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof i.getSnapshotBeforeUpdate == "function" ||
      (typeof i.UNSAFE_componentWillMount != "function" &&
        typeof i.componentWillMount != "function") ||
      ((e = i.state),
      typeof i.componentWillMount == "function" && i.componentWillMount(),
      typeof i.UNSAFE_componentWillMount == "function" &&
        i.UNSAFE_componentWillMount(),
      e !== i.state && qg.enqueueReplaceState(i, i.state, null),
      _g(n, t, i, r),
      (i.state = n.memoizedState)),
    typeof i.componentDidMount == "function" && (n.flags |= 4194308);
}
function yf(n, e, t) {
  if (
    ((n = t.ref), n !== null && typeof n != "function" && typeof n != "object")
  ) {
    if (t._owner) {
      if (((t = t._owner), t)) {
        if (t.tag !== 1) throw Error(Se(309));
        var r = t.stateNode;
      }
      if (!r) throw Error(Se(147, n));
      var i = r,
        s = "" + n;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === s
        ? e.ref
        : ((e = function (o) {
            var a = i.refs;
            a === YR && (a = i.refs = {}),
              o === null ? delete a[s] : (a[s] = o);
          }),
          (e._stringRef = s),
          e);
    }
    if (typeof n != "string") throw Error(Se(284));
    if (!t._owner) throw Error(Se(290, n));
  }
  return n;
}
function Pp(n, e) {
  throw (
    ((n = Object.prototype.toString.call(e)),
    Error(
      Se(
        31,
        n === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : n
      )
    ))
  );
}
function bw(n) {
  var e = n._init;
  return e(n._payload);
}
function qR(n) {
  function e(g, S) {
    if (n) {
      var A = g.deletions;
      A === null ? ((g.deletions = [S]), (g.flags |= 16)) : A.push(S);
    }
  }
  function t(g, S) {
    if (!n) return null;
    for (; S !== null; ) e(g, S), (S = S.sibling);
    return null;
  }
  function r(g, S) {
    for (g = new Map(); S !== null; )
      S.key !== null ? g.set(S.key, S) : g.set(S.index, S), (S = S.sibling);
    return g;
  }
  function i(g, S) {
    return (g = aa(g, S)), (g.index = 0), (g.sibling = null), g;
  }
  function s(g, S, A) {
    return (
      (g.index = A),
      n
        ? ((A = g.alternate),
          A !== null
            ? ((A = A.index), A < S ? ((g.flags |= 2), S) : A)
            : ((g.flags |= 2), S))
        : ((g.flags |= 1048576), S)
    );
  }
  function o(g) {
    return n && g.alternate === null && (g.flags |= 2), g;
  }
  function a(g, S, A, E) {
    return S === null || S.tag !== 6
      ? ((S = Cv(A, g.mode, E)), (S.return = g), S)
      : ((S = i(S, A)), (S.return = g), S);
  }
  function l(g, S, A, E) {
    var C = A.type;
    return C === Nu
      ? h(g, S, A.props.children, E, A.key)
      : S !== null &&
        (S.elementType === C ||
          (typeof C == "object" &&
            C !== null &&
            C.$$typeof === Go &&
            bw(C) === S.type))
      ? ((E = i(S, A.props)), (E.ref = yf(g, S, A)), (E.return = g), E)
      : ((E = Um(A.type, A.key, A.props, null, g.mode, E)),
        (E.ref = yf(g, S, A)),
        (E.return = g),
        E);
  }
  function u(g, S, A, E) {
    return S === null ||
      S.tag !== 4 ||
      S.stateNode.containerInfo !== A.containerInfo ||
      S.stateNode.implementation !== A.implementation
      ? ((S = Tv(A, g.mode, E)), (S.return = g), S)
      : ((S = i(S, A.children || [])), (S.return = g), S);
  }
  function h(g, S, A, E, C) {
    return S === null || S.tag !== 7
      ? ((S = vl(A, g.mode, E, C)), (S.return = g), S)
      : ((S = i(S, A)), (S.return = g), S);
  }
  function d(g, S, A) {
    if ((typeof S == "string" && S !== "") || typeof S == "number")
      return (S = Cv("" + S, g.mode, A)), (S.return = g), S;
    if (typeof S == "object" && S !== null) {
      switch (S.$$typeof) {
        case yp:
          return (
            (A = Um(S.type, S.key, S.props, null, g.mode, A)),
            (A.ref = yf(g, null, S)),
            (A.return = g),
            A
          );
        case Fu:
          return (S = Tv(S, g.mode, A)), (S.return = g), S;
        case Go:
          var E = S._init;
          return d(g, E(S._payload), A);
      }
      if (zf(S) || pf(S))
        return (S = vl(S, g.mode, A, null)), (S.return = g), S;
      Pp(g, S);
    }
    return null;
  }
  function p(g, S, A, E) {
    var C = S !== null ? S.key : null;
    if ((typeof A == "string" && A !== "") || typeof A == "number")
      return C !== null ? null : a(g, S, "" + A, E);
    if (typeof A == "object" && A !== null) {
      switch (A.$$typeof) {
        case yp:
          return A.key === C ? l(g, S, A, E) : null;
        case Fu:
          return A.key === C ? u(g, S, A, E) : null;
        case Go:
          return (C = A._init), p(g, S, C(A._payload), E);
      }
      if (zf(A) || pf(A)) return C !== null ? null : h(g, S, A, E, null);
      Pp(g, A);
    }
    return null;
  }
  function m(g, S, A, E, C) {
    if ((typeof E == "string" && E !== "") || typeof E == "number")
      return (g = g.get(A) || null), a(S, g, "" + E, C);
    if (typeof E == "object" && E !== null) {
      switch (E.$$typeof) {
        case yp:
          return (g = g.get(E.key === null ? A : E.key) || null), l(S, g, E, C);
        case Fu:
          return (g = g.get(E.key === null ? A : E.key) || null), u(S, g, E, C);
        case Go:
          var R = E._init;
          return m(g, S, A, R(E._payload), C);
      }
      if (zf(E) || pf(E)) return (g = g.get(A) || null), h(S, g, E, C, null);
      Pp(S, E);
    }
    return null;
  }
  function _(g, S, A, E) {
    for (
      var C = null, R = null, P = S, L = (S = 0), T = null;
      P !== null && L < A.length;
      L++
    ) {
      P.index > L ? ((T = P), (P = null)) : (T = P.sibling);
      var B = p(g, P, A[L], E);
      if (B === null) {
        P === null && (P = T);
        break;
      }
      n && P && B.alternate === null && e(g, P),
        (S = s(B, S, L)),
        R === null ? (C = B) : (R.sibling = B),
        (R = B),
        (P = T);
    }
    if (L === A.length) return t(g, P), $t && el(g, L), C;
    if (P === null) {
      for (; L < A.length; L++)
        (P = d(g, A[L], E)),
          P !== null &&
            ((S = s(P, S, L)), R === null ? (C = P) : (R.sibling = P), (R = P));
      return $t && el(g, L), C;
    }
    for (P = r(g, P); L < A.length; L++)
      (T = m(P, g, L, A[L], E)),
        T !== null &&
          (n && T.alternate !== null && P.delete(T.key === null ? L : T.key),
          (S = s(T, S, L)),
          R === null ? (C = T) : (R.sibling = T),
          (R = T));
    return (
      n &&
        P.forEach(function (D) {
          return e(g, D);
        }),
      $t && el(g, L),
      C
    );
  }
  function y(g, S, A, E) {
    var C = pf(A);
    if (typeof C != "function") throw Error(Se(150));
    if (((A = C.call(A)), A == null)) throw Error(Se(151));
    for (
      var R = (C = null), P = S, L = (S = 0), T = null, B = A.next();
      P !== null && !B.done;
      L++, B = A.next()
    ) {
      P.index > L ? ((T = P), (P = null)) : (T = P.sibling);
      var D = p(g, P, B.value, E);
      if (D === null) {
        P === null && (P = T);
        break;
      }
      n && P && D.alternate === null && e(g, P),
        (S = s(D, S, L)),
        R === null ? (C = D) : (R.sibling = D),
        (R = D),
        (P = T);
    }
    if (B.done) return t(g, P), $t && el(g, L), C;
    if (P === null) {
      for (; !B.done; L++, B = A.next())
        (B = d(g, B.value, E)),
          B !== null &&
            ((S = s(B, S, L)), R === null ? (C = B) : (R.sibling = B), (R = B));
      return $t && el(g, L), C;
    }
    for (P = r(g, P); !B.done; L++, B = A.next())
      (B = m(P, g, L, B.value, E)),
        B !== null &&
          (n && B.alternate !== null && P.delete(B.key === null ? L : B.key),
          (S = s(B, S, L)),
          R === null ? (C = B) : (R.sibling = B),
          (R = B));
    return (
      n &&
        P.forEach(function (I) {
          return e(g, I);
        }),
      $t && el(g, L),
      C
    );
  }
  function x(g, S, A, E) {
    if (
      (typeof A == "object" &&
        A !== null &&
        A.type === Nu &&
        A.key === null &&
        (A = A.props.children),
      typeof A == "object" && A !== null)
    ) {
      switch (A.$$typeof) {
        case yp:
          e: {
            for (var C = A.key, R = S; R !== null; ) {
              if (R.key === C) {
                if (((C = A.type), C === Nu)) {
                  if (R.tag === 7) {
                    t(g, R.sibling),
                      (S = i(R, A.props.children)),
                      (S.return = g),
                      (g = S);
                    break e;
                  }
                } else if (
                  R.elementType === C ||
                  (typeof C == "object" &&
                    C !== null &&
                    C.$$typeof === Go &&
                    bw(C) === R.type)
                ) {
                  t(g, R.sibling),
                    (S = i(R, A.props)),
                    (S.ref = yf(g, R, A)),
                    (S.return = g),
                    (g = S);
                  break e;
                }
                t(g, R);
                break;
              } else e(g, R);
              R = R.sibling;
            }
            A.type === Nu
              ? ((S = vl(A.props.children, g.mode, E, A.key)),
                (S.return = g),
                (g = S))
              : ((E = Um(A.type, A.key, A.props, null, g.mode, E)),
                (E.ref = yf(g, S, A)),
                (E.return = g),
                (g = E));
          }
          return o(g);
        case Fu:
          e: {
            for (R = A.key; S !== null; ) {
              if (S.key === R)
                if (
                  S.tag === 4 &&
                  S.stateNode.containerInfo === A.containerInfo &&
                  S.stateNode.implementation === A.implementation
                ) {
                  t(g, S.sibling),
                    (S = i(S, A.children || [])),
                    (S.return = g),
                    (g = S);
                  break e;
                } else {
                  t(g, S);
                  break;
                }
              else e(g, S);
              S = S.sibling;
            }
            (S = Tv(A, g.mode, E)), (S.return = g), (g = S);
          }
          return o(g);
        case Go:
          return (R = A._init), x(g, S, R(A._payload), E);
      }
      if (zf(A)) return _(g, S, A, E);
      if (pf(A)) return y(g, S, A, E);
      Pp(g, A);
    }
    return (typeof A == "string" && A !== "") || typeof A == "number"
      ? ((A = "" + A),
        S !== null && S.tag === 6
          ? (t(g, S.sibling), (S = i(S, A)), (S.return = g), (g = S))
          : (t(g, S), (S = Cv(A, g.mode, E)), (S.return = g), (g = S)),
        o(g))
      : t(g, S);
  }
  return x;
}
var mc = qR(!0),
  ZR = qR(!1),
  ed = {},
  Ps = Ca(ed),
  Sh = Ca(ed),
  Ah = Ca(ed);
function cl(n) {
  if (n === ed) throw Error(Se(174));
  return n;
}
function xA(n, e) {
  switch ((Xt(Ah, e), Xt(Sh, n), Xt(Ps, ed), (n = e.nodeType), n)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : Yy(null, "");
      break;
    default:
      (n = n === 8 ? e.parentNode : e),
        (e = n.namespaceURI || null),
        (n = n.tagName),
        (e = Yy(e, n));
  }
  qt(Ps), Xt(Ps, e);
}
function gc() {
  qt(Ps), qt(Sh), qt(Ah);
}
function $R(n) {
  cl(Ah.current);
  var e = cl(Ps.current),
    t = Yy(e, n.type);
  e !== t && (Xt(Sh, n), Xt(Ps, t));
}
function SA(n) {
  Sh.current === n && (qt(Ps), qt(Sh));
}
var nn = Ca(0);
function vg(n) {
  for (var e = n; e !== null; ) {
    if (e.tag === 13) {
      var t = e.memoizedState;
      if (
        t !== null &&
        ((t = t.dehydrated), t === null || t.data === "$?" || t.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === n) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === n) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var xv = [];
function AA() {
  for (var n = 0; n < xv.length; n++)
    xv[n]._workInProgressVersionPrimary = null;
  xv.length = 0;
}
var Im = So.ReactCurrentDispatcher,
  Sv = So.ReactCurrentBatchConfig,
  Rl = 0,
  ln = null,
  On = null,
  Jn = null,
  yg = !1,
  Zf = !1,
  Mh = 0,
  j3 = 0;
function ur() {
  throw Error(Se(321));
}
function MA(n, e) {
  if (e === null) return !1;
  for (var t = 0; t < e.length && t < n.length; t++)
    if (!os(n[t], e[t])) return !1;
  return !0;
}
function EA(n, e, t, r, i, s) {
  if (
    ((Rl = s),
    (ln = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (Im.current = n === null || n.memoizedState === null ? Y3 : Q3),
    (n = t(r, i)),
    Zf)
  ) {
    s = 0;
    do {
      if (((Zf = !1), (Mh = 0), 25 <= s)) throw Error(Se(301));
      (s += 1),
        (Jn = On = null),
        (e.updateQueue = null),
        (Im.current = q3),
        (n = t(r, i));
    } while (Zf);
  }
  if (
    ((Im.current = xg),
    (e = On !== null && On.next !== null),
    (Rl = 0),
    (Jn = On = ln = null),
    (yg = !1),
    e)
  )
    throw Error(Se(300));
  return n;
}
function wA() {
  var n = Mh !== 0;
  return (Mh = 0), n;
}
function As() {
  var n = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return Jn === null ? (ln.memoizedState = Jn = n) : (Jn = Jn.next = n), Jn;
}
function zi() {
  if (On === null) {
    var n = ln.alternate;
    n = n !== null ? n.memoizedState : null;
  } else n = On.next;
  var e = Jn === null ? ln.memoizedState : Jn.next;
  if (e !== null) (Jn = e), (On = n);
  else {
    if (n === null) throw Error(Se(310));
    (On = n),
      (n = {
        memoizedState: On.memoizedState,
        baseState: On.baseState,
        baseQueue: On.baseQueue,
        queue: On.queue,
        next: null,
      }),
      Jn === null ? (ln.memoizedState = Jn = n) : (Jn = Jn.next = n);
  }
  return Jn;
}
function Eh(n, e) {
  return typeof e == "function" ? e(n) : e;
}
function Av(n) {
  var e = zi(),
    t = e.queue;
  if (t === null) throw Error(Se(311));
  t.lastRenderedReducer = n;
  var r = On,
    i = r.baseQueue,
    s = t.pending;
  if (s !== null) {
    if (i !== null) {
      var o = i.next;
      (i.next = s.next), (s.next = o);
    }
    (r.baseQueue = i = s), (t.pending = null);
  }
  if (i !== null) {
    (s = i.next), (r = r.baseState);
    var a = (o = null),
      l = null,
      u = s;
    do {
      var h = u.lane;
      if ((Rl & h) === h)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: u.action,
              hasEagerState: u.hasEagerState,
              eagerState: u.eagerState,
              next: null,
            }),
          (r = u.hasEagerState ? u.eagerState : n(r, u.action));
      else {
        var d = {
          lane: h,
          action: u.action,
          hasEagerState: u.hasEagerState,
          eagerState: u.eagerState,
          next: null,
        };
        l === null ? ((a = l = d), (o = r)) : (l = l.next = d),
          (ln.lanes |= h),
          (Pl |= h);
      }
      u = u.next;
    } while (u !== null && u !== s);
    l === null ? (o = r) : (l.next = a),
      os(r, e.memoizedState) || (Ur = !0),
      (e.memoizedState = r),
      (e.baseState = o),
      (e.baseQueue = l),
      (t.lastRenderedState = r);
  }
  if (((n = t.interleaved), n !== null)) {
    i = n;
    do (s = i.lane), (ln.lanes |= s), (Pl |= s), (i = i.next);
    while (i !== n);
  } else i === null && (t.lanes = 0);
  return [e.memoizedState, t.dispatch];
}
function Mv(n) {
  var e = zi(),
    t = e.queue;
  if (t === null) throw Error(Se(311));
  t.lastRenderedReducer = n;
  var r = t.dispatch,
    i = t.pending,
    s = e.memoizedState;
  if (i !== null) {
    t.pending = null;
    var o = (i = i.next);
    do (s = n(s, o.action)), (o = o.next);
    while (o !== i);
    os(s, e.memoizedState) || (Ur = !0),
      (e.memoizedState = s),
      e.baseQueue === null && (e.baseState = s),
      (t.lastRenderedState = s);
  }
  return [s, r];
}
function eP() {}
function tP(n, e) {
  var t = ln,
    r = zi(),
    i = e(),
    s = !os(r.memoizedState, i);
  if (
    (s && ((r.memoizedState = i), (Ur = !0)),
    (r = r.queue),
    CA(iP.bind(null, t, r, n), [n]),
    r.getSnapshot !== e || s || (Jn !== null && Jn.memoizedState.tag & 1))
  ) {
    if (
      ((t.flags |= 2048),
      wh(9, rP.bind(null, t, r, i, e), void 0, null),
      Kn === null)
    )
      throw Error(Se(349));
    Rl & 30 || nP(t, e, i);
  }
  return i;
}
function nP(n, e, t) {
  (n.flags |= 16384),
    (n = { getSnapshot: e, value: t }),
    (e = ln.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (ln.updateQueue = e),
        (e.stores = [n]))
      : ((t = e.stores), t === null ? (e.stores = [n]) : t.push(n));
}
function rP(n, e, t, r) {
  (e.value = t), (e.getSnapshot = r), sP(e) && oP(n);
}
function iP(n, e, t) {
  return t(function () {
    sP(e) && oP(n);
  });
}
function sP(n) {
  var e = n.getSnapshot;
  n = n.value;
  try {
    var t = e();
    return !os(n, t);
  } catch {
    return !0;
  }
}
function oP(n) {
  var e = go(n, 1);
  e !== null && rs(e, n, 1, -1);
}
function Rw(n) {
  var e = As();
  return (
    typeof n == "function" && (n = n()),
    (e.memoizedState = e.baseState = n),
    (n = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Eh,
      lastRenderedState: n,
    }),
    (e.queue = n),
    (n = n.dispatch = K3.bind(null, ln, n)),
    [e.memoizedState, n]
  );
}
function wh(n, e, t, r) {
  return (
    (n = { tag: n, create: e, destroy: t, deps: r, next: null }),
    (e = ln.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (ln.updateQueue = e),
        (e.lastEffect = n.next = n))
      : ((t = e.lastEffect),
        t === null
          ? (e.lastEffect = n.next = n)
          : ((r = t.next), (t.next = n), (n.next = r), (e.lastEffect = n))),
    n
  );
}
function aP() {
  return zi().memoizedState;
}
function Dm(n, e, t, r) {
  var i = As();
  (ln.flags |= n),
    (i.memoizedState = wh(1 | e, t, void 0, r === void 0 ? null : r));
}
function Zg(n, e, t, r) {
  var i = zi();
  r = r === void 0 ? null : r;
  var s = void 0;
  if (On !== null) {
    var o = On.memoizedState;
    if (((s = o.destroy), r !== null && MA(r, o.deps))) {
      i.memoizedState = wh(e, t, s, r);
      return;
    }
  }
  (ln.flags |= n), (i.memoizedState = wh(1 | e, t, s, r));
}
function Pw(n, e) {
  return Dm(8390656, 8, n, e);
}
function CA(n, e) {
  return Zg(2048, 8, n, e);
}
function lP(n, e) {
  return Zg(4, 2, n, e);
}
function uP(n, e) {
  return Zg(4, 4, n, e);
}
function cP(n, e) {
  if (typeof e == "function")
    return (
      (n = n()),
      e(n),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (n = n()),
      (e.current = n),
      function () {
        e.current = null;
      }
    );
}
function fP(n, e, t) {
  return (
    (t = t != null ? t.concat([n]) : null), Zg(4, 4, cP.bind(null, e, n), t)
  );
}
function TA() {}
function hP(n, e) {
  var t = zi();
  e = e === void 0 ? null : e;
  var r = t.memoizedState;
  return r !== null && e !== null && MA(e, r[1])
    ? r[0]
    : ((t.memoizedState = [n, e]), n);
}
function dP(n, e) {
  var t = zi();
  e = e === void 0 ? null : e;
  var r = t.memoizedState;
  return r !== null && e !== null && MA(e, r[1])
    ? r[0]
    : ((n = n()), (t.memoizedState = [n, e]), n);
}
function pP(n, e, t) {
  return Rl & 21
    ? (os(t, e) || ((t = _R()), (ln.lanes |= t), (Pl |= t), (n.baseState = !0)),
      e)
    : (n.baseState && ((n.baseState = !1), (Ur = !0)), (n.memoizedState = t));
}
function X3(n, e) {
  var t = Ot;
  (Ot = t !== 0 && 4 > t ? t : 4), n(!0);
  var r = Sv.transition;
  Sv.transition = {};
  try {
    n(!1), e();
  } finally {
    (Ot = t), (Sv.transition = r);
  }
}
function mP() {
  return zi().memoizedState;
}
function J3(n, e, t) {
  var r = oa(n);
  if (
    ((t = {
      lane: r,
      action: t,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    gP(n))
  )
    _P(e, t);
  else if (((t = JR(n, e, t, r)), t !== null)) {
    var i = Cr();
    rs(t, n, r, i), vP(t, e, r);
  }
}
function K3(n, e, t) {
  var r = oa(n),
    i = { lane: r, action: t, hasEagerState: !1, eagerState: null, next: null };
  if (gP(n)) _P(e, i);
  else {
    var s = n.alternate;
    if (
      n.lanes === 0 &&
      (s === null || s.lanes === 0) &&
      ((s = e.lastRenderedReducer), s !== null)
    )
      try {
        var o = e.lastRenderedState,
          a = s(o, t);
        if (((i.hasEagerState = !0), (i.eagerState = a), os(a, o))) {
          var l = e.interleaved;
          l === null
            ? ((i.next = i), vA(e))
            : ((i.next = l.next), (l.next = i)),
            (e.interleaved = i);
          return;
        }
      } catch {
      } finally {
      }
    (t = JR(n, e, i, r)),
      t !== null && ((i = Cr()), rs(t, n, r, i), vP(t, e, r));
  }
}
function gP(n) {
  var e = n.alternate;
  return n === ln || (e !== null && e === ln);
}
function _P(n, e) {
  Zf = yg = !0;
  var t = n.pending;
  t === null ? (e.next = e) : ((e.next = t.next), (t.next = e)),
    (n.pending = e);
}
function vP(n, e, t) {
  if (t & 4194240) {
    var r = e.lanes;
    (r &= n.pendingLanes), (t |= r), (e.lanes = t), iA(n, t);
  }
}
var xg = {
    readContext: ki,
    useCallback: ur,
    useContext: ur,
    useEffect: ur,
    useImperativeHandle: ur,
    useInsertionEffect: ur,
    useLayoutEffect: ur,
    useMemo: ur,
    useReducer: ur,
    useRef: ur,
    useState: ur,
    useDebugValue: ur,
    useDeferredValue: ur,
    useTransition: ur,
    useMutableSource: ur,
    useSyncExternalStore: ur,
    useId: ur,
    unstable_isNewReconciler: !1,
  },
  Y3 = {
    readContext: ki,
    useCallback: function (n, e) {
      return (As().memoizedState = [n, e === void 0 ? null : e]), n;
    },
    useContext: ki,
    useEffect: Pw,
    useImperativeHandle: function (n, e, t) {
      return (
        (t = t != null ? t.concat([n]) : null),
        Dm(4194308, 4, cP.bind(null, e, n), t)
      );
    },
    useLayoutEffect: function (n, e) {
      return Dm(4194308, 4, n, e);
    },
    useInsertionEffect: function (n, e) {
      return Dm(4, 2, n, e);
    },
    useMemo: function (n, e) {
      var t = As();
      return (
        (e = e === void 0 ? null : e), (n = n()), (t.memoizedState = [n, e]), n
      );
    },
    useReducer: function (n, e, t) {
      var r = As();
      return (
        (e = t !== void 0 ? t(e) : e),
        (r.memoizedState = r.baseState = e),
        (n = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: n,
          lastRenderedState: e,
        }),
        (r.queue = n),
        (n = n.dispatch = J3.bind(null, ln, n)),
        [r.memoizedState, n]
      );
    },
    useRef: function (n) {
      var e = As();
      return (n = { current: n }), (e.memoizedState = n);
    },
    useState: Rw,
    useDebugValue: TA,
    useDeferredValue: function (n) {
      return (As().memoizedState = n);
    },
    useTransition: function () {
      var n = Rw(!1),
        e = n[0];
      return (n = X3.bind(null, n[1])), (As().memoizedState = n), [e, n];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (n, e, t) {
      var r = ln,
        i = As();
      if ($t) {
        if (t === void 0) throw Error(Se(407));
        t = t();
      } else {
        if (((t = e()), Kn === null)) throw Error(Se(349));
        Rl & 30 || nP(r, e, t);
      }
      i.memoizedState = t;
      var s = { value: t, getSnapshot: e };
      return (
        (i.queue = s),
        Pw(iP.bind(null, r, s, n), [n]),
        (r.flags |= 2048),
        wh(9, rP.bind(null, r, s, t, e), void 0, null),
        t
      );
    },
    useId: function () {
      var n = As(),
        e = Kn.identifierPrefix;
      if ($t) {
        var t = ao,
          r = oo;
        (t = (r & ~(1 << (32 - ns(r) - 1))).toString(32) + t),
          (e = ":" + e + "R" + t),
          (t = Mh++),
          0 < t && (e += "H" + t.toString(32)),
          (e += ":");
      } else (t = j3++), (e = ":" + e + "r" + t.toString(32) + ":");
      return (n.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  Q3 = {
    readContext: ki,
    useCallback: hP,
    useContext: ki,
    useEffect: CA,
    useImperativeHandle: fP,
    useInsertionEffect: lP,
    useLayoutEffect: uP,
    useMemo: dP,
    useReducer: Av,
    useRef: aP,
    useState: function () {
      return Av(Eh);
    },
    useDebugValue: TA,
    useDeferredValue: function (n) {
      var e = zi();
      return pP(e, On.memoizedState, n);
    },
    useTransition: function () {
      var n = Av(Eh)[0],
        e = zi().memoizedState;
      return [n, e];
    },
    useMutableSource: eP,
    useSyncExternalStore: tP,
    useId: mP,
    unstable_isNewReconciler: !1,
  },
  q3 = {
    readContext: ki,
    useCallback: hP,
    useContext: ki,
    useEffect: CA,
    useImperativeHandle: fP,
    useInsertionEffect: lP,
    useLayoutEffect: uP,
    useMemo: dP,
    useReducer: Mv,
    useRef: aP,
    useState: function () {
      return Mv(Eh);
    },
    useDebugValue: TA,
    useDeferredValue: function (n) {
      var e = zi();
      return On === null ? (e.memoizedState = n) : pP(e, On.memoizedState, n);
    },
    useTransition: function () {
      var n = Mv(Eh)[0],
        e = zi().memoizedState;
      return [n, e];
    },
    useMutableSource: eP,
    useSyncExternalStore: tP,
    useId: mP,
    unstable_isNewReconciler: !1,
  };
function _c(n, e) {
  try {
    var t = "",
      r = e;
    do (t += wF(r)), (r = r.return);
    while (r);
    var i = t;
  } catch (s) {
    i =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack;
  }
  return { value: n, source: e, stack: i, digest: null };
}
function Ev(n, e, t) {
  return { value: n, source: null, stack: t ?? null, digest: e ?? null };
}
function vx(n, e) {
  try {
    console.error(e.value);
  } catch (t) {
    setTimeout(function () {
      throw t;
    });
  }
}
var Z3 = typeof WeakMap == "function" ? WeakMap : Map;
function yP(n, e, t) {
  (t = co(-1, t)), (t.tag = 3), (t.payload = { element: null });
  var r = e.value;
  return (
    (t.callback = function () {
      Ag || ((Ag = !0), (bx = r)), vx(n, e);
    }),
    t
  );
}
function xP(n, e, t) {
  (t = co(-1, t)), (t.tag = 3);
  var r = n.type.getDerivedStateFromError;
  if (typeof r == "function") {
    var i = e.value;
    (t.payload = function () {
      return r(i);
    }),
      (t.callback = function () {
        vx(n, e);
      });
  }
  var s = n.stateNode;
  return (
    s !== null &&
      typeof s.componentDidCatch == "function" &&
      (t.callback = function () {
        vx(n, e),
          typeof r != "function" &&
            (sa === null ? (sa = new Set([this])) : sa.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: o !== null ? o : "",
        });
      }),
    t
  );
}
function Bw(n, e, t) {
  var r = n.pingCache;
  if (r === null) {
    r = n.pingCache = new Z3();
    var i = new Set();
    r.set(e, i);
  } else (i = r.get(e)), i === void 0 && ((i = new Set()), r.set(e, i));
  i.has(t) || (i.add(t), (n = hN.bind(null, n, e, t)), e.then(n, n));
}
function Lw(n) {
  do {
    var e;
    if (
      ((e = n.tag === 13) &&
        ((e = n.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return n;
    n = n.return;
  } while (n !== null);
  return null;
}
function Iw(n, e, t, r, i) {
  return n.mode & 1
    ? ((n.flags |= 65536), (n.lanes = i), n)
    : (n === e
        ? (n.flags |= 65536)
        : ((n.flags |= 128),
          (t.flags |= 131072),
          (t.flags &= -52805),
          t.tag === 1 &&
            (t.alternate === null
              ? (t.tag = 17)
              : ((e = co(-1, 1)), (e.tag = 2), ia(t, e, 1))),
          (t.lanes |= 1)),
      n);
}
var $3 = So.ReactCurrentOwner,
  Ur = !1;
function wr(n, e, t, r) {
  e.child = n === null ? ZR(e, null, t, r) : mc(e, n.child, t, r);
}
function Dw(n, e, t, r, i) {
  t = t.render;
  var s = e.ref;
  return (
    rc(e, i),
    (r = EA(n, e, t, r, s, i)),
    (t = wA()),
    n !== null && !Ur
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~i),
        _o(n, e, i))
      : ($t && t && hA(e), (e.flags |= 1), wr(n, e, r, i), e.child)
  );
}
function Fw(n, e, t, r, i) {
  if (n === null) {
    var s = t.type;
    return typeof s == "function" &&
      !FA(s) &&
      s.defaultProps === void 0 &&
      t.compare === null &&
      t.defaultProps === void 0
      ? ((e.tag = 15), (e.type = s), SP(n, e, s, r, i))
      : ((n = Um(t.type, null, r, e, e.mode, i)),
        (n.ref = e.ref),
        (n.return = e),
        (e.child = n));
  }
  if (((s = n.child), !(n.lanes & i))) {
    var o = s.memoizedProps;
    if (
      ((t = t.compare), (t = t !== null ? t : _h), t(o, r) && n.ref === e.ref)
    )
      return _o(n, e, i);
  }
  return (
    (e.flags |= 1),
    (n = aa(s, r)),
    (n.ref = e.ref),
    (n.return = e),
    (e.child = n)
  );
}
function SP(n, e, t, r, i) {
  if (n !== null) {
    var s = n.memoizedProps;
    if (_h(s, r) && n.ref === e.ref)
      if (((Ur = !1), (e.pendingProps = r = s), (n.lanes & i) !== 0))
        n.flags & 131072 && (Ur = !0);
      else return (e.lanes = n.lanes), _o(n, e, i);
  }
  return yx(n, e, t, r, i);
}
function AP(n, e, t) {
  var r = e.pendingProps,
    i = r.children,
    s = n !== null ? n.memoizedState : null;
  if (r.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        Xt(Xu, ri),
        (ri |= t);
    else {
      if (!(t & 1073741824))
        return (
          (n = s !== null ? s.baseLanes | t : t),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: n,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          Xt(Xu, ri),
          (ri |= n),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (r = s !== null ? s.baseLanes : t),
        Xt(Xu, ri),
        (ri |= r);
    }
  else
    s !== null ? ((r = s.baseLanes | t), (e.memoizedState = null)) : (r = t),
      Xt(Xu, ri),
      (ri |= r);
  return wr(n, e, i, t), e.child;
}
function MP(n, e) {
  var t = e.ref;
  ((n === null && t !== null) || (n !== null && n.ref !== t)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function yx(n, e, t, r, i) {
  var s = Hr(t) ? Tl : vr.current;
  return (
    (s = dc(e, s)),
    rc(e, i),
    (t = EA(n, e, t, r, s, i)),
    (r = wA()),
    n !== null && !Ur
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~i),
        _o(n, e, i))
      : ($t && r && hA(e), (e.flags |= 1), wr(n, e, t, i), e.child)
  );
}
function Nw(n, e, t, r, i) {
  if (Hr(t)) {
    var s = !0;
    hg(e);
  } else s = !1;
  if ((rc(e, i), e.stateNode === null))
    Fm(n, e), QR(e, t, r), _x(e, t, r, i), (r = !0);
  else if (n === null) {
    var o = e.stateNode,
      a = e.memoizedProps;
    o.props = a;
    var l = o.context,
      u = t.contextType;
    typeof u == "object" && u !== null
      ? (u = ki(u))
      : ((u = Hr(t) ? Tl : vr.current), (u = dc(e, u)));
    var h = t.getDerivedStateFromProps,
      d =
        typeof h == "function" ||
        typeof o.getSnapshotBeforeUpdate == "function";
    d ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== r || l !== u) && Tw(e, o, r, u)),
      (Vo = !1);
    var p = e.memoizedState;
    (o.state = p),
      _g(e, r, o, i),
      (l = e.memoizedState),
      a !== r || p !== l || zr.current || Vo
        ? (typeof h == "function" && (gx(e, t, h, r), (l = e.memoizedState)),
          (a = Vo || Cw(e, t, a, r, p, l, u))
            ? (d ||
                (typeof o.UNSAFE_componentWillMount != "function" &&
                  typeof o.componentWillMount != "function") ||
                (typeof o.componentWillMount == "function" &&
                  o.componentWillMount(),
                typeof o.UNSAFE_componentWillMount == "function" &&
                  o.UNSAFE_componentWillMount()),
              typeof o.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = r),
              (e.memoizedState = l)),
          (o.props = r),
          (o.state = l),
          (o.context = u),
          (r = a))
        : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
          (r = !1));
  } else {
    (o = e.stateNode),
      KR(n, e),
      (a = e.memoizedProps),
      (u = e.type === e.elementType ? a : qi(e.type, a)),
      (o.props = u),
      (d = e.pendingProps),
      (p = o.context),
      (l = t.contextType),
      typeof l == "object" && l !== null
        ? (l = ki(l))
        : ((l = Hr(t) ? Tl : vr.current), (l = dc(e, l)));
    var m = t.getDerivedStateFromProps;
    (h =
      typeof m == "function" ||
      typeof o.getSnapshotBeforeUpdate == "function") ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== d || p !== l) && Tw(e, o, r, l)),
      (Vo = !1),
      (p = e.memoizedState),
      (o.state = p),
      _g(e, r, o, i);
    var _ = e.memoizedState;
    a !== d || p !== _ || zr.current || Vo
      ? (typeof m == "function" && (gx(e, t, m, r), (_ = e.memoizedState)),
        (u = Vo || Cw(e, t, u, r, p, _, l) || !1)
          ? (h ||
              (typeof o.UNSAFE_componentWillUpdate != "function" &&
                typeof o.componentWillUpdate != "function") ||
              (typeof o.componentWillUpdate == "function" &&
                o.componentWillUpdate(r, _, l),
              typeof o.UNSAFE_componentWillUpdate == "function" &&
                o.UNSAFE_componentWillUpdate(r, _, l)),
            typeof o.componentDidUpdate == "function" && (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof o.componentDidUpdate != "function" ||
              (a === n.memoizedProps && p === n.memoizedState) ||
              (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate != "function" ||
              (a === n.memoizedProps && p === n.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = r),
            (e.memoizedState = _)),
        (o.props = r),
        (o.state = _),
        (o.context = l),
        (r = u))
      : (typeof o.componentDidUpdate != "function" ||
          (a === n.memoizedProps && p === n.memoizedState) ||
          (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" ||
          (a === n.memoizedProps && p === n.memoizedState) ||
          (e.flags |= 1024),
        (r = !1));
  }
  return xx(n, e, t, r, s, i);
}
function xx(n, e, t, r, i, s) {
  MP(n, e);
  var o = (e.flags & 128) !== 0;
  if (!r && !o) return i && Sw(e, t, !1), _o(n, e, s);
  (r = e.stateNode), ($3.current = e);
  var a =
    o && typeof t.getDerivedStateFromError != "function" ? null : r.render();
  return (
    (e.flags |= 1),
    n !== null && o
      ? ((e.child = mc(e, n.child, null, s)), (e.child = mc(e, null, a, s)))
      : wr(n, e, a, s),
    (e.memoizedState = r.state),
    i && Sw(e, t, !0),
    e.child
  );
}
function EP(n) {
  var e = n.stateNode;
  e.pendingContext
    ? xw(n, e.pendingContext, e.pendingContext !== e.context)
    : e.context && xw(n, e.context, !1),
    xA(n, e.containerInfo);
}
function Ow(n, e, t, r, i) {
  return pc(), pA(i), (e.flags |= 256), wr(n, e, t, r), e.child;
}
var Sx = { dehydrated: null, treeContext: null, retryLane: 0 };
function Ax(n) {
  return { baseLanes: n, cachePool: null, transitions: null };
}
function wP(n, e, t) {
  var r = e.pendingProps,
    i = nn.current,
    s = !1,
    o = (e.flags & 128) !== 0,
    a;
  if (
    ((a = o) ||
      (a = n !== null && n.memoizedState === null ? !1 : (i & 2) !== 0),
    a
      ? ((s = !0), (e.flags &= -129))
      : (n === null || n.memoizedState !== null) && (i |= 1),
    Xt(nn, i & 1),
    n === null)
  )
    return (
      px(e),
      (n = e.memoizedState),
      n !== null && ((n = n.dehydrated), n !== null)
        ? (e.mode & 1
            ? n.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((o = r.children),
          (n = r.fallback),
          s
            ? ((r = e.mode),
              (s = e.child),
              (o = { mode: "hidden", children: o }),
              !(r & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = o))
                : (s = t0(o, r, 0, null)),
              (n = vl(n, r, t, null)),
              (s.return = e),
              (n.return = e),
              (s.sibling = n),
              (e.child = s),
              (e.child.memoizedState = Ax(t)),
              (e.memoizedState = Sx),
              n)
            : bA(e, o))
    );
  if (((i = n.memoizedState), i !== null && ((a = i.dehydrated), a !== null)))
    return eN(n, e, o, r, a, i, t);
  if (s) {
    (s = r.fallback), (o = e.mode), (i = n.child), (a = i.sibling);
    var l = { mode: "hidden", children: r.children };
    return (
      !(o & 1) && e.child !== i
        ? ((r = e.child),
          (r.childLanes = 0),
          (r.pendingProps = l),
          (e.deletions = null))
        : ((r = aa(i, l)), (r.subtreeFlags = i.subtreeFlags & 14680064)),
      a !== null ? (s = aa(a, s)) : ((s = vl(s, o, t, null)), (s.flags |= 2)),
      (s.return = e),
      (r.return = e),
      (r.sibling = s),
      (e.child = r),
      (r = s),
      (s = e.child),
      (o = n.child.memoizedState),
      (o =
        o === null
          ? Ax(t)
          : {
              baseLanes: o.baseLanes | t,
              cachePool: null,
              transitions: o.transitions,
            }),
      (s.memoizedState = o),
      (s.childLanes = n.childLanes & ~t),
      (e.memoizedState = Sx),
      r
    );
  }
  return (
    (s = n.child),
    (n = s.sibling),
    (r = aa(s, { mode: "visible", children: r.children })),
    !(e.mode & 1) && (r.lanes = t),
    (r.return = e),
    (r.sibling = null),
    n !== null &&
      ((t = e.deletions),
      t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n)),
    (e.child = r),
    (e.memoizedState = null),
    r
  );
}
function bA(n, e) {
  return (
    (e = t0({ mode: "visible", children: e }, n.mode, 0, null)),
    (e.return = n),
    (n.child = e)
  );
}
function Bp(n, e, t, r) {
  return (
    r !== null && pA(r),
    mc(e, n.child, null, t),
    (n = bA(e, e.pendingProps.children)),
    (n.flags |= 2),
    (e.memoizedState = null),
    n
  );
}
function eN(n, e, t, r, i, s, o) {
  if (t)
    return e.flags & 256
      ? ((e.flags &= -257), (r = Ev(Error(Se(422)))), Bp(n, e, o, r))
      : e.memoizedState !== null
      ? ((e.child = n.child), (e.flags |= 128), null)
      : ((s = r.fallback),
        (i = e.mode),
        (r = t0({ mode: "visible", children: r.children }, i, 0, null)),
        (s = vl(s, i, o, null)),
        (s.flags |= 2),
        (r.return = e),
        (s.return = e),
        (r.sibling = s),
        (e.child = r),
        e.mode & 1 && mc(e, n.child, null, o),
        (e.child.memoizedState = Ax(o)),
        (e.memoizedState = Sx),
        s);
  if (!(e.mode & 1)) return Bp(n, e, o, null);
  if (i.data === "$!") {
    if (((r = i.nextSibling && i.nextSibling.dataset), r)) var a = r.dgst;
    return (
      (r = a), (s = Error(Se(419))), (r = Ev(s, r, void 0)), Bp(n, e, o, r)
    );
  }
  if (((a = (o & n.childLanes) !== 0), Ur || a)) {
    if (((r = Kn), r !== null)) {
      switch (o & -o) {
        case 4:
          i = 2;
          break;
        case 16:
          i = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32;
          break;
        case 536870912:
          i = 268435456;
          break;
        default:
          i = 0;
      }
      (i = i & (r.suspendedLanes | o) ? 0 : i),
        i !== 0 &&
          i !== s.retryLane &&
          ((s.retryLane = i), go(n, i), rs(r, n, i, -1));
    }
    return DA(), (r = Ev(Error(Se(421)))), Bp(n, e, o, r);
  }
  return i.data === "$?"
    ? ((e.flags |= 128),
      (e.child = n.child),
      (e = dN.bind(null, n)),
      (i._reactRetry = e),
      null)
    : ((n = s.treeContext),
      (oi = ra(i.nextSibling)),
      (li = e),
      ($t = !0),
      (es = null),
      n !== null &&
        ((Pi[Bi++] = oo),
        (Pi[Bi++] = ao),
        (Pi[Bi++] = bl),
        (oo = n.id),
        (ao = n.overflow),
        (bl = e)),
      (e = bA(e, r.children)),
      (e.flags |= 4096),
      e);
}
function Uw(n, e, t) {
  n.lanes |= e;
  var r = n.alternate;
  r !== null && (r.lanes |= e), mx(n.return, e, t);
}
function wv(n, e, t, r, i) {
  var s = n.memoizedState;
  s === null
    ? (n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: t,
        tailMode: i,
      })
    : ((s.isBackwards = e),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = r),
      (s.tail = t),
      (s.tailMode = i));
}
function CP(n, e, t) {
  var r = e.pendingProps,
    i = r.revealOrder,
    s = r.tail;
  if ((wr(n, e, r.children, t), (r = nn.current), r & 2))
    (r = (r & 1) | 2), (e.flags |= 128);
  else {
    if (n !== null && n.flags & 128)
      e: for (n = e.child; n !== null; ) {
        if (n.tag === 13) n.memoizedState !== null && Uw(n, t, e);
        else if (n.tag === 19) Uw(n, t, e);
        else if (n.child !== null) {
          (n.child.return = n), (n = n.child);
          continue;
        }
        if (n === e) break e;
        for (; n.sibling === null; ) {
          if (n.return === null || n.return === e) break e;
          n = n.return;
        }
        (n.sibling.return = n.return), (n = n.sibling);
      }
    r &= 1;
  }
  if ((Xt(nn, r), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (i) {
      case "forwards":
        for (t = e.child, i = null; t !== null; )
          (n = t.alternate),
            n !== null && vg(n) === null && (i = t),
            (t = t.sibling);
        (t = i),
          t === null
            ? ((i = e.child), (e.child = null))
            : ((i = t.sibling), (t.sibling = null)),
          wv(e, !1, i, t, s);
        break;
      case "backwards":
        for (t = null, i = e.child, e.child = null; i !== null; ) {
          if (((n = i.alternate), n !== null && vg(n) === null)) {
            e.child = i;
            break;
          }
          (n = i.sibling), (i.sibling = t), (t = i), (i = n);
        }
        wv(e, !0, t, null, s);
        break;
      case "together":
        wv(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function Fm(n, e) {
  !(e.mode & 1) &&
    n !== null &&
    ((n.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function _o(n, e, t) {
  if (
    (n !== null && (e.dependencies = n.dependencies),
    (Pl |= e.lanes),
    !(t & e.childLanes))
  )
    return null;
  if (n !== null && e.child !== n.child) throw Error(Se(153));
  if (e.child !== null) {
    for (
      n = e.child, t = aa(n, n.pendingProps), e.child = t, t.return = e;
      n.sibling !== null;

    )
      (n = n.sibling), (t = t.sibling = aa(n, n.pendingProps)), (t.return = e);
    t.sibling = null;
  }
  return e.child;
}
function tN(n, e, t) {
  switch (e.tag) {
    case 3:
      EP(e), pc();
      break;
    case 5:
      $R(e);
      break;
    case 1:
      Hr(e.type) && hg(e);
      break;
    case 4:
      xA(e, e.stateNode.containerInfo);
      break;
    case 10:
      var r = e.type._context,
        i = e.memoizedProps.value;
      Xt(mg, r._currentValue), (r._currentValue = i);
      break;
    case 13:
      if (((r = e.memoizedState), r !== null))
        return r.dehydrated !== null
          ? (Xt(nn, nn.current & 1), (e.flags |= 128), null)
          : t & e.child.childLanes
          ? wP(n, e, t)
          : (Xt(nn, nn.current & 1),
            (n = _o(n, e, t)),
            n !== null ? n.sibling : null);
      Xt(nn, nn.current & 1);
      break;
    case 19:
      if (((r = (t & e.childLanes) !== 0), n.flags & 128)) {
        if (r) return CP(n, e, t);
        e.flags |= 128;
      }
      if (
        ((i = e.memoizedState),
        i !== null &&
          ((i.rendering = null), (i.tail = null), (i.lastEffect = null)),
        Xt(nn, nn.current),
        r)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), AP(n, e, t);
  }
  return _o(n, e, t);
}
var TP, Mx, bP, RP;
TP = function (n, e) {
  for (var t = e.child; t !== null; ) {
    if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode);
    else if (t.tag !== 4 && t.child !== null) {
      (t.child.return = t), (t = t.child);
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return;
      t = t.return;
    }
    (t.sibling.return = t.return), (t = t.sibling);
  }
};
Mx = function () {};
bP = function (n, e, t, r) {
  var i = n.memoizedProps;
  if (i !== r) {
    (n = e.stateNode), cl(Ps.current);
    var s = null;
    switch (t) {
      case "input":
        (i = jy(n, i)), (r = jy(n, r)), (s = []);
        break;
      case "select":
        (i = un({}, i, { value: void 0 })),
          (r = un({}, r, { value: void 0 })),
          (s = []);
        break;
      case "textarea":
        (i = Ky(n, i)), (r = Ky(n, r)), (s = []);
        break;
      default:
        typeof i.onClick != "function" &&
          typeof r.onClick == "function" &&
          (n.onclick = cg);
    }
    Qy(t, r);
    var o;
    t = null;
    for (u in i)
      if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null)
        if (u === "style") {
          var a = i[u];
          for (o in a) a.hasOwnProperty(o) && (t || (t = {}), (t[o] = ""));
        } else
          u !== "dangerouslySetInnerHTML" &&
            u !== "children" &&
            u !== "suppressContentEditableWarning" &&
            u !== "suppressHydrationWarning" &&
            u !== "autoFocus" &&
            (ch.hasOwnProperty(u)
              ? s || (s = [])
              : (s = s || []).push(u, null));
    for (u in r) {
      var l = r[u];
      if (
        ((a = i != null ? i[u] : void 0),
        r.hasOwnProperty(u) && l !== a && (l != null || a != null))
      )
        if (u === "style")
          if (a) {
            for (o in a)
              !a.hasOwnProperty(o) ||
                (l && l.hasOwnProperty(o)) ||
                (t || (t = {}), (t[o] = ""));
            for (o in l)
              l.hasOwnProperty(o) &&
                a[o] !== l[o] &&
                (t || (t = {}), (t[o] = l[o]));
          } else t || (s || (s = []), s.push(u, t)), (t = l);
        else
          u === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (a = a ? a.__html : void 0),
              l != null && a !== l && (s = s || []).push(u, l))
            : u === "children"
            ? (typeof l != "string" && typeof l != "number") ||
              (s = s || []).push(u, "" + l)
            : u !== "suppressContentEditableWarning" &&
              u !== "suppressHydrationWarning" &&
              (ch.hasOwnProperty(u)
                ? (l != null && u === "onScroll" && Yt("scroll", n),
                  s || a === l || (s = []))
                : (s = s || []).push(u, l));
    }
    t && (s = s || []).push("style", t);
    var u = s;
    (e.updateQueue = u) && (e.flags |= 4);
  }
};
RP = function (n, e, t, r) {
  t !== r && (e.flags |= 4);
};
function xf(n, e) {
  if (!$t)
    switch (n.tailMode) {
      case "hidden":
        e = n.tail;
        for (var t = null; e !== null; )
          e.alternate !== null && (t = e), (e = e.sibling);
        t === null ? (n.tail = null) : (t.sibling = null);
        break;
      case "collapsed":
        t = n.tail;
        for (var r = null; t !== null; )
          t.alternate !== null && (r = t), (t = t.sibling);
        r === null
          ? e || n.tail === null
            ? (n.tail = null)
            : (n.tail.sibling = null)
          : (r.sibling = null);
    }
}
function cr(n) {
  var e = n.alternate !== null && n.alternate.child === n.child,
    t = 0,
    r = 0;
  if (e)
    for (var i = n.child; i !== null; )
      (t |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags & 14680064),
        (r |= i.flags & 14680064),
        (i.return = n),
        (i = i.sibling);
  else
    for (i = n.child; i !== null; )
      (t |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags),
        (r |= i.flags),
        (i.return = n),
        (i = i.sibling);
  return (n.subtreeFlags |= r), (n.childLanes = t), e;
}
function nN(n, e, t) {
  var r = e.pendingProps;
  switch ((dA(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return cr(e), null;
    case 1:
      return Hr(e.type) && fg(), cr(e), null;
    case 3:
      return (
        (r = e.stateNode),
        gc(),
        qt(zr),
        qt(vr),
        AA(),
        r.pendingContext &&
          ((r.context = r.pendingContext), (r.pendingContext = null)),
        (n === null || n.child === null) &&
          (Rp(e)
            ? (e.flags |= 4)
            : n === null ||
              (n.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), es !== null && (Bx(es), (es = null)))),
        Mx(n, e),
        cr(e),
        null
      );
    case 5:
      SA(e);
      var i = cl(Ah.current);
      if (((t = e.type), n !== null && e.stateNode != null))
        bP(n, e, t, r, i),
          n.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!r) {
          if (e.stateNode === null) throw Error(Se(166));
          return cr(e), null;
        }
        if (((n = cl(Ps.current)), Rp(e))) {
          (r = e.stateNode), (t = e.type);
          var s = e.memoizedProps;
          switch (((r[Ms] = e), (r[xh] = s), (n = (e.mode & 1) !== 0), t)) {
            case "dialog":
              Yt("cancel", r), Yt("close", r);
              break;
            case "iframe":
            case "object":
            case "embed":
              Yt("load", r);
              break;
            case "video":
            case "audio":
              for (i = 0; i < Gf.length; i++) Yt(Gf[i], r);
              break;
            case "source":
              Yt("error", r);
              break;
            case "img":
            case "image":
            case "link":
              Yt("error", r), Yt("load", r);
              break;
            case "details":
              Yt("toggle", r);
              break;
            case "input":
              JE(r, s), Yt("invalid", r);
              break;
            case "select":
              (r._wrapperState = { wasMultiple: !!s.multiple }),
                Yt("invalid", r);
              break;
            case "textarea":
              YE(r, s), Yt("invalid", r);
          }
          Qy(t, s), (i = null);
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var a = s[o];
              o === "children"
                ? typeof a == "string"
                  ? r.textContent !== a &&
                    (s.suppressHydrationWarning !== !0 &&
                      bp(r.textContent, a, n),
                    (i = ["children", a]))
                  : typeof a == "number" &&
                    r.textContent !== "" + a &&
                    (s.suppressHydrationWarning !== !0 &&
                      bp(r.textContent, a, n),
                    (i = ["children", "" + a]))
                : ch.hasOwnProperty(o) &&
                  a != null &&
                  o === "onScroll" &&
                  Yt("scroll", r);
            }
          switch (t) {
            case "input":
              xp(r), KE(r, s, !0);
              break;
            case "textarea":
              xp(r), QE(r);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (r.onclick = cg);
          }
          (r = i), (e.updateQueue = r), r !== null && (e.flags |= 4);
        } else {
          (o = i.nodeType === 9 ? i : i.ownerDocument),
            n === "http://www.w3.org/1999/xhtml" && (n = nR(t)),
            n === "http://www.w3.org/1999/xhtml"
              ? t === "script"
                ? ((n = o.createElement("div")),
                  (n.innerHTML = "<script></script>"),
                  (n = n.removeChild(n.firstChild)))
                : typeof r.is == "string"
                ? (n = o.createElement(t, { is: r.is }))
                : ((n = o.createElement(t)),
                  t === "select" &&
                    ((o = n),
                    r.multiple
                      ? (o.multiple = !0)
                      : r.size && (o.size = r.size)))
              : (n = o.createElementNS(n, t)),
            (n[Ms] = e),
            (n[xh] = r),
            TP(n, e, !1, !1),
            (e.stateNode = n);
          e: {
            switch (((o = qy(t, r)), t)) {
              case "dialog":
                Yt("cancel", n), Yt("close", n), (i = r);
                break;
              case "iframe":
              case "object":
              case "embed":
                Yt("load", n), (i = r);
                break;
              case "video":
              case "audio":
                for (i = 0; i < Gf.length; i++) Yt(Gf[i], n);
                i = r;
                break;
              case "source":
                Yt("error", n), (i = r);
                break;
              case "img":
              case "image":
              case "link":
                Yt("error", n), Yt("load", n), (i = r);
                break;
              case "details":
                Yt("toggle", n), (i = r);
                break;
              case "input":
                JE(n, r), (i = jy(n, r)), Yt("invalid", n);
                break;
              case "option":
                i = r;
                break;
              case "select":
                (n._wrapperState = { wasMultiple: !!r.multiple }),
                  (i = un({}, r, { value: void 0 })),
                  Yt("invalid", n);
                break;
              case "textarea":
                YE(n, r), (i = Ky(n, r)), Yt("invalid", n);
                break;
              default:
                i = r;
            }
            Qy(t, i), (a = i);
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var l = a[s];
                s === "style"
                  ? sR(n, l)
                  : s === "dangerouslySetInnerHTML"
                  ? ((l = l ? l.__html : void 0), l != null && rR(n, l))
                  : s === "children"
                  ? typeof l == "string"
                    ? (t !== "textarea" || l !== "") && fh(n, l)
                    : typeof l == "number" && fh(n, "" + l)
                  : s !== "suppressContentEditableWarning" &&
                    s !== "suppressHydrationWarning" &&
                    s !== "autoFocus" &&
                    (ch.hasOwnProperty(s)
                      ? l != null && s === "onScroll" && Yt("scroll", n)
                      : l != null && ZS(n, s, l, o));
              }
            switch (t) {
              case "input":
                xp(n), KE(n, r, !1);
                break;
              case "textarea":
                xp(n), QE(n);
                break;
              case "option":
                r.value != null && n.setAttribute("value", "" + ga(r.value));
                break;
              case "select":
                (n.multiple = !!r.multiple),
                  (s = r.value),
                  s != null
                    ? $u(n, !!r.multiple, s, !1)
                    : r.defaultValue != null &&
                      $u(n, !!r.multiple, r.defaultValue, !0);
                break;
              default:
                typeof i.onClick == "function" && (n.onclick = cg);
            }
            switch (t) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!r.autoFocus;
                break e;
              case "img":
                r = !0;
                break e;
              default:
                r = !1;
            }
          }
          r && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return cr(e), null;
    case 6:
      if (n && e.stateNode != null) RP(n, e, n.memoizedProps, r);
      else {
        if (typeof r != "string" && e.stateNode === null) throw Error(Se(166));
        if (((t = cl(Ah.current)), cl(Ps.current), Rp(e))) {
          if (
            ((r = e.stateNode),
            (t = e.memoizedProps),
            (r[Ms] = e),
            (s = r.nodeValue !== t) && ((n = li), n !== null))
          )
            switch (n.tag) {
              case 3:
                bp(r.nodeValue, t, (n.mode & 1) !== 0);
                break;
              case 5:
                n.memoizedProps.suppressHydrationWarning !== !0 &&
                  bp(r.nodeValue, t, (n.mode & 1) !== 0);
            }
          s && (e.flags |= 4);
        } else
          (r = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(r)),
            (r[Ms] = e),
            (e.stateNode = r);
      }
      return cr(e), null;
    case 13:
      if (
        (qt(nn),
        (r = e.memoizedState),
        n === null ||
          (n.memoizedState !== null && n.memoizedState.dehydrated !== null))
      ) {
        if ($t && oi !== null && e.mode & 1 && !(e.flags & 128))
          XR(), pc(), (e.flags |= 98560), (s = !1);
        else if (((s = Rp(e)), r !== null && r.dehydrated !== null)) {
          if (n === null) {
            if (!s) throw Error(Se(318));
            if (
              ((s = e.memoizedState),
              (s = s !== null ? s.dehydrated : null),
              !s)
            )
              throw Error(Se(317));
            s[Ms] = e;
          } else
            pc(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          cr(e), (s = !1);
        } else es !== null && (Bx(es), (es = null)), (s = !0);
        if (!s) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = t), e)
        : ((r = r !== null),
          r !== (n !== null && n.memoizedState !== null) &&
            r &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (n === null || nn.current & 1 ? Un === 0 && (Un = 3) : DA())),
          e.updateQueue !== null && (e.flags |= 4),
          cr(e),
          null);
    case 4:
      return (
        gc(), Mx(n, e), n === null && vh(e.stateNode.containerInfo), cr(e), null
      );
    case 10:
      return _A(e.type._context), cr(e), null;
    case 17:
      return Hr(e.type) && fg(), cr(e), null;
    case 19:
      if ((qt(nn), (s = e.memoizedState), s === null)) return cr(e), null;
      if (((r = (e.flags & 128) !== 0), (o = s.rendering), o === null))
        if (r) xf(s, !1);
        else {
          if (Un !== 0 || (n !== null && n.flags & 128))
            for (n = e.child; n !== null; ) {
              if (((o = vg(n)), o !== null)) {
                for (
                  e.flags |= 128,
                    xf(s, !1),
                    r = o.updateQueue,
                    r !== null && ((e.updateQueue = r), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    r = t,
                    t = e.child;
                  t !== null;

                )
                  (s = t),
                    (n = r),
                    (s.flags &= 14680066),
                    (o = s.alternate),
                    o === null
                      ? ((s.childLanes = 0),
                        (s.lanes = n),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = o.childLanes),
                        (s.lanes = o.lanes),
                        (s.child = o.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = o.memoizedProps),
                        (s.memoizedState = o.memoizedState),
                        (s.updateQueue = o.updateQueue),
                        (s.type = o.type),
                        (n = o.dependencies),
                        (s.dependencies =
                          n === null
                            ? null
                            : {
                                lanes: n.lanes,
                                firstContext: n.firstContext,
                              })),
                    (t = t.sibling);
                return Xt(nn, (nn.current & 1) | 2), e.child;
              }
              n = n.sibling;
            }
          s.tail !== null &&
            An() > vc &&
            ((e.flags |= 128), (r = !0), xf(s, !1), (e.lanes = 4194304));
        }
      else {
        if (!r)
          if (((n = vg(o)), n !== null)) {
            if (
              ((e.flags |= 128),
              (r = !0),
              (t = n.updateQueue),
              t !== null && ((e.updateQueue = t), (e.flags |= 4)),
              xf(s, !0),
              s.tail === null && s.tailMode === "hidden" && !o.alternate && !$t)
            )
              return cr(e), null;
          } else
            2 * An() - s.renderingStartTime > vc &&
              t !== 1073741824 &&
              ((e.flags |= 128), (r = !0), xf(s, !1), (e.lanes = 4194304));
        s.isBackwards
          ? ((o.sibling = e.child), (e.child = o))
          : ((t = s.last),
            t !== null ? (t.sibling = o) : (e.child = o),
            (s.last = o));
      }
      return s.tail !== null
        ? ((e = s.tail),
          (s.rendering = e),
          (s.tail = e.sibling),
          (s.renderingStartTime = An()),
          (e.sibling = null),
          (t = nn.current),
          Xt(nn, r ? (t & 1) | 2 : t & 1),
          e)
        : (cr(e), null);
    case 22:
    case 23:
      return (
        IA(),
        (r = e.memoizedState !== null),
        n !== null && (n.memoizedState !== null) !== r && (e.flags |= 8192),
        r && e.mode & 1
          ? ri & 1073741824 && (cr(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : cr(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(Se(156, e.tag));
}
function rN(n, e) {
  switch ((dA(e), e.tag)) {
    case 1:
      return (
        Hr(e.type) && fg(),
        (n = e.flags),
        n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 3:
      return (
        gc(),
        qt(zr),
        qt(vr),
        AA(),
        (n = e.flags),
        n & 65536 && !(n & 128) ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 5:
      return SA(e), null;
    case 13:
      if (
        (qt(nn), (n = e.memoizedState), n !== null && n.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(Se(340));
        pc();
      }
      return (
        (n = e.flags), n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 19:
      return qt(nn), null;
    case 4:
      return gc(), null;
    case 10:
      return _A(e.type._context), null;
    case 22:
    case 23:
      return IA(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Lp = !1,
  dr = !1,
  iN = typeof WeakSet == "function" ? WeakSet : Set,
  ke = null;
function ju(n, e) {
  var t = n.ref;
  if (t !== null)
    if (typeof t == "function")
      try {
        t(null);
      } catch (r) {
        pn(n, e, r);
      }
    else t.current = null;
}
function Ex(n, e, t) {
  try {
    t();
  } catch (r) {
    pn(n, e, r);
  }
}
var kw = !1;
function sN(n, e) {
  if (((ax = ag), (n = IR()), fA(n))) {
    if ("selectionStart" in n)
      var t = { start: n.selectionStart, end: n.selectionEnd };
    else
      e: {
        t = ((t = n.ownerDocument) && t.defaultView) || window;
        var r = t.getSelection && t.getSelection();
        if (r && r.rangeCount !== 0) {
          t = r.anchorNode;
          var i = r.anchorOffset,
            s = r.focusNode;
          r = r.focusOffset;
          try {
            t.nodeType, s.nodeType;
          } catch {
            t = null;
            break e;
          }
          var o = 0,
            a = -1,
            l = -1,
            u = 0,
            h = 0,
            d = n,
            p = null;
          t: for (;;) {
            for (
              var m;
              d !== t || (i !== 0 && d.nodeType !== 3) || (a = o + i),
                d !== s || (r !== 0 && d.nodeType !== 3) || (l = o + r),
                d.nodeType === 3 && (o += d.nodeValue.length),
                (m = d.firstChild) !== null;

            )
              (p = d), (d = m);
            for (;;) {
              if (d === n) break t;
              if (
                (p === t && ++u === i && (a = o),
                p === s && ++h === r && (l = o),
                (m = d.nextSibling) !== null)
              )
                break;
              (d = p), (p = d.parentNode);
            }
            d = m;
          }
          t = a === -1 || l === -1 ? null : { start: a, end: l };
        } else t = null;
      }
    t = t || { start: 0, end: 0 };
  } else t = null;
  for (
    lx = { focusedElem: n, selectionRange: t }, ag = !1, ke = e;
    ke !== null;

  )
    if (((e = ke), (n = e.child), (e.subtreeFlags & 1028) !== 0 && n !== null))
      (n.return = e), (ke = n);
    else
      for (; ke !== null; ) {
        e = ke;
        try {
          var _ = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (_ !== null) {
                  var y = _.memoizedProps,
                    x = _.memoizedState,
                    g = e.stateNode,
                    S = g.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? y : qi(e.type, y),
                      x
                    );
                  g.__reactInternalSnapshotBeforeUpdate = S;
                }
                break;
              case 3:
                var A = e.stateNode.containerInfo;
                A.nodeType === 1
                  ? (A.textContent = "")
                  : A.nodeType === 9 &&
                    A.documentElement &&
                    A.removeChild(A.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(Se(163));
            }
        } catch (E) {
          pn(e, e.return, E);
        }
        if (((n = e.sibling), n !== null)) {
          (n.return = e.return), (ke = n);
          break;
        }
        ke = e.return;
      }
  return (_ = kw), (kw = !1), _;
}
function $f(n, e, t) {
  var r = e.updateQueue;
  if (((r = r !== null ? r.lastEffect : null), r !== null)) {
    var i = (r = r.next);
    do {
      if ((i.tag & n) === n) {
        var s = i.destroy;
        (i.destroy = void 0), s !== void 0 && Ex(e, t, s);
      }
      i = i.next;
    } while (i !== r);
  }
}
function $g(n, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var t = (e = e.next);
    do {
      if ((t.tag & n) === n) {
        var r = t.create;
        t.destroy = r();
      }
      t = t.next;
    } while (t !== e);
  }
}
function wx(n) {
  var e = n.ref;
  if (e !== null) {
    var t = n.stateNode;
    switch (n.tag) {
      case 5:
        n = t;
        break;
      default:
        n = t;
    }
    typeof e == "function" ? e(n) : (e.current = n);
  }
}
function PP(n) {
  var e = n.alternate;
  e !== null && ((n.alternate = null), PP(e)),
    (n.child = null),
    (n.deletions = null),
    (n.sibling = null),
    n.tag === 5 &&
      ((e = n.stateNode),
      e !== null &&
        (delete e[Ms], delete e[xh], delete e[fx], delete e[H3], delete e[G3])),
    (n.stateNode = null),
    (n.return = null),
    (n.dependencies = null),
    (n.memoizedProps = null),
    (n.memoizedState = null),
    (n.pendingProps = null),
    (n.stateNode = null),
    (n.updateQueue = null);
}
function BP(n) {
  return n.tag === 5 || n.tag === 3 || n.tag === 4;
}
function zw(n) {
  e: for (;;) {
    for (; n.sibling === null; ) {
      if (n.return === null || BP(n.return)) return null;
      n = n.return;
    }
    for (
      n.sibling.return = n.return, n = n.sibling;
      n.tag !== 5 && n.tag !== 6 && n.tag !== 18;

    ) {
      if (n.flags & 2 || n.child === null || n.tag === 4) continue e;
      (n.child.return = n), (n = n.child);
    }
    if (!(n.flags & 2)) return n.stateNode;
  }
}
function Cx(n, e, t) {
  var r = n.tag;
  if (r === 5 || r === 6)
    (n = n.stateNode),
      e
        ? t.nodeType === 8
          ? t.parentNode.insertBefore(n, e)
          : t.insertBefore(n, e)
        : (t.nodeType === 8
            ? ((e = t.parentNode), e.insertBefore(n, t))
            : ((e = t), e.appendChild(n)),
          (t = t._reactRootContainer),
          t != null || e.onclick !== null || (e.onclick = cg));
  else if (r !== 4 && ((n = n.child), n !== null))
    for (Cx(n, e, t), n = n.sibling; n !== null; ) Cx(n, e, t), (n = n.sibling);
}
function Tx(n, e, t) {
  var r = n.tag;
  if (r === 5 || r === 6)
    (n = n.stateNode), e ? t.insertBefore(n, e) : t.appendChild(n);
  else if (r !== 4 && ((n = n.child), n !== null))
    for (Tx(n, e, t), n = n.sibling; n !== null; ) Tx(n, e, t), (n = n.sibling);
}
var Zn = null,
  $i = !1;
function Do(n, e, t) {
  for (t = t.child; t !== null; ) LP(n, e, t), (t = t.sibling);
}
function LP(n, e, t) {
  if (Rs && typeof Rs.onCommitFiberUnmount == "function")
    try {
      Rs.onCommitFiberUnmount(jg, t);
    } catch {}
  switch (t.tag) {
    case 5:
      dr || ju(t, e);
    case 6:
      var r = Zn,
        i = $i;
      (Zn = null),
        Do(n, e, t),
        (Zn = r),
        ($i = i),
        Zn !== null &&
          ($i
            ? ((n = Zn),
              (t = t.stateNode),
              n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t))
            : Zn.removeChild(t.stateNode));
      break;
    case 18:
      Zn !== null &&
        ($i
          ? ((n = Zn),
            (t = t.stateNode),
            n.nodeType === 8
              ? vv(n.parentNode, t)
              : n.nodeType === 1 && vv(n, t),
            mh(n))
          : vv(Zn, t.stateNode));
      break;
    case 4:
      (r = Zn),
        (i = $i),
        (Zn = t.stateNode.containerInfo),
        ($i = !0),
        Do(n, e, t),
        (Zn = r),
        ($i = i);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !dr &&
        ((r = t.updateQueue), r !== null && ((r = r.lastEffect), r !== null))
      ) {
        i = r = r.next;
        do {
          var s = i,
            o = s.destroy;
          (s = s.tag),
            o !== void 0 && (s & 2 || s & 4) && Ex(t, e, o),
            (i = i.next);
        } while (i !== r);
      }
      Do(n, e, t);
      break;
    case 1:
      if (
        !dr &&
        (ju(t, e),
        (r = t.stateNode),
        typeof r.componentWillUnmount == "function")
      )
        try {
          (r.props = t.memoizedProps),
            (r.state = t.memoizedState),
            r.componentWillUnmount();
        } catch (a) {
          pn(t, e, a);
        }
      Do(n, e, t);
      break;
    case 21:
      Do(n, e, t);
      break;
    case 22:
      t.mode & 1
        ? ((dr = (r = dr) || t.memoizedState !== null), Do(n, e, t), (dr = r))
        : Do(n, e, t);
      break;
    default:
      Do(n, e, t);
  }
}
function Hw(n) {
  var e = n.updateQueue;
  if (e !== null) {
    n.updateQueue = null;
    var t = n.stateNode;
    t === null && (t = n.stateNode = new iN()),
      e.forEach(function (r) {
        var i = pN.bind(null, n, r);
        t.has(r) || (t.add(r), r.then(i, i));
      });
  }
}
function Ji(n, e) {
  var t = e.deletions;
  if (t !== null)
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      try {
        var s = n,
          o = e,
          a = o;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              (Zn = a.stateNode), ($i = !1);
              break e;
            case 3:
              (Zn = a.stateNode.containerInfo), ($i = !0);
              break e;
            case 4:
              (Zn = a.stateNode.containerInfo), ($i = !0);
              break e;
          }
          a = a.return;
        }
        if (Zn === null) throw Error(Se(160));
        LP(s, o, i), (Zn = null), ($i = !1);
        var l = i.alternate;
        l !== null && (l.return = null), (i.return = null);
      } catch (u) {
        pn(i, e, u);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) IP(e, n), (e = e.sibling);
}
function IP(n, e) {
  var t = n.alternate,
    r = n.flags;
  switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((Ji(e, n), Ss(n), r & 4)) {
        try {
          $f(3, n, n.return), $g(3, n);
        } catch (y) {
          pn(n, n.return, y);
        }
        try {
          $f(5, n, n.return);
        } catch (y) {
          pn(n, n.return, y);
        }
      }
      break;
    case 1:
      Ji(e, n), Ss(n), r & 512 && t !== null && ju(t, t.return);
      break;
    case 5:
      if (
        (Ji(e, n),
        Ss(n),
        r & 512 && t !== null && ju(t, t.return),
        n.flags & 32)
      ) {
        var i = n.stateNode;
        try {
          fh(i, "");
        } catch (y) {
          pn(n, n.return, y);
        }
      }
      if (r & 4 && ((i = n.stateNode), i != null)) {
        var s = n.memoizedProps,
          o = t !== null ? t.memoizedProps : s,
          a = n.type,
          l = n.updateQueue;
        if (((n.updateQueue = null), l !== null))
          try {
            a === "input" && s.type === "radio" && s.name != null && eR(i, s),
              qy(a, o);
            var u = qy(a, s);
            for (o = 0; o < l.length; o += 2) {
              var h = l[o],
                d = l[o + 1];
              h === "style"
                ? sR(i, d)
                : h === "dangerouslySetInnerHTML"
                ? rR(i, d)
                : h === "children"
                ? fh(i, d)
                : ZS(i, h, d, u);
            }
            switch (a) {
              case "input":
                Xy(i, s);
                break;
              case "textarea":
                tR(i, s);
                break;
              case "select":
                var p = i._wrapperState.wasMultiple;
                i._wrapperState.wasMultiple = !!s.multiple;
                var m = s.value;
                m != null
                  ? $u(i, !!s.multiple, m, !1)
                  : p !== !!s.multiple &&
                    (s.defaultValue != null
                      ? $u(i, !!s.multiple, s.defaultValue, !0)
                      : $u(i, !!s.multiple, s.multiple ? [] : "", !1));
            }
            i[xh] = s;
          } catch (y) {
            pn(n, n.return, y);
          }
      }
      break;
    case 6:
      if ((Ji(e, n), Ss(n), r & 4)) {
        if (n.stateNode === null) throw Error(Se(162));
        (i = n.stateNode), (s = n.memoizedProps);
        try {
          i.nodeValue = s;
        } catch (y) {
          pn(n, n.return, y);
        }
      }
      break;
    case 3:
      if (
        (Ji(e, n), Ss(n), r & 4 && t !== null && t.memoizedState.isDehydrated)
      )
        try {
          mh(e.containerInfo);
        } catch (y) {
          pn(n, n.return, y);
        }
      break;
    case 4:
      Ji(e, n), Ss(n);
      break;
    case 13:
      Ji(e, n),
        Ss(n),
        (i = n.child),
        i.flags & 8192 &&
          ((s = i.memoizedState !== null),
          (i.stateNode.isHidden = s),
          !s ||
            (i.alternate !== null && i.alternate.memoizedState !== null) ||
            (BA = An())),
        r & 4 && Hw(n);
      break;
    case 22:
      if (
        ((h = t !== null && t.memoizedState !== null),
        n.mode & 1 ? ((dr = (u = dr) || h), Ji(e, n), (dr = u)) : Ji(e, n),
        Ss(n),
        r & 8192)
      ) {
        if (
          ((u = n.memoizedState !== null),
          (n.stateNode.isHidden = u) && !h && n.mode & 1)
        )
          for (ke = n, h = n.child; h !== null; ) {
            for (d = ke = h; ke !== null; ) {
              switch (((p = ke), (m = p.child), p.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  $f(4, p, p.return);
                  break;
                case 1:
                  ju(p, p.return);
                  var _ = p.stateNode;
                  if (typeof _.componentWillUnmount == "function") {
                    (r = p), (t = p.return);
                    try {
                      (e = r),
                        (_.props = e.memoizedProps),
                        (_.state = e.memoizedState),
                        _.componentWillUnmount();
                    } catch (y) {
                      pn(r, t, y);
                    }
                  }
                  break;
                case 5:
                  ju(p, p.return);
                  break;
                case 22:
                  if (p.memoizedState !== null) {
                    Vw(d);
                    continue;
                  }
              }
              m !== null ? ((m.return = p), (ke = m)) : Vw(d);
            }
            h = h.sibling;
          }
        e: for (h = null, d = n; ; ) {
          if (d.tag === 5) {
            if (h === null) {
              h = d;
              try {
                (i = d.stateNode),
                  u
                    ? ((s = i.style),
                      typeof s.setProperty == "function"
                        ? s.setProperty("display", "none", "important")
                        : (s.display = "none"))
                    : ((a = d.stateNode),
                      (l = d.memoizedProps.style),
                      (o =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (a.style.display = iR("display", o)));
              } catch (y) {
                pn(n, n.return, y);
              }
            }
          } else if (d.tag === 6) {
            if (h === null)
              try {
                d.stateNode.nodeValue = u ? "" : d.memoizedProps;
              } catch (y) {
                pn(n, n.return, y);
              }
          } else if (
            ((d.tag !== 22 && d.tag !== 23) ||
              d.memoizedState === null ||
              d === n) &&
            d.child !== null
          ) {
            (d.child.return = d), (d = d.child);
            continue;
          }
          if (d === n) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === n) break e;
            h === d && (h = null), (d = d.return);
          }
          h === d && (h = null), (d.sibling.return = d.return), (d = d.sibling);
        }
      }
      break;
    case 19:
      Ji(e, n), Ss(n), r & 4 && Hw(n);
      break;
    case 21:
      break;
    default:
      Ji(e, n), Ss(n);
  }
}
function Ss(n) {
  var e = n.flags;
  if (e & 2) {
    try {
      e: {
        for (var t = n.return; t !== null; ) {
          if (BP(t)) {
            var r = t;
            break e;
          }
          t = t.return;
        }
        throw Error(Se(160));
      }
      switch (r.tag) {
        case 5:
          var i = r.stateNode;
          r.flags & 32 && (fh(i, ""), (r.flags &= -33));
          var s = zw(n);
          Tx(n, s, i);
          break;
        case 3:
        case 4:
          var o = r.stateNode.containerInfo,
            a = zw(n);
          Cx(n, a, o);
          break;
        default:
          throw Error(Se(161));
      }
    } catch (l) {
      pn(n, n.return, l);
    }
    n.flags &= -3;
  }
  e & 4096 && (n.flags &= -4097);
}
function oN(n, e, t) {
  (ke = n), DP(n);
}
function DP(n, e, t) {
  for (var r = (n.mode & 1) !== 0; ke !== null; ) {
    var i = ke,
      s = i.child;
    if (i.tag === 22 && r) {
      var o = i.memoizedState !== null || Lp;
      if (!o) {
        var a = i.alternate,
          l = (a !== null && a.memoizedState !== null) || dr;
        a = Lp;
        var u = dr;
        if (((Lp = o), (dr = l) && !u))
          for (ke = i; ke !== null; )
            (o = ke),
              (l = o.child),
              o.tag === 22 && o.memoizedState !== null
                ? Ww(i)
                : l !== null
                ? ((l.return = o), (ke = l))
                : Ww(i);
        for (; s !== null; ) (ke = s), DP(s), (s = s.sibling);
        (ke = i), (Lp = a), (dr = u);
      }
      Gw(n);
    } else
      i.subtreeFlags & 8772 && s !== null ? ((s.return = i), (ke = s)) : Gw(n);
  }
}
function Gw(n) {
  for (; ke !== null; ) {
    var e = ke;
    if (e.flags & 8772) {
      var t = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              dr || $g(5, e);
              break;
            case 1:
              var r = e.stateNode;
              if (e.flags & 4 && !dr)
                if (t === null) r.componentDidMount();
                else {
                  var i =
                    e.elementType === e.type
                      ? t.memoizedProps
                      : qi(e.type, t.memoizedProps);
                  r.componentDidUpdate(
                    i,
                    t.memoizedState,
                    r.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var s = e.updateQueue;
              s !== null && ww(e, s, r);
              break;
            case 3:
              var o = e.updateQueue;
              if (o !== null) {
                if (((t = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      t = e.child.stateNode;
                      break;
                    case 1:
                      t = e.child.stateNode;
                  }
                ww(e, o, t);
              }
              break;
            case 5:
              var a = e.stateNode;
              if (t === null && e.flags & 4) {
                t = a;
                var l = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && t.focus();
                    break;
                  case "img":
                    l.src && (t.src = l.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var u = e.alternate;
                if (u !== null) {
                  var h = u.memoizedState;
                  if (h !== null) {
                    var d = h.dehydrated;
                    d !== null && mh(d);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(Se(163));
          }
        dr || (e.flags & 512 && wx(e));
      } catch (p) {
        pn(e, e.return, p);
      }
    }
    if (e === n) {
      ke = null;
      break;
    }
    if (((t = e.sibling), t !== null)) {
      (t.return = e.return), (ke = t);
      break;
    }
    ke = e.return;
  }
}
function Vw(n) {
  for (; ke !== null; ) {
    var e = ke;
    if (e === n) {
      ke = null;
      break;
    }
    var t = e.sibling;
    if (t !== null) {
      (t.return = e.return), (ke = t);
      break;
    }
    ke = e.return;
  }
}
function Ww(n) {
  for (; ke !== null; ) {
    var e = ke;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var t = e.return;
          try {
            $g(4, e);
          } catch (l) {
            pn(e, t, l);
          }
          break;
        case 1:
          var r = e.stateNode;
          if (typeof r.componentDidMount == "function") {
            var i = e.return;
            try {
              r.componentDidMount();
            } catch (l) {
              pn(e, i, l);
            }
          }
          var s = e.return;
          try {
            wx(e);
          } catch (l) {
            pn(e, s, l);
          }
          break;
        case 5:
          var o = e.return;
          try {
            wx(e);
          } catch (l) {
            pn(e, o, l);
          }
      }
    } catch (l) {
      pn(e, e.return, l);
    }
    if (e === n) {
      ke = null;
      break;
    }
    var a = e.sibling;
    if (a !== null) {
      (a.return = e.return), (ke = a);
      break;
    }
    ke = e.return;
  }
}
var aN = Math.ceil,
  Sg = So.ReactCurrentDispatcher,
  RA = So.ReactCurrentOwner,
  Oi = So.ReactCurrentBatchConfig,
  Pt = 0,
  Kn = null,
  Bn = null,
  tr = 0,
  ri = 0,
  Xu = Ca(0),
  Un = 0,
  Ch = null,
  Pl = 0,
  e0 = 0,
  PA = 0,
  eh = null,
  Dr = null,
  BA = 0,
  vc = 1 / 0,
  to = null,
  Ag = !1,
  bx = null,
  sa = null,
  Ip = !1,
  Yo = null,
  Mg = 0,
  th = 0,
  Rx = null,
  Nm = -1,
  Om = 0;
function Cr() {
  return Pt & 6 ? An() : Nm !== -1 ? Nm : (Nm = An());
}
function oa(n) {
  return n.mode & 1
    ? Pt & 2 && tr !== 0
      ? tr & -tr
      : W3.transition !== null
      ? (Om === 0 && (Om = _R()), Om)
      : ((n = Ot),
        n !== 0 || ((n = window.event), (n = n === void 0 ? 16 : ER(n.type))),
        n)
    : 1;
}
function rs(n, e, t, r) {
  if (50 < th) throw ((th = 0), (Rx = null), Error(Se(185)));
  qh(n, t, r),
    (!(Pt & 2) || n !== Kn) &&
      (n === Kn && (!(Pt & 2) && (e0 |= t), Un === 4 && Jo(n, tr)),
      Gr(n, r),
      t === 1 && Pt === 0 && !(e.mode & 1) && ((vc = An() + 500), Qg && Ta()));
}
function Gr(n, e) {
  var t = n.callbackNode;
  WF(n, e);
  var r = og(n, n === Kn ? tr : 0);
  if (r === 0)
    t !== null && $E(t), (n.callbackNode = null), (n.callbackPriority = 0);
  else if (((e = r & -r), n.callbackPriority !== e)) {
    if ((t != null && $E(t), e === 1))
      n.tag === 0 ? V3(jw.bind(null, n)) : VR(jw.bind(null, n)),
        k3(function () {
          !(Pt & 6) && Ta();
        }),
        (t = null);
    else {
      switch (vR(r)) {
        case 1:
          t = rA;
          break;
        case 4:
          t = mR;
          break;
        case 16:
          t = sg;
          break;
        case 536870912:
          t = gR;
          break;
        default:
          t = sg;
      }
      t = GP(t, FP.bind(null, n));
    }
    (n.callbackPriority = e), (n.callbackNode = t);
  }
}
function FP(n, e) {
  if (((Nm = -1), (Om = 0), Pt & 6)) throw Error(Se(327));
  var t = n.callbackNode;
  if (ic() && n.callbackNode !== t) return null;
  var r = og(n, n === Kn ? tr : 0);
  if (r === 0) return null;
  if (r & 30 || r & n.expiredLanes || e) e = Eg(n, r);
  else {
    e = r;
    var i = Pt;
    Pt |= 2;
    var s = OP();
    (Kn !== n || tr !== e) && ((to = null), (vc = An() + 500), _l(n, e));
    do
      try {
        cN();
        break;
      } catch (a) {
        NP(n, a);
      }
    while (1);
    gA(),
      (Sg.current = s),
      (Pt = i),
      Bn !== null ? (e = 0) : ((Kn = null), (tr = 0), (e = Un));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((i = nx(n)), i !== 0 && ((r = i), (e = Px(n, i)))), e === 1)
    )
      throw ((t = Ch), _l(n, 0), Jo(n, r), Gr(n, An()), t);
    if (e === 6) Jo(n, r);
    else {
      if (
        ((i = n.current.alternate),
        !(r & 30) &&
          !lN(i) &&
          ((e = Eg(n, r)),
          e === 2 && ((s = nx(n)), s !== 0 && ((r = s), (e = Px(n, s)))),
          e === 1))
      )
        throw ((t = Ch), _l(n, 0), Jo(n, r), Gr(n, An()), t);
      switch (((n.finishedWork = i), (n.finishedLanes = r), e)) {
        case 0:
        case 1:
          throw Error(Se(345));
        case 2:
          tl(n, Dr, to);
          break;
        case 3:
          if (
            (Jo(n, r), (r & 130023424) === r && ((e = BA + 500 - An()), 10 < e))
          ) {
            if (og(n, 0) !== 0) break;
            if (((i = n.suspendedLanes), (i & r) !== r)) {
              Cr(), (n.pingedLanes |= n.suspendedLanes & i);
              break;
            }
            n.timeoutHandle = cx(tl.bind(null, n, Dr, to), e);
            break;
          }
          tl(n, Dr, to);
          break;
        case 4:
          if ((Jo(n, r), (r & 4194240) === r)) break;
          for (e = n.eventTimes, i = -1; 0 < r; ) {
            var o = 31 - ns(r);
            (s = 1 << o), (o = e[o]), o > i && (i = o), (r &= ~s);
          }
          if (
            ((r = i),
            (r = An() - r),
            (r =
              (120 > r
                ? 120
                : 480 > r
                ? 480
                : 1080 > r
                ? 1080
                : 1920 > r
                ? 1920
                : 3e3 > r
                ? 3e3
                : 4320 > r
                ? 4320
                : 1960 * aN(r / 1960)) - r),
            10 < r)
          ) {
            n.timeoutHandle = cx(tl.bind(null, n, Dr, to), r);
            break;
          }
          tl(n, Dr, to);
          break;
        case 5:
          tl(n, Dr, to);
          break;
        default:
          throw Error(Se(329));
      }
    }
  }
  return Gr(n, An()), n.callbackNode === t ? FP.bind(null, n) : null;
}
function Px(n, e) {
  var t = eh;
  return (
    n.current.memoizedState.isDehydrated && (_l(n, e).flags |= 256),
    (n = Eg(n, e)),
    n !== 2 && ((e = Dr), (Dr = t), e !== null && Bx(e)),
    n
  );
}
function Bx(n) {
  Dr === null ? (Dr = n) : Dr.push.apply(Dr, n);
}
function lN(n) {
  for (var e = n; ; ) {
    if (e.flags & 16384) {
      var t = e.updateQueue;
      if (t !== null && ((t = t.stores), t !== null))
        for (var r = 0; r < t.length; r++) {
          var i = t[r],
            s = i.getSnapshot;
          i = i.value;
          try {
            if (!os(s(), i)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((t = e.child), e.subtreeFlags & 16384 && t !== null))
      (t.return = e), (e = t);
    else {
      if (e === n) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === n) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function Jo(n, e) {
  for (
    e &= ~PA,
      e &= ~e0,
      n.suspendedLanes |= e,
      n.pingedLanes &= ~e,
      n = n.expirationTimes;
    0 < e;

  ) {
    var t = 31 - ns(e),
      r = 1 << t;
    (n[t] = -1), (e &= ~r);
  }
}
function jw(n) {
  if (Pt & 6) throw Error(Se(327));
  ic();
  var e = og(n, 0);
  if (!(e & 1)) return Gr(n, An()), null;
  var t = Eg(n, e);
  if (n.tag !== 0 && t === 2) {
    var r = nx(n);
    r !== 0 && ((e = r), (t = Px(n, r)));
  }
  if (t === 1) throw ((t = Ch), _l(n, 0), Jo(n, e), Gr(n, An()), t);
  if (t === 6) throw Error(Se(345));
  return (
    (n.finishedWork = n.current.alternate),
    (n.finishedLanes = e),
    tl(n, Dr, to),
    Gr(n, An()),
    null
  );
}
function LA(n, e) {
  var t = Pt;
  Pt |= 1;
  try {
    return n(e);
  } finally {
    (Pt = t), Pt === 0 && ((vc = An() + 500), Qg && Ta());
  }
}
function Bl(n) {
  Yo !== null && Yo.tag === 0 && !(Pt & 6) && ic();
  var e = Pt;
  Pt |= 1;
  var t = Oi.transition,
    r = Ot;
  try {
    if (((Oi.transition = null), (Ot = 1), n)) return n();
  } finally {
    (Ot = r), (Oi.transition = t), (Pt = e), !(Pt & 6) && Ta();
  }
}
function IA() {
  (ri = Xu.current), qt(Xu);
}
function _l(n, e) {
  (n.finishedWork = null), (n.finishedLanes = 0);
  var t = n.timeoutHandle;
  if ((t !== -1 && ((n.timeoutHandle = -1), U3(t)), Bn !== null))
    for (t = Bn.return; t !== null; ) {
      var r = t;
      switch ((dA(r), r.tag)) {
        case 1:
          (r = r.type.childContextTypes), r != null && fg();
          break;
        case 3:
          gc(), qt(zr), qt(vr), AA();
          break;
        case 5:
          SA(r);
          break;
        case 4:
          gc();
          break;
        case 13:
          qt(nn);
          break;
        case 19:
          qt(nn);
          break;
        case 10:
          _A(r.type._context);
          break;
        case 22:
        case 23:
          IA();
      }
      t = t.return;
    }
  if (
    ((Kn = n),
    (Bn = n = aa(n.current, null)),
    (tr = ri = e),
    (Un = 0),
    (Ch = null),
    (PA = e0 = Pl = 0),
    (Dr = eh = null),
    ul !== null)
  ) {
    for (e = 0; e < ul.length; e++)
      if (((t = ul[e]), (r = t.interleaved), r !== null)) {
        t.interleaved = null;
        var i = r.next,
          s = t.pending;
        if (s !== null) {
          var o = s.next;
          (s.next = i), (r.next = o);
        }
        t.pending = r;
      }
    ul = null;
  }
  return n;
}
function NP(n, e) {
  do {
    var t = Bn;
    try {
      if ((gA(), (Im.current = xg), yg)) {
        for (var r = ln.memoizedState; r !== null; ) {
          var i = r.queue;
          i !== null && (i.pending = null), (r = r.next);
        }
        yg = !1;
      }
      if (
        ((Rl = 0),
        (Jn = On = ln = null),
        (Zf = !1),
        (Mh = 0),
        (RA.current = null),
        t === null || t.return === null)
      ) {
        (Un = 1), (Ch = e), (Bn = null);
        break;
      }
      e: {
        var s = n,
          o = t.return,
          a = t,
          l = e;
        if (
          ((e = tr),
          (a.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var u = l,
            h = a,
            d = h.tag;
          if (!(h.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var p = h.alternate;
            p
              ? ((h.updateQueue = p.updateQueue),
                (h.memoizedState = p.memoizedState),
                (h.lanes = p.lanes))
              : ((h.updateQueue = null), (h.memoizedState = null));
          }
          var m = Lw(o);
          if (m !== null) {
            (m.flags &= -257),
              Iw(m, o, a, s, e),
              m.mode & 1 && Bw(s, u, e),
              (e = m),
              (l = u);
            var _ = e.updateQueue;
            if (_ === null) {
              var y = new Set();
              y.add(l), (e.updateQueue = y);
            } else _.add(l);
            break e;
          } else {
            if (!(e & 1)) {
              Bw(s, u, e), DA();
              break e;
            }
            l = Error(Se(426));
          }
        } else if ($t && a.mode & 1) {
          var x = Lw(o);
          if (x !== null) {
            !(x.flags & 65536) && (x.flags |= 256),
              Iw(x, o, a, s, e),
              pA(_c(l, a));
            break e;
          }
        }
        (s = l = _c(l, a)),
          Un !== 4 && (Un = 2),
          eh === null ? (eh = [s]) : eh.push(s),
          (s = o);
        do {
          switch (s.tag) {
            case 3:
              (s.flags |= 65536), (e &= -e), (s.lanes |= e);
              var g = yP(s, l, e);
              Ew(s, g);
              break e;
            case 1:
              a = l;
              var S = s.type,
                A = s.stateNode;
              if (
                !(s.flags & 128) &&
                (typeof S.getDerivedStateFromError == "function" ||
                  (A !== null &&
                    typeof A.componentDidCatch == "function" &&
                    (sa === null || !sa.has(A))))
              ) {
                (s.flags |= 65536), (e &= -e), (s.lanes |= e);
                var E = xP(s, a, e);
                Ew(s, E);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      kP(t);
    } catch (C) {
      (e = C), Bn === t && t !== null && (Bn = t = t.return);
      continue;
    }
    break;
  } while (1);
}
function OP() {
  var n = Sg.current;
  return (Sg.current = xg), n === null ? xg : n;
}
function DA() {
  (Un === 0 || Un === 3 || Un === 2) && (Un = 4),
    Kn === null || (!(Pl & 268435455) && !(e0 & 268435455)) || Jo(Kn, tr);
}
function Eg(n, e) {
  var t = Pt;
  Pt |= 2;
  var r = OP();
  (Kn !== n || tr !== e) && ((to = null), _l(n, e));
  do
    try {
      uN();
      break;
    } catch (i) {
      NP(n, i);
    }
  while (1);
  if ((gA(), (Pt = t), (Sg.current = r), Bn !== null)) throw Error(Se(261));
  return (Kn = null), (tr = 0), Un;
}
function uN() {
  for (; Bn !== null; ) UP(Bn);
}
function cN() {
  for (; Bn !== null && !FF(); ) UP(Bn);
}
function UP(n) {
  var e = HP(n.alternate, n, ri);
  (n.memoizedProps = n.pendingProps),
    e === null ? kP(n) : (Bn = e),
    (RA.current = null);
}
function kP(n) {
  var e = n;
  do {
    var t = e.alternate;
    if (((n = e.return), e.flags & 32768)) {
      if (((t = rN(t, e)), t !== null)) {
        (t.flags &= 32767), (Bn = t);
        return;
      }
      if (n !== null)
        (n.flags |= 32768), (n.subtreeFlags = 0), (n.deletions = null);
      else {
        (Un = 6), (Bn = null);
        return;
      }
    } else if (((t = nN(t, e, ri)), t !== null)) {
      Bn = t;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      Bn = e;
      return;
    }
    Bn = e = n;
  } while (e !== null);
  Un === 0 && (Un = 5);
}
function tl(n, e, t) {
  var r = Ot,
    i = Oi.transition;
  try {
    (Oi.transition = null), (Ot = 1), fN(n, e, t, r);
  } finally {
    (Oi.transition = i), (Ot = r);
  }
  return null;
}
function fN(n, e, t, r) {
  do ic();
  while (Yo !== null);
  if (Pt & 6) throw Error(Se(327));
  t = n.finishedWork;
  var i = n.finishedLanes;
  if (t === null) return null;
  if (((n.finishedWork = null), (n.finishedLanes = 0), t === n.current))
    throw Error(Se(177));
  (n.callbackNode = null), (n.callbackPriority = 0);
  var s = t.lanes | t.childLanes;
  if (
    (jF(n, s),
    n === Kn && ((Bn = Kn = null), (tr = 0)),
    (!(t.subtreeFlags & 2064) && !(t.flags & 2064)) ||
      Ip ||
      ((Ip = !0),
      GP(sg, function () {
        return ic(), null;
      })),
    (s = (t.flags & 15990) !== 0),
    t.subtreeFlags & 15990 || s)
  ) {
    (s = Oi.transition), (Oi.transition = null);
    var o = Ot;
    Ot = 1;
    var a = Pt;
    (Pt |= 4),
      (RA.current = null),
      sN(n, t),
      IP(t, n),
      B3(lx),
      (ag = !!ax),
      (lx = ax = null),
      (n.current = t),
      oN(t),
      NF(),
      (Pt = a),
      (Ot = o),
      (Oi.transition = s);
  } else n.current = t;
  if (
    (Ip && ((Ip = !1), (Yo = n), (Mg = i)),
    (s = n.pendingLanes),
    s === 0 && (sa = null),
    kF(t.stateNode),
    Gr(n, An()),
    e !== null)
  )
    for (r = n.onRecoverableError, t = 0; t < e.length; t++)
      (i = e[t]), r(i.value, { componentStack: i.stack, digest: i.digest });
  if (Ag) throw ((Ag = !1), (n = bx), (bx = null), n);
  return (
    Mg & 1 && n.tag !== 0 && ic(),
    (s = n.pendingLanes),
    s & 1 ? (n === Rx ? th++ : ((th = 0), (Rx = n))) : (th = 0),
    Ta(),
    null
  );
}
function ic() {
  if (Yo !== null) {
    var n = vR(Mg),
      e = Oi.transition,
      t = Ot;
    try {
      if (((Oi.transition = null), (Ot = 16 > n ? 16 : n), Yo === null))
        var r = !1;
      else {
        if (((n = Yo), (Yo = null), (Mg = 0), Pt & 6)) throw Error(Se(331));
        var i = Pt;
        for (Pt |= 4, ke = n.current; ke !== null; ) {
          var s = ke,
            o = s.child;
          if (ke.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var u = a[l];
                for (ke = u; ke !== null; ) {
                  var h = ke;
                  switch (h.tag) {
                    case 0:
                    case 11:
                    case 15:
                      $f(8, h, s);
                  }
                  var d = h.child;
                  if (d !== null) (d.return = h), (ke = d);
                  else
                    for (; ke !== null; ) {
                      h = ke;
                      var p = h.sibling,
                        m = h.return;
                      if ((PP(h), h === u)) {
                        ke = null;
                        break;
                      }
                      if (p !== null) {
                        (p.return = m), (ke = p);
                        break;
                      }
                      ke = m;
                    }
                }
              }
              var _ = s.alternate;
              if (_ !== null) {
                var y = _.child;
                if (y !== null) {
                  _.child = null;
                  do {
                    var x = y.sibling;
                    (y.sibling = null), (y = x);
                  } while (y !== null);
                }
              }
              ke = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) (o.return = s), (ke = o);
          else
            e: for (; ke !== null; ) {
              if (((s = ke), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    $f(9, s, s.return);
                }
              var g = s.sibling;
              if (g !== null) {
                (g.return = s.return), (ke = g);
                break e;
              }
              ke = s.return;
            }
        }
        var S = n.current;
        for (ke = S; ke !== null; ) {
          o = ke;
          var A = o.child;
          if (o.subtreeFlags & 2064 && A !== null) (A.return = o), (ke = A);
          else
            e: for (o = S; ke !== null; ) {
              if (((a = ke), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      $g(9, a);
                  }
                } catch (C) {
                  pn(a, a.return, C);
                }
              if (a === o) {
                ke = null;
                break e;
              }
              var E = a.sibling;
              if (E !== null) {
                (E.return = a.return), (ke = E);
                break e;
              }
              ke = a.return;
            }
        }
        if (
          ((Pt = i), Ta(), Rs && typeof Rs.onPostCommitFiberRoot == "function")
        )
          try {
            Rs.onPostCommitFiberRoot(jg, n);
          } catch {}
        r = !0;
      }
      return r;
    } finally {
      (Ot = t), (Oi.transition = e);
    }
  }
  return !1;
}
function Xw(n, e, t) {
  (e = _c(t, e)),
    (e = yP(n, e, 1)),
    (n = ia(n, e, 1)),
    (e = Cr()),
    n !== null && (qh(n, 1, e), Gr(n, e));
}
function pn(n, e, t) {
  if (n.tag === 3) Xw(n, n, t);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        Xw(e, n, t);
        break;
      } else if (e.tag === 1) {
        var r = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof r.componentDidCatch == "function" &&
            (sa === null || !sa.has(r)))
        ) {
          (n = _c(t, n)),
            (n = xP(e, n, 1)),
            (e = ia(e, n, 1)),
            (n = Cr()),
            e !== null && (qh(e, 1, n), Gr(e, n));
          break;
        }
      }
      e = e.return;
    }
}
function hN(n, e, t) {
  var r = n.pingCache;
  r !== null && r.delete(e),
    (e = Cr()),
    (n.pingedLanes |= n.suspendedLanes & t),
    Kn === n &&
      (tr & t) === t &&
      (Un === 4 || (Un === 3 && (tr & 130023424) === tr && 500 > An() - BA)
        ? _l(n, 0)
        : (PA |= t)),
    Gr(n, e);
}
function zP(n, e) {
  e === 0 &&
    (n.mode & 1
      ? ((e = Mp), (Mp <<= 1), !(Mp & 130023424) && (Mp = 4194304))
      : (e = 1));
  var t = Cr();
  (n = go(n, e)), n !== null && (qh(n, e, t), Gr(n, t));
}
function dN(n) {
  var e = n.memoizedState,
    t = 0;
  e !== null && (t = e.retryLane), zP(n, t);
}
function pN(n, e) {
  var t = 0;
  switch (n.tag) {
    case 13:
      var r = n.stateNode,
        i = n.memoizedState;
      i !== null && (t = i.retryLane);
      break;
    case 19:
      r = n.stateNode;
      break;
    default:
      throw Error(Se(314));
  }
  r !== null && r.delete(e), zP(n, t);
}
var HP;
HP = function (n, e, t) {
  if (n !== null)
    if (n.memoizedProps !== e.pendingProps || zr.current) Ur = !0;
    else {
      if (!(n.lanes & t) && !(e.flags & 128)) return (Ur = !1), tN(n, e, t);
      Ur = !!(n.flags & 131072);
    }
  else (Ur = !1), $t && e.flags & 1048576 && WR(e, pg, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var r = e.type;
      Fm(n, e), (n = e.pendingProps);
      var i = dc(e, vr.current);
      rc(e, t), (i = EA(null, e, r, n, i, t));
      var s = wA();
      return (
        (e.flags |= 1),
        typeof i == "object" &&
        i !== null &&
        typeof i.render == "function" &&
        i.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            Hr(r) ? ((s = !0), hg(e)) : (s = !1),
            (e.memoizedState =
              i.state !== null && i.state !== void 0 ? i.state : null),
            yA(e),
            (i.updater = qg),
            (e.stateNode = i),
            (i._reactInternals = e),
            _x(e, r, n, t),
            (e = xx(null, e, r, !0, s, t)))
          : ((e.tag = 0), $t && s && hA(e), wr(null, e, i, t), (e = e.child)),
        e
      );
    case 16:
      r = e.elementType;
      e: {
        switch (
          (Fm(n, e),
          (n = e.pendingProps),
          (i = r._init),
          (r = i(r._payload)),
          (e.type = r),
          (i = e.tag = gN(r)),
          (n = qi(r, n)),
          i)
        ) {
          case 0:
            e = yx(null, e, r, n, t);
            break e;
          case 1:
            e = Nw(null, e, r, n, t);
            break e;
          case 11:
            e = Dw(null, e, r, n, t);
            break e;
          case 14:
            e = Fw(null, e, r, qi(r.type, n), t);
            break e;
        }
        throw Error(Se(306, r, ""));
      }
      return e;
    case 0:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : qi(r, i)),
        yx(n, e, r, i, t)
      );
    case 1:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : qi(r, i)),
        Nw(n, e, r, i, t)
      );
    case 3:
      e: {
        if ((EP(e), n === null)) throw Error(Se(387));
        (r = e.pendingProps),
          (s = e.memoizedState),
          (i = s.element),
          KR(n, e),
          _g(e, r, null, t);
        var o = e.memoizedState;
        if (((r = o.element), s.isDehydrated))
          if (
            ((s = {
              element: r,
              isDehydrated: !1,
              cache: o.cache,
              pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
              transitions: o.transitions,
            }),
            (e.updateQueue.baseState = s),
            (e.memoizedState = s),
            e.flags & 256)
          ) {
            (i = _c(Error(Se(423)), e)), (e = Ow(n, e, r, t, i));
            break e;
          } else if (r !== i) {
            (i = _c(Error(Se(424)), e)), (e = Ow(n, e, r, t, i));
            break e;
          } else
            for (
              oi = ra(e.stateNode.containerInfo.firstChild),
                li = e,
                $t = !0,
                es = null,
                t = ZR(e, null, r, t),
                e.child = t;
              t;

            )
              (t.flags = (t.flags & -3) | 4096), (t = t.sibling);
        else {
          if ((pc(), r === i)) {
            e = _o(n, e, t);
            break e;
          }
          wr(n, e, r, t);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        $R(e),
        n === null && px(e),
        (r = e.type),
        (i = e.pendingProps),
        (s = n !== null ? n.memoizedProps : null),
        (o = i.children),
        ux(r, i) ? (o = null) : s !== null && ux(r, s) && (e.flags |= 32),
        MP(n, e),
        wr(n, e, o, t),
        e.child
      );
    case 6:
      return n === null && px(e), null;
    case 13:
      return wP(n, e, t);
    case 4:
      return (
        xA(e, e.stateNode.containerInfo),
        (r = e.pendingProps),
        n === null ? (e.child = mc(e, null, r, t)) : wr(n, e, r, t),
        e.child
      );
    case 11:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : qi(r, i)),
        Dw(n, e, r, i, t)
      );
    case 7:
      return wr(n, e, e.pendingProps, t), e.child;
    case 8:
      return wr(n, e, e.pendingProps.children, t), e.child;
    case 12:
      return wr(n, e, e.pendingProps.children, t), e.child;
    case 10:
      e: {
        if (
          ((r = e.type._context),
          (i = e.pendingProps),
          (s = e.memoizedProps),
          (o = i.value),
          Xt(mg, r._currentValue),
          (r._currentValue = o),
          s !== null)
        )
          if (os(s.value, o)) {
            if (s.children === i.children && !zr.current) {
              e = _o(n, e, t);
              break e;
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null; ) {
              var a = s.dependencies;
              if (a !== null) {
                o = s.child;
                for (var l = a.firstContext; l !== null; ) {
                  if (l.context === r) {
                    if (s.tag === 1) {
                      (l = co(-1, t & -t)), (l.tag = 2);
                      var u = s.updateQueue;
                      if (u !== null) {
                        u = u.shared;
                        var h = u.pending;
                        h === null
                          ? (l.next = l)
                          : ((l.next = h.next), (h.next = l)),
                          (u.pending = l);
                      }
                    }
                    (s.lanes |= t),
                      (l = s.alternate),
                      l !== null && (l.lanes |= t),
                      mx(s.return, t, e),
                      (a.lanes |= t);
                    break;
                  }
                  l = l.next;
                }
              } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
              else if (s.tag === 18) {
                if (((o = s.return), o === null)) throw Error(Se(341));
                (o.lanes |= t),
                  (a = o.alternate),
                  a !== null && (a.lanes |= t),
                  mx(o, t, e),
                  (o = s.sibling);
              } else o = s.child;
              if (o !== null) o.return = s;
              else
                for (o = s; o !== null; ) {
                  if (o === e) {
                    o = null;
                    break;
                  }
                  if (((s = o.sibling), s !== null)) {
                    (s.return = o.return), (o = s);
                    break;
                  }
                  o = o.return;
                }
              s = o;
            }
        wr(n, e, i.children, t), (e = e.child);
      }
      return e;
    case 9:
      return (
        (i = e.type),
        (r = e.pendingProps.children),
        rc(e, t),
        (i = ki(i)),
        (r = r(i)),
        (e.flags |= 1),
        wr(n, e, r, t),
        e.child
      );
    case 14:
      return (
        (r = e.type),
        (i = qi(r, e.pendingProps)),
        (i = qi(r.type, i)),
        Fw(n, e, r, i, t)
      );
    case 15:
      return SP(n, e, e.type, e.pendingProps, t);
    case 17:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : qi(r, i)),
        Fm(n, e),
        (e.tag = 1),
        Hr(r) ? ((n = !0), hg(e)) : (n = !1),
        rc(e, t),
        QR(e, r, i),
        _x(e, r, i, t),
        xx(null, e, r, !0, n, t)
      );
    case 19:
      return CP(n, e, t);
    case 22:
      return AP(n, e, t);
  }
  throw Error(Se(156, e.tag));
};
function GP(n, e) {
  return pR(n, e);
}
function mN(n, e, t, r) {
  (this.tag = n),
    (this.key = t),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = r),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function Ii(n, e, t, r) {
  return new mN(n, e, t, r);
}
function FA(n) {
  return (n = n.prototype), !(!n || !n.isReactComponent);
}
function gN(n) {
  if (typeof n == "function") return FA(n) ? 1 : 0;
  if (n != null) {
    if (((n = n.$$typeof), n === eA)) return 11;
    if (n === tA) return 14;
  }
  return 2;
}
function aa(n, e) {
  var t = n.alternate;
  return (
    t === null
      ? ((t = Ii(n.tag, e, n.key, n.mode)),
        (t.elementType = n.elementType),
        (t.type = n.type),
        (t.stateNode = n.stateNode),
        (t.alternate = n),
        (n.alternate = t))
      : ((t.pendingProps = e),
        (t.type = n.type),
        (t.flags = 0),
        (t.subtreeFlags = 0),
        (t.deletions = null)),
    (t.flags = n.flags & 14680064),
    (t.childLanes = n.childLanes),
    (t.lanes = n.lanes),
    (t.child = n.child),
    (t.memoizedProps = n.memoizedProps),
    (t.memoizedState = n.memoizedState),
    (t.updateQueue = n.updateQueue),
    (e = n.dependencies),
    (t.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (t.sibling = n.sibling),
    (t.index = n.index),
    (t.ref = n.ref),
    t
  );
}
function Um(n, e, t, r, i, s) {
  var o = 2;
  if (((r = n), typeof n == "function")) FA(n) && (o = 1);
  else if (typeof n == "string") o = 5;
  else
    e: switch (n) {
      case Nu:
        return vl(t.children, i, s, e);
      case $S:
        (o = 8), (i |= 8);
        break;
      case Hy:
        return (
          (n = Ii(12, t, e, i | 2)), (n.elementType = Hy), (n.lanes = s), n
        );
      case Gy:
        return (n = Ii(13, t, e, i)), (n.elementType = Gy), (n.lanes = s), n;
      case Vy:
        return (n = Ii(19, t, e, i)), (n.elementType = Vy), (n.lanes = s), n;
      case qb:
        return t0(t, i, s, e);
      default:
        if (typeof n == "object" && n !== null)
          switch (n.$$typeof) {
            case Yb:
              o = 10;
              break e;
            case Qb:
              o = 9;
              break e;
            case eA:
              o = 11;
              break e;
            case tA:
              o = 14;
              break e;
            case Go:
              (o = 16), (r = null);
              break e;
          }
        throw Error(Se(130, n == null ? n : typeof n, ""));
    }
  return (
    (e = Ii(o, t, e, i)), (e.elementType = n), (e.type = r), (e.lanes = s), e
  );
}
function vl(n, e, t, r) {
  return (n = Ii(7, n, r, e)), (n.lanes = t), n;
}
function t0(n, e, t, r) {
  return (
    (n = Ii(22, n, r, e)),
    (n.elementType = qb),
    (n.lanes = t),
    (n.stateNode = { isHidden: !1 }),
    n
  );
}
function Cv(n, e, t) {
  return (n = Ii(6, n, null, e)), (n.lanes = t), n;
}
function Tv(n, e, t) {
  return (
    (e = Ii(4, n.children !== null ? n.children : [], n.key, e)),
    (e.lanes = t),
    (e.stateNode = {
      containerInfo: n.containerInfo,
      pendingChildren: null,
      implementation: n.implementation,
    }),
    e
  );
}
function _N(n, e, t, r, i) {
  (this.tag = e),
    (this.containerInfo = n),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = av(0)),
    (this.expirationTimes = av(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = av(0)),
    (this.identifierPrefix = r),
    (this.onRecoverableError = i),
    (this.mutableSourceEagerHydrationData = null);
}
function NA(n, e, t, r, i, s, o, a, l) {
  return (
    (n = new _N(n, e, t, a, l)),
    e === 1 ? ((e = 1), s === !0 && (e |= 8)) : (e = 0),
    (s = Ii(3, null, null, e)),
    (n.current = s),
    (s.stateNode = n),
    (s.memoizedState = {
      element: r,
      isDehydrated: t,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    yA(s),
    n
  );
}
function vN(n, e, t) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: Fu,
    key: r == null ? null : "" + r,
    children: n,
    containerInfo: e,
    implementation: t,
  };
}
function VP(n) {
  if (!n) return _a;
  n = n._reactInternals;
  e: {
    if (Ul(n) !== n || n.tag !== 1) throw Error(Se(170));
    var e = n;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (Hr(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(Se(171));
  }
  if (n.tag === 1) {
    var t = n.type;
    if (Hr(t)) return GR(n, t, e);
  }
  return e;
}
function WP(n, e, t, r, i, s, o, a, l) {
  return (
    (n = NA(t, r, !0, n, i, s, o, a, l)),
    (n.context = VP(null)),
    (t = n.current),
    (r = Cr()),
    (i = oa(t)),
    (s = co(r, i)),
    (s.callback = e ?? null),
    ia(t, s, i),
    (n.current.lanes = i),
    qh(n, i, r),
    Gr(n, r),
    n
  );
}
function n0(n, e, t, r) {
  var i = e.current,
    s = Cr(),
    o = oa(i);
  return (
    (t = VP(t)),
    e.context === null ? (e.context = t) : (e.pendingContext = t),
    (e = co(s, o)),
    (e.payload = { element: n }),
    (r = r === void 0 ? null : r),
    r !== null && (e.callback = r),
    (n = ia(i, e, o)),
    n !== null && (rs(n, i, o, s), Lm(n, i, o)),
    o
  );
}
function wg(n) {
  if (((n = n.current), !n.child)) return null;
  switch (n.child.tag) {
    case 5:
      return n.child.stateNode;
    default:
      return n.child.stateNode;
  }
}
function Jw(n, e) {
  if (((n = n.memoizedState), n !== null && n.dehydrated !== null)) {
    var t = n.retryLane;
    n.retryLane = t !== 0 && t < e ? t : e;
  }
}
function OA(n, e) {
  Jw(n, e), (n = n.alternate) && Jw(n, e);
}
function yN() {
  return null;
}
var jP =
  typeof reportError == "function"
    ? reportError
    : function (n) {
        console.error(n);
      };
function UA(n) {
  this._internalRoot = n;
}
r0.prototype.render = UA.prototype.render = function (n) {
  var e = this._internalRoot;
  if (e === null) throw Error(Se(409));
  n0(n, e, null, null);
};
r0.prototype.unmount = UA.prototype.unmount = function () {
  var n = this._internalRoot;
  if (n !== null) {
    this._internalRoot = null;
    var e = n.containerInfo;
    Bl(function () {
      n0(null, n, null, null);
    }),
      (e[mo] = null);
  }
};
function r0(n) {
  this._internalRoot = n;
}
r0.prototype.unstable_scheduleHydration = function (n) {
  if (n) {
    var e = SR();
    n = { blockedOn: null, target: n, priority: e };
    for (var t = 0; t < Xo.length && e !== 0 && e < Xo[t].priority; t++);
    Xo.splice(t, 0, n), t === 0 && MR(n);
  }
};
function kA(n) {
  return !(!n || (n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11));
}
function i0(n) {
  return !(
    !n ||
    (n.nodeType !== 1 &&
      n.nodeType !== 9 &&
      n.nodeType !== 11 &&
      (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
  );
}
function Kw() {}
function xN(n, e, t, r, i) {
  if (i) {
    if (typeof r == "function") {
      var s = r;
      r = function () {
        var u = wg(o);
        s.call(u);
      };
    }
    var o = WP(e, r, n, 0, null, !1, !1, "", Kw);
    return (
      (n._reactRootContainer = o),
      (n[mo] = o.current),
      vh(n.nodeType === 8 ? n.parentNode : n),
      Bl(),
      o
    );
  }
  for (; (i = n.lastChild); ) n.removeChild(i);
  if (typeof r == "function") {
    var a = r;
    r = function () {
      var u = wg(l);
      a.call(u);
    };
  }
  var l = NA(n, 0, !1, null, null, !1, !1, "", Kw);
  return (
    (n._reactRootContainer = l),
    (n[mo] = l.current),
    vh(n.nodeType === 8 ? n.parentNode : n),
    Bl(function () {
      n0(e, l, t, r);
    }),
    l
  );
}
function s0(n, e, t, r, i) {
  var s = t._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof i == "function") {
      var a = i;
      i = function () {
        var l = wg(o);
        a.call(l);
      };
    }
    n0(e, o, n, i);
  } else o = xN(t, e, n, i, r);
  return wg(o);
}
yR = function (n) {
  switch (n.tag) {
    case 3:
      var e = n.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var t = Hf(e.pendingLanes);
        t !== 0 &&
          (iA(e, t | 1), Gr(e, An()), !(Pt & 6) && ((vc = An() + 500), Ta()));
      }
      break;
    case 13:
      Bl(function () {
        var r = go(n, 1);
        if (r !== null) {
          var i = Cr();
          rs(r, n, 1, i);
        }
      }),
        OA(n, 1);
  }
};
sA = function (n) {
  if (n.tag === 13) {
    var e = go(n, 134217728);
    if (e !== null) {
      var t = Cr();
      rs(e, n, 134217728, t);
    }
    OA(n, 134217728);
  }
};
xR = function (n) {
  if (n.tag === 13) {
    var e = oa(n),
      t = go(n, e);
    if (t !== null) {
      var r = Cr();
      rs(t, n, e, r);
    }
    OA(n, e);
  }
};
SR = function () {
  return Ot;
};
AR = function (n, e) {
  var t = Ot;
  try {
    return (Ot = n), e();
  } finally {
    Ot = t;
  }
};
$y = function (n, e, t) {
  switch (e) {
    case "input":
      if ((Xy(n, t), (e = t.name), t.type === "radio" && e != null)) {
        for (t = n; t.parentNode; ) t = t.parentNode;
        for (
          t = t.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < t.length;
          e++
        ) {
          var r = t[e];
          if (r !== n && r.form === n.form) {
            var i = Yg(r);
            if (!i) throw Error(Se(90));
            $b(r), Xy(r, i);
          }
        }
      }
      break;
    case "textarea":
      tR(n, t);
      break;
    case "select":
      (e = t.value), e != null && $u(n, !!t.multiple, e, !1);
  }
};
lR = LA;
uR = Bl;
var SN = { usingClientEntryPoint: !1, Events: [$h, zu, Yg, oR, aR, LA] },
  Sf = {
    findFiberByHostInstance: ll,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom",
  },
  AN = {
    bundleType: Sf.bundleType,
    version: Sf.version,
    rendererPackageName: Sf.rendererPackageName,
    rendererConfig: Sf.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: So.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (n) {
      return (n = hR(n)), n === null ? null : n.stateNode;
    },
    findFiberByHostInstance: Sf.findFiberByHostInstance || yN,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var Dp = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!Dp.isDisabled && Dp.supportsFiber)
    try {
      (jg = Dp.inject(AN)), (Rs = Dp);
    } catch {}
}
pi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = SN;
pi.createPortal = function (n, e) {
  var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!kA(e)) throw Error(Se(200));
  return vN(n, e, null, t);
};
pi.createRoot = function (n, e) {
  if (!kA(n)) throw Error(Se(299));
  var t = !1,
    r = "",
    i = jP;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (t = !0),
      e.identifierPrefix !== void 0 && (r = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (i = e.onRecoverableError)),
    (e = NA(n, 1, !1, null, null, t, !1, r, i)),
    (n[mo] = e.current),
    vh(n.nodeType === 8 ? n.parentNode : n),
    new UA(e)
  );
};
pi.findDOMNode = function (n) {
  if (n == null) return null;
  if (n.nodeType === 1) return n;
  var e = n._reactInternals;
  if (e === void 0)
    throw typeof n.render == "function"
      ? Error(Se(188))
      : ((n = Object.keys(n).join(",")), Error(Se(268, n)));
  return (n = hR(e)), (n = n === null ? null : n.stateNode), n;
};
pi.flushSync = function (n) {
  return Bl(n);
};
pi.hydrate = function (n, e, t) {
  if (!i0(e)) throw Error(Se(200));
  return s0(null, n, e, !0, t);
};
pi.hydrateRoot = function (n, e, t) {
  if (!kA(n)) throw Error(Se(405));
  var r = (t != null && t.hydratedSources) || null,
    i = !1,
    s = "",
    o = jP;
  if (
    (t != null &&
      (t.unstable_strictMode === !0 && (i = !0),
      t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    (e = WP(e, null, n, 1, t ?? null, i, !1, s, o)),
    (n[mo] = e.current),
    vh(n),
    r)
  )
    for (n = 0; n < r.length; n++)
      (t = r[n]),
        (i = t._getVersion),
        (i = i(t._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [t, i])
          : e.mutableSourceEagerHydrationData.push(t, i);
  return new r0(e);
};
pi.render = function (n, e, t) {
  if (!i0(e)) throw Error(Se(200));
  return s0(null, n, e, !1, t);
};
pi.unmountComponentAtNode = function (n) {
  if (!i0(n)) throw Error(Se(40));
  return n._reactRootContainer
    ? (Bl(function () {
        s0(null, null, n, !1, function () {
          (n._reactRootContainer = null), (n[mo] = null);
        });
      }),
      !0)
    : !1;
};
pi.unstable_batchedUpdates = LA;
pi.unstable_renderSubtreeIntoContainer = function (n, e, t, r) {
  if (!i0(t)) throw Error(Se(200));
  if (n == null || n._reactInternals === void 0) throw Error(Se(38));
  return s0(n, e, t, !1, r);
};
pi.version = "18.2.0-next-9e3b772b8-20220608";
function XP() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(XP);
    } catch (n) {
      console.error(n);
    }
}
XP(), (Wb.exports = pi);
var MN = Wb.exports,
  JP,
  Yw = MN;
(JP = ky.createRoot = Yw.createRoot), (ky.hydrateRoot = Yw.hydrateRoot);
const EN = "_container_1mkxh_1",
  wN = "_title_1mkxh_12",
  Qw = { container: EN, title: wN };
/**
 * @remix-run/router v1.6.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Th() {
  return (
    (Th = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)
              Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }),
    Th.apply(this, arguments)
  );
}
var Qo;
(function (n) {
  (n.Pop = "POP"), (n.Push = "PUSH"), (n.Replace = "REPLACE");
})(Qo || (Qo = {}));
const qw = "popstate";
function CN(n) {
  n === void 0 && (n = {});
  function e(i, s) {
    let {
      pathname: o = "/",
      search: a = "",
      hash: l = "",
    } = kl(i.location.hash.substr(1));
    return Lx(
      "",
      { pathname: o, search: a, hash: l },
      (s.state && s.state.usr) || null,
      (s.state && s.state.key) || "default"
    );
  }
  function t(i, s) {
    let o = i.document.querySelector("base"),
      a = "";
    if (o && o.getAttribute("href")) {
      let l = i.location.href,
        u = l.indexOf("#");
      a = u === -1 ? l : l.slice(0, u);
    }
    return a + "#" + (typeof s == "string" ? s : Cg(s));
  }
  function r(i, s) {
    o0(
      i.pathname.charAt(0) === "/",
      "relative pathnames are not supported in hash history.push(" +
        JSON.stringify(s) +
        ")"
    );
  }
  return bN(e, t, r, n);
}
function Ln(n, e) {
  if (n === !1 || n === null || typeof n > "u") throw new Error(e);
}
function o0(n, e) {
  if (!n) {
    typeof console < "u" && console.warn(e);
    try {
      throw new Error(e);
    } catch {}
  }
}
function TN() {
  return Math.random().toString(36).substr(2, 8);
}
function Zw(n, e) {
  return { usr: n.state, key: n.key, idx: e };
}
function Lx(n, e, t, r) {
  return (
    t === void 0 && (t = null),
    Th(
      { pathname: typeof n == "string" ? n : n.pathname, search: "", hash: "" },
      typeof e == "string" ? kl(e) : e,
      { state: t, key: (e && e.key) || r || TN() }
    )
  );
}
function Cg(n) {
  let { pathname: e = "/", search: t = "", hash: r = "" } = n;
  return (
    t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t),
    r && r !== "#" && (e += r.charAt(0) === "#" ? r : "#" + r),
    e
  );
}
function kl(n) {
  let e = {};
  if (n) {
    let t = n.indexOf("#");
    t >= 0 && ((e.hash = n.substr(t)), (n = n.substr(0, t)));
    let r = n.indexOf("?");
    r >= 0 && ((e.search = n.substr(r)), (n = n.substr(0, r))),
      n && (e.pathname = n);
  }
  return e;
}
function bN(n, e, t, r) {
  r === void 0 && (r = {});
  let { window: i = document.defaultView, v5Compat: s = !1 } = r,
    o = i.history,
    a = Qo.Pop,
    l = null,
    u = h();
  u == null && ((u = 0), o.replaceState(Th({}, o.state, { idx: u }), ""));
  function h() {
    return (o.state || { idx: null }).idx;
  }
  function d() {
    a = Qo.Pop;
    let x = h(),
      g = x == null ? null : x - u;
    (u = x), l && l({ action: a, location: y.location, delta: g });
  }
  function p(x, g) {
    a = Qo.Push;
    let S = Lx(y.location, x, g);
    t && t(S, x), (u = h() + 1);
    let A = Zw(S, u),
      E = y.createHref(S);
    try {
      o.pushState(A, "", E);
    } catch {
      i.location.assign(E);
    }
    s && l && l({ action: a, location: y.location, delta: 1 });
  }
  function m(x, g) {
    a = Qo.Replace;
    let S = Lx(y.location, x, g);
    t && t(S, x), (u = h());
    let A = Zw(S, u),
      E = y.createHref(S);
    o.replaceState(A, "", E),
      s && l && l({ action: a, location: y.location, delta: 0 });
  }
  function _(x) {
    let g = i.location.origin !== "null" ? i.location.origin : i.location.href,
      S = typeof x == "string" ? x : Cg(x);
    return (
      Ln(
        g,
        "No window.location.(origin|href) available to create URL for href: " +
          S
      ),
      new URL(S, g)
    );
  }
  let y = {
    get action() {
      return a;
    },
    get location() {
      return n(i, o);
    },
    listen(x) {
      if (l) throw new Error("A history only accepts one active listener");
      return (
        i.addEventListener(qw, d),
        (l = x),
        () => {
          i.removeEventListener(qw, d), (l = null);
        }
      );
    },
    createHref(x) {
      return e(i, x);
    },
    createURL: _,
    encodeLocation(x) {
      let g = _(x);
      return { pathname: g.pathname, search: g.search, hash: g.hash };
    },
    push: p,
    replace: m,
    go(x) {
      return o.go(x);
    },
  };
  return y;
}
var $w;
(function (n) {
  (n.data = "data"),
    (n.deferred = "deferred"),
    (n.redirect = "redirect"),
    (n.error = "error");
})($w || ($w = {}));
function RN(n, e, t) {
  t === void 0 && (t = "/");
  let r = typeof e == "string" ? kl(e) : e,
    i = zA(r.pathname || "/", t);
  if (i == null) return null;
  let s = KP(n);
  PN(s);
  let o = null;
  for (let a = 0; o == null && a < s.length; ++a) o = kN(s[a], GN(i));
  return o;
}
function KP(n, e, t, r) {
  e === void 0 && (e = []), t === void 0 && (t = []), r === void 0 && (r = "");
  let i = (s, o, a) => {
    let l = {
      relativePath: a === void 0 ? s.path || "" : a,
      caseSensitive: s.caseSensitive === !0,
      childrenIndex: o,
      route: s,
    };
    l.relativePath.startsWith("/") &&
      (Ln(
        l.relativePath.startsWith(r),
        'Absolute route path "' +
          l.relativePath +
          '" nested under path ' +
          ('"' + r + '" is not valid. An absolute child route path ') +
          "must start with the combined path of all its parent routes."
      ),
      (l.relativePath = l.relativePath.slice(r.length)));
    let u = la([r, l.relativePath]),
      h = t.concat(l);
    s.children &&
      s.children.length > 0 &&
      (Ln(
        s.index !== !0,
        "Index routes must not have child routes. Please remove " +
          ('all child routes from route path "' + u + '".')
      ),
      KP(s.children, e, h, u)),
      !(s.path == null && !s.index) &&
        e.push({ path: u, score: ON(u, s.index), routesMeta: h });
  };
  return (
    n.forEach((s, o) => {
      var a;
      if (s.path === "" || !((a = s.path) != null && a.includes("?"))) i(s, o);
      else for (let l of YP(s.path)) i(s, o, l);
    }),
    e
  );
}
function YP(n) {
  let e = n.split("/");
  if (e.length === 0) return [];
  let [t, ...r] = e,
    i = t.endsWith("?"),
    s = t.replace(/\?$/, "");
  if (r.length === 0) return i ? [s, ""] : [s];
  let o = YP(r.join("/")),
    a = [];
  return (
    a.push(...o.map((l) => (l === "" ? s : [s, l].join("/")))),
    i && a.push(...o),
    a.map((l) => (n.startsWith("/") && l === "" ? "/" : l))
  );
}
function PN(n) {
  n.sort((e, t) =>
    e.score !== t.score
      ? t.score - e.score
      : UN(
          e.routesMeta.map((r) => r.childrenIndex),
          t.routesMeta.map((r) => r.childrenIndex)
        )
  );
}
const BN = /^:\w+$/,
  LN = 3,
  IN = 2,
  DN = 1,
  FN = 10,
  NN = -2,
  eC = (n) => n === "*";
function ON(n, e) {
  let t = n.split("/"),
    r = t.length;
  return (
    t.some(eC) && (r += NN),
    e && (r += IN),
    t
      .filter((i) => !eC(i))
      .reduce((i, s) => i + (BN.test(s) ? LN : s === "" ? DN : FN), r)
  );
}
function UN(n, e) {
  return n.length === e.length && n.slice(0, -1).every((r, i) => r === e[i])
    ? n[n.length - 1] - e[e.length - 1]
    : 0;
}
function kN(n, e) {
  let { routesMeta: t } = n,
    r = {},
    i = "/",
    s = [];
  for (let o = 0; o < t.length; ++o) {
    let a = t[o],
      l = o === t.length - 1,
      u = i === "/" ? e : e.slice(i.length) || "/",
      h = zN(
        { path: a.relativePath, caseSensitive: a.caseSensitive, end: l },
        u
      );
    if (!h) return null;
    Object.assign(r, h.params);
    let d = a.route;
    s.push({
      params: r,
      pathname: la([i, h.pathname]),
      pathnameBase: XN(la([i, h.pathnameBase])),
      route: d,
    }),
      h.pathnameBase !== "/" && (i = la([i, h.pathnameBase]));
  }
  return s;
}
function zN(n, e) {
  typeof n == "string" && (n = { path: n, caseSensitive: !1, end: !0 });
  let [t, r] = HN(n.path, n.caseSensitive, n.end),
    i = e.match(t);
  if (!i) return null;
  let s = i[0],
    o = s.replace(/(.)\/+$/, "$1"),
    a = i.slice(1);
  return {
    params: r.reduce((u, h, d) => {
      if (h === "*") {
        let p = a[d] || "";
        o = s.slice(0, s.length - p.length).replace(/(.)\/+$/, "$1");
      }
      return (u[h] = VN(a[d] || "", h)), u;
    }, {}),
    pathname: s,
    pathnameBase: o,
    pattern: n,
  };
}
function HN(n, e, t) {
  e === void 0 && (e = !1),
    t === void 0 && (t = !0),
    o0(
      n === "*" || !n.endsWith("*") || n.endsWith("/*"),
      'Route path "' +
        n +
        '" will be treated as if it were ' +
        ('"' + n.replace(/\*$/, "/*") + '" because the `*` character must ') +
        "always follow a `/` in the pattern. To get rid of this warning, " +
        ('please change the route path to "' + n.replace(/\*$/, "/*") + '".')
    );
  let r = [],
    i =
      "^" +
      n
        .replace(/\/*\*?$/, "")
        .replace(/^\/*/, "/")
        .replace(/[\\.*+^$?{}|()[\]]/g, "\\$&")
        .replace(/\/:(\w+)/g, (o, a) => (r.push(a), "/([^\\/]+)"));
  return (
    n.endsWith("*")
      ? (r.push("*"),
        (i += n === "*" || n === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$"))
      : t
      ? (i += "\\/*$")
      : n !== "" && n !== "/" && (i += "(?:(?=\\/|$))"),
    [new RegExp(i, e ? void 0 : "i"), r]
  );
}
function GN(n) {
  try {
    return decodeURI(n);
  } catch (e) {
    return (
      o0(
        !1,
        'The URL path "' +
          n +
          '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' +
          ("encoding (" + e + ").")
      ),
      n
    );
  }
}
function VN(n, e) {
  try {
    return decodeURIComponent(n);
  } catch (t) {
    return (
      o0(
        !1,
        'The value for the URL param "' +
          e +
          '" will not be decoded because' +
          (' the string "' +
            n +
            '" is a malformed URL segment. This is probably') +
          (" due to a bad percent encoding (" + t + ").")
      ),
      n
    );
  }
}
function zA(n, e) {
  if (e === "/") return n;
  if (!n.toLowerCase().startsWith(e.toLowerCase())) return null;
  let t = e.endsWith("/") ? e.length - 1 : e.length,
    r = n.charAt(t);
  return r && r !== "/" ? null : n.slice(t) || "/";
}
function WN(n, e) {
  e === void 0 && (e = "/");
  let {
    pathname: t,
    search: r = "",
    hash: i = "",
  } = typeof n == "string" ? kl(n) : n;
  return {
    pathname: t ? (t.startsWith("/") ? t : jN(t, e)) : e,
    search: JN(r),
    hash: KN(i),
  };
}
function jN(n, e) {
  let t = e.replace(/\/+$/, "").split("/");
  return (
    n.split("/").forEach((i) => {
      i === ".." ? t.length > 1 && t.pop() : i !== "." && t.push(i);
    }),
    t.length > 1 ? t.join("/") : "/"
  );
}
function bv(n, e, t, r) {
  return (
    "Cannot include a '" +
    n +
    "' character in a manually specified " +
    ("`to." +
      e +
      "` field [" +
      JSON.stringify(r) +
      "].  Please separate it out to the ") +
    ("`to." + t + "` field. Alternatively you may provide the full path as ") +
    'a string in <Link to="..."> and the router will parse it for you.'
  );
}
function QP(n) {
  return n.filter(
    (e, t) => t === 0 || (e.route.path && e.route.path.length > 0)
  );
}
function qP(n, e, t, r) {
  r === void 0 && (r = !1);
  let i;
  typeof n == "string"
    ? (i = kl(n))
    : ((i = Th({}, n)),
      Ln(
        !i.pathname || !i.pathname.includes("?"),
        bv("?", "pathname", "search", i)
      ),
      Ln(
        !i.pathname || !i.pathname.includes("#"),
        bv("#", "pathname", "hash", i)
      ),
      Ln(!i.search || !i.search.includes("#"), bv("#", "search", "hash", i)));
  let s = n === "" || i.pathname === "",
    o = s ? "/" : i.pathname,
    a;
  if (r || o == null) a = t;
  else {
    let d = e.length - 1;
    if (o.startsWith("..")) {
      let p = o.split("/");
      for (; p[0] === ".."; ) p.shift(), (d -= 1);
      i.pathname = p.join("/");
    }
    a = d >= 0 ? e[d] : "/";
  }
  let l = WN(i, a),
    u = o && o !== "/" && o.endsWith("/"),
    h = (s || o === ".") && t.endsWith("/");
  return !l.pathname.endsWith("/") && (u || h) && (l.pathname += "/"), l;
}
const la = (n) => n.join("/").replace(/\/\/+/g, "/"),
  XN = (n) => n.replace(/\/+$/, "").replace(/^\/*/, "/"),
  JN = (n) => (!n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n),
  KN = (n) => (!n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n);
function YN(n) {
  return (
    n != null &&
    typeof n.status == "number" &&
    typeof n.statusText == "string" &&
    typeof n.internal == "boolean" &&
    "data" in n
  );
}
const ZP = ["post", "put", "patch", "delete"];
new Set(ZP);
const QN = ["get", ...ZP];
new Set(QN);
/**
 * React Router v6.11.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Tg() {
  return (
    (Tg = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)
              Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }),
    Tg.apply(this, arguments)
  );
}
const HA = te.createContext(null),
  qN = te.createContext(null),
  zc = te.createContext(null),
  a0 = te.createContext(null),
  Ao = te.createContext({ outlet: null, matches: [], isDataRoute: !1 }),
  $P = te.createContext(null);
function ZN(n, e) {
  let { relative: t } = e === void 0 ? {} : e;
  td() || Ln(!1);
  let { basename: r, navigator: i } = te.useContext(zc),
    { hash: s, pathname: o, search: a } = tB(n, { relative: t }),
    l = o;
  return (
    r !== "/" && (l = o === "/" ? r : la([r, o])),
    i.createHref({ pathname: l, search: a, hash: s })
  );
}
function td() {
  return te.useContext(a0) != null;
}
function l0() {
  return td() || Ln(!1), te.useContext(a0).location;
}
function eB(n) {
  te.useContext(zc).static || te.useLayoutEffect(n);
}
function nd() {
  let { isDataRoute: n } = te.useContext(Ao);
  return n ? pO() : $N();
}
function $N() {
  td() || Ln(!1);
  let n = te.useContext(HA),
    { basename: e, navigator: t } = te.useContext(zc),
    { matches: r } = te.useContext(Ao),
    { pathname: i } = l0(),
    s = JSON.stringify(QP(r).map((l) => l.pathnameBase)),
    o = te.useRef(!1);
  return (
    eB(() => {
      o.current = !0;
    }),
    te.useCallback(
      function (l, u) {
        if ((u === void 0 && (u = {}), !o.current)) return;
        if (typeof l == "number") {
          t.go(l);
          return;
        }
        let h = qP(l, JSON.parse(s), i, u.relative === "path");
        n == null &&
          e !== "/" &&
          (h.pathname = h.pathname === "/" ? e : la([e, h.pathname])),
          (u.replace ? t.replace : t.push)(h, u.state, u);
      },
      [e, t, s, i, n]
    )
  );
}
const eO = te.createContext(null);
function tO(n) {
  let e = te.useContext(Ao).outlet;
  return e && te.createElement(eO.Provider, { value: n }, e);
}
function nO() {
  let { matches: n } = te.useContext(Ao),
    e = n[n.length - 1];
  return e ? e.params : {};
}
function tB(n, e) {
  let { relative: t } = e === void 0 ? {} : e,
    { matches: r } = te.useContext(Ao),
    { pathname: i } = l0(),
    s = JSON.stringify(QP(r).map((o) => o.pathnameBase));
  return te.useMemo(() => qP(n, JSON.parse(s), i, t === "path"), [n, s, i, t]);
}
function rO(n, e) {
  return iO(n, e);
}
function iO(n, e, t) {
  td() || Ln(!1);
  let { navigator: r } = te.useContext(zc),
    { matches: i } = te.useContext(Ao),
    s = i[i.length - 1],
    o = s ? s.params : {};
  s && s.pathname;
  let a = s ? s.pathnameBase : "/";
  s && s.route;
  let l = l0(),
    u;
  if (e) {
    var h;
    let y = typeof e == "string" ? kl(e) : e;
    a === "/" || ((h = y.pathname) != null && h.startsWith(a)) || Ln(!1),
      (u = y);
  } else u = l;
  let d = u.pathname || "/",
    p = a === "/" ? d : d.slice(a.length) || "/",
    m = RN(n, { pathname: p }),
    _ = uO(
      m &&
        m.map((y) =>
          Object.assign({}, y, {
            params: Object.assign({}, o, y.params),
            pathname: la([
              a,
              r.encodeLocation
                ? r.encodeLocation(y.pathname).pathname
                : y.pathname,
            ]),
            pathnameBase:
              y.pathnameBase === "/"
                ? a
                : la([
                    a,
                    r.encodeLocation
                      ? r.encodeLocation(y.pathnameBase).pathname
                      : y.pathnameBase,
                  ]),
          })
        ),
      i,
      t
    );
  return e && _
    ? te.createElement(
        a0.Provider,
        {
          value: {
            location: Tg(
              {
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default",
              },
              u
            ),
            navigationType: Qo.Pop,
          },
        },
        _
      )
    : _;
}
function sO() {
  let n = dO(),
    e = YN(n)
      ? n.status + " " + n.statusText
      : n instanceof Error
      ? n.message
      : JSON.stringify(n),
    t = n instanceof Error ? n.stack : null,
    i = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" },
    s = null;
  return te.createElement(
    te.Fragment,
    null,
    te.createElement("h2", null, "Unexpected Application Error!"),
    te.createElement("h3", { style: { fontStyle: "italic" } }, e),
    t ? te.createElement("pre", { style: i }, t) : null,
    s
  );
}
const oO = te.createElement(sO, null);
class aO extends te.Component {
  constructor(e) {
    super(e),
      (this.state = {
        location: e.location,
        revalidation: e.revalidation,
        error: e.error,
      });
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location ||
      (t.revalidation !== "idle" && e.revalidation === "idle")
      ? { error: e.error, location: e.location, revalidation: e.revalidation }
      : {
          error: e.error || t.error,
          location: t.location,
          revalidation: e.revalidation || t.revalidation,
        };
  }
  componentDidCatch(e, t) {
    console.error(
      "React Router caught the following error during render",
      e,
      t
    );
  }
  render() {
    return this.state.error
      ? te.createElement(
          Ao.Provider,
          { value: this.props.routeContext },
          te.createElement($P.Provider, {
            value: this.state.error,
            children: this.props.component,
          })
        )
      : this.props.children;
  }
}
function lO(n) {
  let { routeContext: e, match: t, children: r } = n,
    i = te.useContext(HA);
  return (
    i &&
      i.static &&
      i.staticContext &&
      (t.route.errorElement || t.route.ErrorBoundary) &&
      (i.staticContext._deepestRenderedBoundaryId = t.route.id),
    te.createElement(Ao.Provider, { value: e }, r)
  );
}
function uO(n, e, t) {
  var r;
  if ((e === void 0 && (e = []), t === void 0 && (t = null), n == null)) {
    var i;
    if ((i = t) != null && i.errors) n = t.matches;
    else return null;
  }
  let s = n,
    o = (r = t) == null ? void 0 : r.errors;
  if (o != null) {
    let a = s.findIndex(
      (l) => l.route.id && (o == null ? void 0 : o[l.route.id])
    );
    a >= 0 || Ln(!1), (s = s.slice(0, Math.min(s.length, a + 1)));
  }
  return s.reduceRight((a, l, u) => {
    let h = l.route.id ? (o == null ? void 0 : o[l.route.id]) : null,
      d = null;
    t && (d = l.route.errorElement || oO);
    let p = e.concat(s.slice(0, u + 1)),
      m = () => {
        let _;
        return (
          h
            ? (_ = d)
            : l.route.Component
            ? (_ = te.createElement(l.route.Component, null))
            : l.route.element
            ? (_ = l.route.element)
            : (_ = a),
          te.createElement(lO, {
            match: l,
            routeContext: { outlet: a, matches: p, isDataRoute: t != null },
            children: _,
          })
        );
      };
    return t && (l.route.ErrorBoundary || l.route.errorElement || u === 0)
      ? te.createElement(aO, {
          location: t.location,
          revalidation: t.revalidation,
          component: d,
          error: h,
          children: m(),
          routeContext: { outlet: null, matches: p, isDataRoute: !0 },
        })
      : m();
  }, null);
}
var Ix;
(function (n) {
  (n.UseBlocker = "useBlocker"),
    (n.UseRevalidator = "useRevalidator"),
    (n.UseNavigateStable = "useNavigate");
})(Ix || (Ix = {}));
var bh;
(function (n) {
  (n.UseBlocker = "useBlocker"),
    (n.UseLoaderData = "useLoaderData"),
    (n.UseActionData = "useActionData"),
    (n.UseRouteError = "useRouteError"),
    (n.UseNavigation = "useNavigation"),
    (n.UseRouteLoaderData = "useRouteLoaderData"),
    (n.UseMatches = "useMatches"),
    (n.UseRevalidator = "useRevalidator"),
    (n.UseNavigateStable = "useNavigate"),
    (n.UseRouteId = "useRouteId");
})(bh || (bh = {}));
function cO(n) {
  let e = te.useContext(HA);
  return e || Ln(!1), e;
}
function fO(n) {
  let e = te.useContext(qN);
  return e || Ln(!1), e;
}
function hO(n) {
  let e = te.useContext(Ao);
  return e || Ln(!1), e;
}
function nB(n) {
  let e = hO(),
    t = e.matches[e.matches.length - 1];
  return t.route.id || Ln(!1), t.route.id;
}
function dO() {
  var n;
  let e = te.useContext($P),
    t = fO(bh.UseRouteError),
    r = nB(bh.UseRouteError);
  return e || ((n = t.errors) == null ? void 0 : n[r]);
}
function pO() {
  let { router: n } = cO(Ix.UseNavigateStable),
    e = nB(bh.UseNavigateStable),
    t = te.useRef(!1);
  return (
    eB(() => {
      t.current = !0;
    }),
    te.useCallback(
      function (i, s) {
        s === void 0 && (s = {}),
          t.current &&
            (typeof i == "number"
              ? n.navigate(i)
              : n.navigate(i, Tg({ fromRouteId: e }, s)));
      },
      [n, e]
    )
  );
}
function mO(n) {
  return tO(n.context);
}
function nl(n) {
  Ln(!1);
}
function gO(n) {
  let {
    basename: e = "/",
    children: t = null,
    location: r,
    navigationType: i = Qo.Pop,
    navigator: s,
    static: o = !1,
  } = n;
  td() && Ln(!1);
  let a = e.replace(/^\/*/, "/"),
    l = te.useMemo(() => ({ basename: a, navigator: s, static: o }), [a, s, o]);
  typeof r == "string" && (r = kl(r));
  let {
      pathname: u = "/",
      search: h = "",
      hash: d = "",
      state: p = null,
      key: m = "default",
    } = r,
    _ = te.useMemo(() => {
      let y = zA(u, a);
      return y == null
        ? null
        : {
            location: { pathname: y, search: h, hash: d, state: p, key: m },
            navigationType: i,
          };
    }, [a, u, h, d, p, m, i]);
  return _ == null
    ? null
    : te.createElement(
        zc.Provider,
        { value: l },
        te.createElement(a0.Provider, { children: t, value: _ })
      );
}
function _O(n) {
  let { children: e, location: t } = n;
  return rO(Dx(e), t);
}
var tC;
(function (n) {
  (n[(n.pending = 0)] = "pending"),
    (n[(n.success = 1)] = "success"),
    (n[(n.error = 2)] = "error");
})(tC || (tC = {}));
new Promise(() => {});
function Dx(n, e) {
  e === void 0 && (e = []);
  let t = [];
  return (
    te.Children.forEach(n, (r, i) => {
      if (!te.isValidElement(r)) return;
      let s = [...e, i];
      if (r.type === te.Fragment) {
        t.push.apply(t, Dx(r.props.children, s));
        return;
      }
      r.type !== nl && Ln(!1), !r.props.index || !r.props.children || Ln(!1);
      let o = {
        id: r.props.id || s.join("-"),
        caseSensitive: r.props.caseSensitive,
        element: r.props.element,
        Component: r.props.Component,
        index: r.props.index,
        path: r.props.path,
        loader: r.props.loader,
        action: r.props.action,
        errorElement: r.props.errorElement,
        ErrorBoundary: r.props.ErrorBoundary,
        hasErrorBoundary:
          r.props.ErrorBoundary != null || r.props.errorElement != null,
        shouldRevalidate: r.props.shouldRevalidate,
        handle: r.props.handle,
        lazy: r.props.lazy,
      };
      r.props.children && (o.children = Dx(r.props.children, s)), t.push(o);
    }),
    t
  );
}
/**
 * React Router DOM v6.11.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Fx() {
  return (
    (Fx = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)
              Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }),
    Fx.apply(this, arguments)
  );
}
function vO(n, e) {
  if (n == null) return {};
  var t = {},
    r = Object.keys(n),
    i,
    s;
  for (s = 0; s < r.length; s++)
    (i = r[s]), !(e.indexOf(i) >= 0) && (t[i] = n[i]);
  return t;
}
function yO(n) {
  return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey);
}
function xO(n, e) {
  return n.button === 0 && (!e || e === "_self") && !yO(n);
}
const SO = [
  "onClick",
  "relative",
  "reloadDocument",
  "replace",
  "state",
  "target",
  "to",
  "preventScrollReset",
];
function AO(n) {
  let { basename: e, children: t, window: r } = n,
    i = te.useRef();
  i.current == null && (i.current = CN({ window: r, v5Compat: !0 }));
  let s = i.current,
    [o, a] = te.useState({ action: s.action, location: s.location });
  return (
    te.useLayoutEffect(() => s.listen(a), [s]),
    te.createElement(gO, {
      basename: e,
      children: t,
      location: o.location,
      navigationType: o.action,
      navigator: s,
    })
  );
}
const MO =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  EO = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  rB = te.forwardRef(function (e, t) {
    let {
        onClick: r,
        relative: i,
        reloadDocument: s,
        replace: o,
        state: a,
        target: l,
        to: u,
        preventScrollReset: h,
      } = e,
      d = vO(e, SO),
      { basename: p } = te.useContext(zc),
      m,
      _ = !1;
    if (typeof u == "string" && EO.test(u) && ((m = u), MO))
      try {
        let S = new URL(window.location.href),
          A = u.startsWith("//") ? new URL(S.protocol + u) : new URL(u),
          E = zA(A.pathname, p);
        A.origin === S.origin && E != null
          ? (u = E + A.search + A.hash)
          : (_ = !0);
      } catch {}
    let y = ZN(u, { relative: i }),
      x = wO(u, {
        replace: o,
        state: a,
        target: l,
        preventScrollReset: h,
        relative: i,
      });
    function g(S) {
      r && r(S), S.defaultPrevented || x(S);
    }
    return te.createElement(
      "a",
      Fx({}, d, { href: m || y, onClick: _ || s ? r : g, ref: t, target: l })
    );
  });
var nC;
(function (n) {
  (n.UseScrollRestoration = "useScrollRestoration"),
    (n.UseSubmitImpl = "useSubmitImpl"),
    (n.UseFetcher = "useFetcher");
})(nC || (nC = {}));
var rC;
(function (n) {
  (n.UseFetchers = "useFetchers"),
    (n.UseScrollRestoration = "useScrollRestoration");
})(rC || (rC = {}));
function wO(n, e) {
  let {
      target: t,
      replace: r,
      state: i,
      preventScrollReset: s,
      relative: o,
    } = e === void 0 ? {} : e,
    a = nd(),
    l = l0(),
    u = tB(n, { relative: o });
  return te.useCallback(
    (h) => {
      if (xO(h, t)) {
        h.preventDefault();
        let d = r !== void 0 ? r : Cg(l) === Cg(u);
        a(n, { replace: d, state: i, preventScrollReset: s, relative: o });
      }
    },
    [l, a, u, r, i, t, n, s, o]
  );
}
function CO() {
  let n = nd();
  return J.jsxs(J.Fragment, {
    children: [
      J.jsxs("div", {
        className: Qw.container,
        children: [
          J.jsx("img", { src: "./assets/cover.jpeg", alt: "" }),
          J.jsxs("div", {
            className: Qw.title,
            children: [
              J.jsx("h2", {
                onClick: () => n("/"),
                children: "TheShowRunner Tickets",
              }),
              J.jsx("h3", {
                children: "Millions of Movies to experience in theaters.",
              }),
            ],
          }),
        ],
      }),
      J.jsx(mO, {}),
    ],
  });
}
function iB(n, e) {
  return function () {
    return n.apply(e, arguments);
  };
}
const { toString: TO } = Object.prototype,
  { getPrototypeOf: GA } = Object,
  u0 = ((n) => (e) => {
    const t = TO.call(e);
    return n[t] || (n[t] = t.slice(8, -1).toLowerCase());
  })(Object.create(null)),
  ks = (n) => ((n = n.toLowerCase()), (e) => u0(e) === n),
  c0 = (n) => (e) => typeof e === n,
  { isArray: Hc } = Array,
  Rh = c0("undefined");
function bO(n) {
  return (
    n !== null &&
    !Rh(n) &&
    n.constructor !== null &&
    !Rh(n.constructor) &&
    Ui(n.constructor.isBuffer) &&
    n.constructor.isBuffer(n)
  );
}
const sB = ks("ArrayBuffer");
function RO(n) {
  let e;
  return (
    typeof ArrayBuffer < "u" && ArrayBuffer.isView
      ? (e = ArrayBuffer.isView(n))
      : (e = n && n.buffer && sB(n.buffer)),
    e
  );
}
const PO = c0("string"),
  Ui = c0("function"),
  oB = c0("number"),
  f0 = (n) => n !== null && typeof n == "object",
  BO = (n) => n === !0 || n === !1,
  km = (n) => {
    if (u0(n) !== "object") return !1;
    const e = GA(n);
    return (
      (e === null ||
        e === Object.prototype ||
        Object.getPrototypeOf(e) === null) &&
      !(Symbol.toStringTag in n) &&
      !(Symbol.iterator in n)
    );
  },
  LO = ks("Date"),
  IO = ks("File"),
  DO = ks("Blob"),
  FO = ks("FileList"),
  NO = (n) => f0(n) && Ui(n.pipe),
  OO = (n) => {
    let e;
    return (
      n &&
      ((typeof FormData == "function" && n instanceof FormData) ||
        (Ui(n.append) &&
          ((e = u0(n)) === "formdata" ||
            (e === "object" &&
              Ui(n.toString) &&
              n.toString() === "[object FormData]"))))
    );
  },
  UO = ks("URLSearchParams"),
  kO = (n) =>
    n.trim ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function rd(n, e, { allOwnKeys: t = !1 } = {}) {
  if (n === null || typeof n > "u") return;
  let r, i;
  if ((typeof n != "object" && (n = [n]), Hc(n)))
    for (r = 0, i = n.length; r < i; r++) e.call(null, n[r], r, n);
  else {
    const s = t ? Object.getOwnPropertyNames(n) : Object.keys(n),
      o = s.length;
    let a;
    for (r = 0; r < o; r++) (a = s[r]), e.call(null, n[a], a, n);
  }
}
function aB(n, e) {
  e = e.toLowerCase();
  const t = Object.keys(n);
  let r = t.length,
    i;
  for (; r-- > 0; ) if (((i = t[r]), e === i.toLowerCase())) return i;
  return null;
}
const lB = (() =>
    typeof globalThis < "u"
      ? globalThis
      : typeof self < "u"
      ? self
      : typeof window < "u"
      ? window
      : global)(),
  uB = (n) => !Rh(n) && n !== lB;
function Nx() {
  const { caseless: n } = (uB(this) && this) || {},
    e = {},
    t = (r, i) => {
      const s = (n && aB(e, i)) || i;
      km(e[s]) && km(r)
        ? (e[s] = Nx(e[s], r))
        : km(r)
        ? (e[s] = Nx({}, r))
        : Hc(r)
        ? (e[s] = r.slice())
        : (e[s] = r);
    };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && rd(arguments[r], t);
  return e;
}
const zO = (n, e, t, { allOwnKeys: r } = {}) => (
    rd(
      e,
      (i, s) => {
        t && Ui(i) ? (n[s] = iB(i, t)) : (n[s] = i);
      },
      { allOwnKeys: r }
    ),
    n
  ),
  HO = (n) => (n.charCodeAt(0) === 65279 && (n = n.slice(1)), n),
  GO = (n, e, t, r) => {
    (n.prototype = Object.create(e.prototype, r)),
      (n.prototype.constructor = n),
      Object.defineProperty(n, "super", { value: e.prototype }),
      t && Object.assign(n.prototype, t);
  },
  VO = (n, e, t, r) => {
    let i, s, o;
    const a = {};
    if (((e = e || {}), n == null)) return e;
    do {
      for (i = Object.getOwnPropertyNames(n), s = i.length; s-- > 0; )
        (o = i[s]), (!r || r(o, n, e)) && !a[o] && ((e[o] = n[o]), (a[o] = !0));
      n = t !== !1 && GA(n);
    } while (n && (!t || t(n, e)) && n !== Object.prototype);
    return e;
  },
  WO = (n, e, t) => {
    (n = String(n)),
      (t === void 0 || t > n.length) && (t = n.length),
      (t -= e.length);
    const r = n.indexOf(e, t);
    return r !== -1 && r === t;
  },
  jO = (n) => {
    if (!n) return null;
    if (Hc(n)) return n;
    let e = n.length;
    if (!oB(e)) return null;
    const t = new Array(e);
    for (; e-- > 0; ) t[e] = n[e];
    return t;
  },
  XO = (
    (n) => (e) =>
      n && e instanceof n
  )(typeof Uint8Array < "u" && GA(Uint8Array)),
  JO = (n, e) => {
    const r = (n && n[Symbol.iterator]).call(n);
    let i;
    for (; (i = r.next()) && !i.done; ) {
      const s = i.value;
      e.call(n, s[0], s[1]);
    }
  },
  KO = (n, e) => {
    let t;
    const r = [];
    for (; (t = n.exec(e)) !== null; ) r.push(t);
    return r;
  },
  YO = ks("HTMLFormElement"),
  QO = (n) =>
    n.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (t, r, i) {
      return r.toUpperCase() + i;
    }),
  iC = (
    ({ hasOwnProperty: n }) =>
    (e, t) =>
      n.call(e, t)
  )(Object.prototype),
  qO = ks("RegExp"),
  cB = (n, e) => {
    const t = Object.getOwnPropertyDescriptors(n),
      r = {};
    rd(t, (i, s) => {
      e(i, s, n) !== !1 && (r[s] = i);
    }),
      Object.defineProperties(n, r);
  },
  ZO = (n) => {
    cB(n, (e, t) => {
      if (Ui(n) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
        return !1;
      const r = n[t];
      if (Ui(r)) {
        if (((e.enumerable = !1), "writable" in e)) {
          e.writable = !1;
          return;
        }
        e.set ||
          (e.set = () => {
            throw Error("Can not rewrite read-only method '" + t + "'");
          });
      }
    });
  },
  $O = (n, e) => {
    const t = {},
      r = (i) => {
        i.forEach((s) => {
          t[s] = !0;
        });
      };
    return Hc(n) ? r(n) : r(String(n).split(e)), t;
  },
  eU = () => {},
  tU = (n, e) => ((n = +n), Number.isFinite(n) ? n : e),
  Rv = "abcdefghijklmnopqrstuvwxyz",
  sC = "0123456789",
  fB = { DIGIT: sC, ALPHA: Rv, ALPHA_DIGIT: Rv + Rv.toUpperCase() + sC },
  nU = (n = 16, e = fB.ALPHA_DIGIT) => {
    let t = "";
    const { length: r } = e;
    for (; n--; ) t += e[(Math.random() * r) | 0];
    return t;
  };
function rU(n) {
  return !!(
    n &&
    Ui(n.append) &&
    n[Symbol.toStringTag] === "FormData" &&
    n[Symbol.iterator]
  );
}
const iU = (n) => {
    const e = new Array(10),
      t = (r, i) => {
        if (f0(r)) {
          if (e.indexOf(r) >= 0) return;
          if (!("toJSON" in r)) {
            e[i] = r;
            const s = Hc(r) ? [] : {};
            return (
              rd(r, (o, a) => {
                const l = t(o, i + 1);
                !Rh(l) && (s[a] = l);
              }),
              (e[i] = void 0),
              s
            );
          }
        }
        return r;
      };
    return t(n, 0);
  },
  sU = ks("AsyncFunction"),
  oU = (n) => n && (f0(n) || Ui(n)) && Ui(n.then) && Ui(n.catch),
  me = {
    isArray: Hc,
    isArrayBuffer: sB,
    isBuffer: bO,
    isFormData: OO,
    isArrayBufferView: RO,
    isString: PO,
    isNumber: oB,
    isBoolean: BO,
    isObject: f0,
    isPlainObject: km,
    isUndefined: Rh,
    isDate: LO,
    isFile: IO,
    isBlob: DO,
    isRegExp: qO,
    isFunction: Ui,
    isStream: NO,
    isURLSearchParams: UO,
    isTypedArray: XO,
    isFileList: FO,
    forEach: rd,
    merge: Nx,
    extend: zO,
    trim: kO,
    stripBOM: HO,
    inherits: GO,
    toFlatObject: VO,
    kindOf: u0,
    kindOfTest: ks,
    endsWith: WO,
    toArray: jO,
    forEachEntry: JO,
    matchAll: KO,
    isHTMLForm: YO,
    hasOwnProperty: iC,
    hasOwnProp: iC,
    reduceDescriptors: cB,
    freezeMethods: ZO,
    toObjectSet: $O,
    toCamelCase: QO,
    noop: eU,
    toFiniteNumber: tU,
    findKey: aB,
    global: lB,
    isContextDefined: uB,
    ALPHABET: fB,
    generateString: nU,
    isSpecCompliantForm: rU,
    toJSONObject: iU,
    isAsyncFn: sU,
    isThenable: oU,
  };
function Rt(n, e, t, r, i) {
  Error.call(this),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack),
    (this.message = n),
    (this.name = "AxiosError"),
    e && (this.code = e),
    t && (this.config = t),
    r && (this.request = r),
    i && (this.response = i);
}
me.inherits(Rt, Error, {
  toJSON: function () {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: me.toJSONObject(this.config),
      code: this.code,
      status:
        this.response && this.response.status ? this.response.status : null,
    };
  },
});
const hB = Rt.prototype,
  dB = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL",
].forEach((n) => {
  dB[n] = { value: n };
});
Object.defineProperties(Rt, dB);
Object.defineProperty(hB, "isAxiosError", { value: !0 });
Rt.from = (n, e, t, r, i, s) => {
  const o = Object.create(hB);
  return (
    me.toFlatObject(
      n,
      o,
      function (l) {
        return l !== Error.prototype;
      },
      (a) => a !== "isAxiosError"
    ),
    Rt.call(o, n.message, e, t, r, i),
    (o.cause = n),
    (o.name = n.name),
    s && Object.assign(o, s),
    o
  );
};
const aU = null;
function Ox(n) {
  return me.isPlainObject(n) || me.isArray(n);
}
function pB(n) {
  return me.endsWith(n, "[]") ? n.slice(0, -2) : n;
}
function oC(n, e, t) {
  return n
    ? n
        .concat(e)
        .map(function (i, s) {
          return (i = pB(i)), !t && s ? "[" + i + "]" : i;
        })
        .join(t ? "." : "")
    : e;
}
function lU(n) {
  return me.isArray(n) && !n.some(Ox);
}
const uU = me.toFlatObject(me, {}, null, function (e) {
  return /^is[A-Z]/.test(e);
});
function h0(n, e, t) {
  if (!me.isObject(n)) throw new TypeError("target must be an object");
  (e = e || new FormData()),
    (t = me.toFlatObject(
      t,
      { metaTokens: !0, dots: !1, indexes: !1 },
      !1,
      function (y, x) {
        return !me.isUndefined(x[y]);
      }
    ));
  const r = t.metaTokens,
    i = t.visitor || h,
    s = t.dots,
    o = t.indexes,
    l = (t.Blob || (typeof Blob < "u" && Blob)) && me.isSpecCompliantForm(e);
  if (!me.isFunction(i)) throw new TypeError("visitor must be a function");
  function u(_) {
    if (_ === null) return "";
    if (me.isDate(_)) return _.toISOString();
    if (!l && me.isBlob(_))
      throw new Rt("Blob is not supported. Use a Buffer instead.");
    return me.isArrayBuffer(_) || me.isTypedArray(_)
      ? l && typeof Blob == "function"
        ? new Blob([_])
        : Buffer.from(_)
      : _;
  }
  function h(_, y, x) {
    let g = _;
    if (_ && !x && typeof _ == "object") {
      if (me.endsWith(y, "{}"))
        (y = r ? y : y.slice(0, -2)), (_ = JSON.stringify(_));
      else if (
        (me.isArray(_) && lU(_)) ||
        ((me.isFileList(_) || me.endsWith(y, "[]")) && (g = me.toArray(_)))
      )
        return (
          (y = pB(y)),
          g.forEach(function (A, E) {
            !(me.isUndefined(A) || A === null) &&
              e.append(
                o === !0 ? oC([y], E, s) : o === null ? y : y + "[]",
                u(A)
              );
          }),
          !1
        );
    }
    return Ox(_) ? !0 : (e.append(oC(x, y, s), u(_)), !1);
  }
  const d = [],
    p = Object.assign(uU, {
      defaultVisitor: h,
      convertValue: u,
      isVisitable: Ox,
    });
  function m(_, y) {
    if (!me.isUndefined(_)) {
      if (d.indexOf(_) !== -1)
        throw Error("Circular reference detected in " + y.join("."));
      d.push(_),
        me.forEach(_, function (g, S) {
          (!(me.isUndefined(g) || g === null) &&
            i.call(e, g, me.isString(S) ? S.trim() : S, y, p)) === !0 &&
            m(g, y ? y.concat(S) : [S]);
        }),
        d.pop();
    }
  }
  if (!me.isObject(n)) throw new TypeError("data must be an object");
  return m(n), e;
}
function aC(n) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0",
  };
  return encodeURIComponent(n).replace(/[!'()~]|%20|%00/g, function (r) {
    return e[r];
  });
}
function VA(n, e) {
  (this._pairs = []), n && h0(n, this, e);
}
const mB = VA.prototype;
mB.append = function (e, t) {
  this._pairs.push([e, t]);
};
mB.toString = function (e) {
  const t = e
    ? function (r) {
        return e.call(this, r, aC);
      }
    : aC;
  return this._pairs
    .map(function (i) {
      return t(i[0]) + "=" + t(i[1]);
    }, "")
    .join("&");
};
function cU(n) {
  return encodeURIComponent(n)
    .replace(/%3A/gi, ":")
    .replace(/%24/g, "$")
    .replace(/%2C/gi, ",")
    .replace(/%20/g, "+")
    .replace(/%5B/gi, "[")
    .replace(/%5D/gi, "]");
}
function gB(n, e, t) {
  if (!e) return n;
  const r = (t && t.encode) || cU,
    i = t && t.serialize;
  let s;
  if (
    (i
      ? (s = i(e, t))
      : (s = me.isURLSearchParams(e) ? e.toString() : new VA(e, t).toString(r)),
    s)
  ) {
    const o = n.indexOf("#");
    o !== -1 && (n = n.slice(0, o)),
      (n += (n.indexOf("?") === -1 ? "?" : "&") + s);
  }
  return n;
}
class fU {
  constructor() {
    this.handlers = [];
  }
  use(e, t, r) {
    return (
      this.handlers.push({
        fulfilled: e,
        rejected: t,
        synchronous: r ? r.synchronous : !1,
        runWhen: r ? r.runWhen : null,
      }),
      this.handlers.length - 1
    );
  }
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  clear() {
    this.handlers && (this.handlers = []);
  }
  forEach(e) {
    me.forEach(this.handlers, function (r) {
      r !== null && e(r);
    });
  }
}
const lC = fU,
  _B = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1,
  },
  hU = typeof URLSearchParams < "u" ? URLSearchParams : VA,
  dU = typeof FormData < "u" ? FormData : null,
  pU = typeof Blob < "u" ? Blob : null,
  mU = (() => {
    let n;
    return typeof navigator < "u" &&
      ((n = navigator.product) === "ReactNative" ||
        n === "NativeScript" ||
        n === "NS")
      ? !1
      : typeof window < "u" && typeof document < "u";
  })(),
  gU = (() =>
    typeof WorkerGlobalScope < "u" &&
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts == "function")(),
  ws = {
    isBrowser: !0,
    classes: { URLSearchParams: hU, FormData: dU, Blob: pU },
    isStandardBrowserEnv: mU,
    isStandardBrowserWebWorkerEnv: gU,
    protocols: ["http", "https", "file", "blob", "url", "data"],
  };
function _U(n, e) {
  return h0(
    n,
    new ws.classes.URLSearchParams(),
    Object.assign(
      {
        visitor: function (t, r, i, s) {
          return ws.isNode && me.isBuffer(t)
            ? (this.append(r, t.toString("base64")), !1)
            : s.defaultVisitor.apply(this, arguments);
        },
      },
      e
    )
  );
}
function vU(n) {
  return me
    .matchAll(/\w+|\[(\w*)]/g, n)
    .map((e) => (e[0] === "[]" ? "" : e[1] || e[0]));
}
function yU(n) {
  const e = {},
    t = Object.keys(n);
  let r;
  const i = t.length;
  let s;
  for (r = 0; r < i; r++) (s = t[r]), (e[s] = n[s]);
  return e;
}
function vB(n) {
  function e(t, r, i, s) {
    let o = t[s++];
    const a = Number.isFinite(+o),
      l = s >= t.length;
    return (
      (o = !o && me.isArray(i) ? i.length : o),
      l
        ? (me.hasOwnProp(i, o) ? (i[o] = [i[o], r]) : (i[o] = r), !a)
        : ((!i[o] || !me.isObject(i[o])) && (i[o] = []),
          e(t, r, i[o], s) && me.isArray(i[o]) && (i[o] = yU(i[o])),
          !a)
    );
  }
  if (me.isFormData(n) && me.isFunction(n.entries)) {
    const t = {};
    return (
      me.forEachEntry(n, (r, i) => {
        e(vU(r), i, t, 0);
      }),
      t
    );
  }
  return null;
}
const xU = { "Content-Type": void 0 };
function SU(n, e, t) {
  if (me.isString(n))
    try {
      return (e || JSON.parse)(n), me.trim(n);
    } catch (r) {
      if (r.name !== "SyntaxError") throw r;
    }
  return (t || JSON.stringify)(n);
}
const d0 = {
  transitional: _B,
  adapter: ["xhr", "http"],
  transformRequest: [
    function (e, t) {
      const r = t.getContentType() || "",
        i = r.indexOf("application/json") > -1,
        s = me.isObject(e);
      if ((s && me.isHTMLForm(e) && (e = new FormData(e)), me.isFormData(e)))
        return i && i ? JSON.stringify(vB(e)) : e;
      if (
        me.isArrayBuffer(e) ||
        me.isBuffer(e) ||
        me.isStream(e) ||
        me.isFile(e) ||
        me.isBlob(e)
      )
        return e;
      if (me.isArrayBufferView(e)) return e.buffer;
      if (me.isURLSearchParams(e))
        return (
          t.setContentType(
            "application/x-www-form-urlencoded;charset=utf-8",
            !1
          ),
          e.toString()
        );
      let a;
      if (s) {
        if (r.indexOf("application/x-www-form-urlencoded") > -1)
          return _U(e, this.formSerializer).toString();
        if ((a = me.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
          const l = this.env && this.env.FormData;
          return h0(
            a ? { "files[]": e } : e,
            l && new l(),
            this.formSerializer
          );
        }
      }
      return s || i ? (t.setContentType("application/json", !1), SU(e)) : e;
    },
  ],
  transformResponse: [
    function (e) {
      const t = this.transitional || d0.transitional,
        r = t && t.forcedJSONParsing,
        i = this.responseType === "json";
      if (e && me.isString(e) && ((r && !this.responseType) || i)) {
        const o = !(t && t.silentJSONParsing) && i;
        try {
          return JSON.parse(e);
        } catch (a) {
          if (o)
            throw a.name === "SyntaxError"
              ? Rt.from(a, Rt.ERR_BAD_RESPONSE, this, null, this.response)
              : a;
        }
      }
      return e;
    },
  ],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: { FormData: ws.classes.FormData, Blob: ws.classes.Blob },
  validateStatus: function (e) {
    return e >= 200 && e < 300;
  },
  headers: { common: { Accept: "application/json, text/plain, */*" } },
};
me.forEach(["delete", "get", "head"], function (e) {
  d0.headers[e] = {};
});
me.forEach(["post", "put", "patch"], function (e) {
  d0.headers[e] = me.merge(xU);
});
const WA = d0,
  AU = me.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent",
  ]),
  MU = (n) => {
    const e = {};
    let t, r, i;
    return (
      n &&
        n
          .split(
            `
`
          )
          .forEach(function (o) {
            (i = o.indexOf(":")),
              (t = o.substring(0, i).trim().toLowerCase()),
              (r = o.substring(i + 1).trim()),
              !(!t || (e[t] && AU[t])) &&
                (t === "set-cookie"
                  ? e[t]
                    ? e[t].push(r)
                    : (e[t] = [r])
                  : (e[t] = e[t] ? e[t] + ", " + r : r));
          }),
      e
    );
  },
  uC = Symbol("internals");
function Af(n) {
  return n && String(n).trim().toLowerCase();
}
function zm(n) {
  return n === !1 || n == null ? n : me.isArray(n) ? n.map(zm) : String(n);
}
function EU(n) {
  const e = Object.create(null),
    t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; (r = t.exec(n)); ) e[r[1]] = r[2];
  return e;
}
const wU = (n) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(n.trim());
function Pv(n, e, t, r, i) {
  if (me.isFunction(r)) return r.call(this, e, t);
  if ((i && (e = t), !!me.isString(e))) {
    if (me.isString(r)) return e.indexOf(r) !== -1;
    if (me.isRegExp(r)) return r.test(e);
  }
}
function CU(n) {
  return n
    .trim()
    .toLowerCase()
    .replace(/([a-z\d])(\w*)/g, (e, t, r) => t.toUpperCase() + r);
}
function TU(n, e) {
  const t = me.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(n, r + t, {
      value: function (i, s, o) {
        return this[r].call(this, e, i, s, o);
      },
      configurable: !0,
    });
  });
}
class p0 {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, r) {
    const i = this;
    function s(a, l, u) {
      const h = Af(l);
      if (!h) throw new Error("header name must be a non-empty string");
      const d = me.findKey(i, h);
      (!d || i[d] === void 0 || u === !0 || (u === void 0 && i[d] !== !1)) &&
        (i[d || l] = zm(a));
    }
    const o = (a, l) => me.forEach(a, (u, h) => s(u, h, l));
    return (
      me.isPlainObject(e) || e instanceof this.constructor
        ? o(e, t)
        : me.isString(e) && (e = e.trim()) && !wU(e)
        ? o(MU(e), t)
        : e != null && s(t, e, r),
      this
    );
  }
  get(e, t) {
    if (((e = Af(e)), e)) {
      const r = me.findKey(this, e);
      if (r) {
        const i = this[r];
        if (!t) return i;
        if (t === !0) return EU(i);
        if (me.isFunction(t)) return t.call(this, i, r);
        if (me.isRegExp(t)) return t.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (((e = Af(e)), e)) {
      const r = me.findKey(this, e);
      return !!(r && this[r] !== void 0 && (!t || Pv(this, this[r], r, t)));
    }
    return !1;
  }
  delete(e, t) {
    const r = this;
    let i = !1;
    function s(o) {
      if (((o = Af(o)), o)) {
        const a = me.findKey(r, o);
        a && (!t || Pv(r, r[a], a, t)) && (delete r[a], (i = !0));
      }
    }
    return me.isArray(e) ? e.forEach(s) : s(e), i;
  }
  clear(e) {
    const t = Object.keys(this);
    let r = t.length,
      i = !1;
    for (; r--; ) {
      const s = t[r];
      (!e || Pv(this, this[s], s, e, !0)) && (delete this[s], (i = !0));
    }
    return i;
  }
  normalize(e) {
    const t = this,
      r = {};
    return (
      me.forEach(this, (i, s) => {
        const o = me.findKey(r, s);
        if (o) {
          (t[o] = zm(i)), delete t[s];
          return;
        }
        const a = e ? CU(s) : String(s).trim();
        a !== s && delete t[s], (t[a] = zm(i)), (r[a] = !0);
      }),
      this
    );
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const t = Object.create(null);
    return (
      me.forEach(this, (r, i) => {
        r != null && r !== !1 && (t[i] = e && me.isArray(r) ? r.join(", ") : r);
      }),
      t
    );
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...t) {
    const r = new this(e);
    return t.forEach((i) => r.set(i)), r;
  }
  static accessor(e) {
    const r = (this[uC] = this[uC] = { accessors: {} }).accessors,
      i = this.prototype;
    function s(o) {
      const a = Af(o);
      r[a] || (TU(i, o), (r[a] = !0));
    }
    return me.isArray(e) ? e.forEach(s) : s(e), this;
  }
}
p0.accessor([
  "Content-Type",
  "Content-Length",
  "Accept",
  "Accept-Encoding",
  "User-Agent",
  "Authorization",
]);
me.freezeMethods(p0.prototype);
me.freezeMethods(p0);
const fo = p0;
function Bv(n, e) {
  const t = this || WA,
    r = e || t,
    i = fo.from(r.headers);
  let s = r.data;
  return (
    me.forEach(n, function (a) {
      s = a.call(t, s, i.normalize(), e ? e.status : void 0);
    }),
    i.normalize(),
    s
  );
}
function yB(n) {
  return !!(n && n.__CANCEL__);
}
function id(n, e, t) {
  Rt.call(this, n ?? "canceled", Rt.ERR_CANCELED, e, t),
    (this.name = "CanceledError");
}
me.inherits(id, Rt, { __CANCEL__: !0 });
function bU(n, e, t) {
  const r = t.config.validateStatus;
  !t.status || !r || r(t.status)
    ? n(t)
    : e(
        new Rt(
          "Request failed with status code " + t.status,
          [Rt.ERR_BAD_REQUEST, Rt.ERR_BAD_RESPONSE][
            Math.floor(t.status / 100) - 4
          ],
          t.config,
          t.request,
          t
        )
      );
}
const RU = ws.isStandardBrowserEnv
  ? (function () {
      return {
        write: function (t, r, i, s, o, a) {
          const l = [];
          l.push(t + "=" + encodeURIComponent(r)),
            me.isNumber(i) && l.push("expires=" + new Date(i).toGMTString()),
            me.isString(s) && l.push("path=" + s),
            me.isString(o) && l.push("domain=" + o),
            a === !0 && l.push("secure"),
            (document.cookie = l.join("; "));
        },
        read: function (t) {
          const r = document.cookie.match(
            new RegExp("(^|;\\s*)(" + t + ")=([^;]*)")
          );
          return r ? decodeURIComponent(r[3]) : null;
        },
        remove: function (t) {
          this.write(t, "", Date.now() - 864e5);
        },
      };
    })()
  : (function () {
      return {
        write: function () {},
        read: function () {
          return null;
        },
        remove: function () {},
      };
    })();
function PU(n) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n);
}
function BU(n, e) {
  return e ? n.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : n;
}
function xB(n, e) {
  return n && !PU(e) ? BU(n, e) : e;
}
const LU = ws.isStandardBrowserEnv
  ? (function () {
      const e = /(msie|trident)/i.test(navigator.userAgent),
        t = document.createElement("a");
      let r;
      function i(s) {
        let o = s;
        return (
          e && (t.setAttribute("href", o), (o = t.href)),
          t.setAttribute("href", o),
          {
            href: t.href,
            protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
            host: t.host,
            search: t.search ? t.search.replace(/^\?/, "") : "",
            hash: t.hash ? t.hash.replace(/^#/, "") : "",
            hostname: t.hostname,
            port: t.port,
            pathname:
              t.pathname.charAt(0) === "/" ? t.pathname : "/" + t.pathname,
          }
        );
      }
      return (
        (r = i(window.location.href)),
        function (o) {
          const a = me.isString(o) ? i(o) : o;
          return a.protocol === r.protocol && a.host === r.host;
        }
      );
    })()
  : (function () {
      return function () {
        return !0;
      };
    })();
function IU(n) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n);
  return (e && e[1]) || "";
}
function DU(n, e) {
  n = n || 10;
  const t = new Array(n),
    r = new Array(n);
  let i = 0,
    s = 0,
    o;
  return (
    (e = e !== void 0 ? e : 1e3),
    function (l) {
      const u = Date.now(),
        h = r[s];
      o || (o = u), (t[i] = l), (r[i] = u);
      let d = s,
        p = 0;
      for (; d !== i; ) (p += t[d++]), (d = d % n);
      if (((i = (i + 1) % n), i === s && (s = (s + 1) % n), u - o < e)) return;
      const m = h && u - h;
      return m ? Math.round((p * 1e3) / m) : void 0;
    }
  );
}
function cC(n, e) {
  let t = 0;
  const r = DU(50, 250);
  return (i) => {
    const s = i.loaded,
      o = i.lengthComputable ? i.total : void 0,
      a = s - t,
      l = r(a),
      u = s <= o;
    t = s;
    const h = {
      loaded: s,
      total: o,
      progress: o ? s / o : void 0,
      bytes: a,
      rate: l || void 0,
      estimated: l && o && u ? (o - s) / l : void 0,
      event: i,
    };
    (h[e ? "download" : "upload"] = !0), n(h);
  };
}
const FU = typeof XMLHttpRequest < "u",
  NU =
    FU &&
    function (n) {
      return new Promise(function (t, r) {
        let i = n.data;
        const s = fo.from(n.headers).normalize(),
          o = n.responseType;
        let a;
        function l() {
          n.cancelToken && n.cancelToken.unsubscribe(a),
            n.signal && n.signal.removeEventListener("abort", a);
        }
        me.isFormData(i) &&
          (ws.isStandardBrowserEnv || ws.isStandardBrowserWebWorkerEnv
            ? s.setContentType(!1)
            : s.setContentType("multipart/form-data;", !1));
        let u = new XMLHttpRequest();
        if (n.auth) {
          const m = n.auth.username || "",
            _ = n.auth.password
              ? unescape(encodeURIComponent(n.auth.password))
              : "";
          s.set("Authorization", "Basic " + btoa(m + ":" + _));
        }
        const h = xB(n.baseURL, n.url);
        u.open(n.method.toUpperCase(), gB(h, n.params, n.paramsSerializer), !0),
          (u.timeout = n.timeout);
        function d() {
          if (!u) return;
          const m = fo.from(
              "getAllResponseHeaders" in u && u.getAllResponseHeaders()
            ),
            y = {
              data:
                !o || o === "text" || o === "json"
                  ? u.responseText
                  : u.response,
              status: u.status,
              statusText: u.statusText,
              headers: m,
              config: n,
              request: u,
            };
          bU(
            function (g) {
              t(g), l();
            },
            function (g) {
              r(g), l();
            },
            y
          ),
            (u = null);
        }
        if (
          ("onloadend" in u
            ? (u.onloadend = d)
            : (u.onreadystatechange = function () {
                !u ||
                  u.readyState !== 4 ||
                  (u.status === 0 &&
                    !(u.responseURL && u.responseURL.indexOf("file:") === 0)) ||
                  setTimeout(d);
              }),
          (u.onabort = function () {
            u &&
              (r(new Rt("Request aborted", Rt.ECONNABORTED, n, u)), (u = null));
          }),
          (u.onerror = function () {
            r(new Rt("Network Error", Rt.ERR_NETWORK, n, u)), (u = null);
          }),
          (u.ontimeout = function () {
            let _ = n.timeout
              ? "timeout of " + n.timeout + "ms exceeded"
              : "timeout exceeded";
            const y = n.transitional || _B;
            n.timeoutErrorMessage && (_ = n.timeoutErrorMessage),
              r(
                new Rt(
                  _,
                  y.clarifyTimeoutError ? Rt.ETIMEDOUT : Rt.ECONNABORTED,
                  n,
                  u
                )
              ),
              (u = null);
          }),
          ws.isStandardBrowserEnv)
        ) {
          const m =
            (n.withCredentials || LU(h)) &&
            n.xsrfCookieName &&
            RU.read(n.xsrfCookieName);
          m && s.set(n.xsrfHeaderName, m);
        }
        i === void 0 && s.setContentType(null),
          "setRequestHeader" in u &&
            me.forEach(s.toJSON(), function (_, y) {
              u.setRequestHeader(y, _);
            }),
          me.isUndefined(n.withCredentials) ||
            (u.withCredentials = !!n.withCredentials),
          o && o !== "json" && (u.responseType = n.responseType),
          typeof n.onDownloadProgress == "function" &&
            u.addEventListener("progress", cC(n.onDownloadProgress, !0)),
          typeof n.onUploadProgress == "function" &&
            u.upload &&
            u.upload.addEventListener("progress", cC(n.onUploadProgress)),
          (n.cancelToken || n.signal) &&
            ((a = (m) => {
              u &&
                (r(!m || m.type ? new id(null, n, u) : m),
                u.abort(),
                (u = null));
            }),
            n.cancelToken && n.cancelToken.subscribe(a),
            n.signal &&
              (n.signal.aborted ? a() : n.signal.addEventListener("abort", a)));
        const p = IU(h);
        if (p && ws.protocols.indexOf(p) === -1) {
          r(new Rt("Unsupported protocol " + p + ":", Rt.ERR_BAD_REQUEST, n));
          return;
        }
        u.send(i || null);
      });
    },
  Hm = { http: aU, xhr: NU };
me.forEach(Hm, (n, e) => {
  if (n) {
    try {
      Object.defineProperty(n, "name", { value: e });
    } catch {}
    Object.defineProperty(n, "adapterName", { value: e });
  }
});
const OU = {
  getAdapter: (n) => {
    n = me.isArray(n) ? n : [n];
    const { length: e } = n;
    let t, r;
    for (
      let i = 0;
      i < e && ((t = n[i]), !(r = me.isString(t) ? Hm[t.toLowerCase()] : t));
      i++
    );
    if (!r)
      throw r === !1
        ? new Rt(
            `Adapter ${t} is not supported by the environment`,
            "ERR_NOT_SUPPORT"
          )
        : new Error(
            me.hasOwnProp(Hm, t)
              ? `Adapter '${t}' is not available in the build`
              : `Unknown adapter '${t}'`
          );
    if (!me.isFunction(r)) throw new TypeError("adapter is not a function");
    return r;
  },
  adapters: Hm,
};
function Lv(n) {
  if (
    (n.cancelToken && n.cancelToken.throwIfRequested(),
    n.signal && n.signal.aborted)
  )
    throw new id(null, n);
}
function fC(n) {
  return (
    Lv(n),
    (n.headers = fo.from(n.headers)),
    (n.data = Bv.call(n, n.transformRequest)),
    ["post", "put", "patch"].indexOf(n.method) !== -1 &&
      n.headers.setContentType("application/x-www-form-urlencoded", !1),
    OU.getAdapter(n.adapter || WA.adapter)(n).then(
      function (r) {
        return (
          Lv(n),
          (r.data = Bv.call(n, n.transformResponse, r)),
          (r.headers = fo.from(r.headers)),
          r
        );
      },
      function (r) {
        return (
          yB(r) ||
            (Lv(n),
            r &&
              r.response &&
              ((r.response.data = Bv.call(n, n.transformResponse, r.response)),
              (r.response.headers = fo.from(r.response.headers)))),
          Promise.reject(r)
        );
      }
    )
  );
}
const hC = (n) => (n instanceof fo ? n.toJSON() : n);
function yc(n, e) {
  e = e || {};
  const t = {};
  function r(u, h, d) {
    return me.isPlainObject(u) && me.isPlainObject(h)
      ? me.merge.call({ caseless: d }, u, h)
      : me.isPlainObject(h)
      ? me.merge({}, h)
      : me.isArray(h)
      ? h.slice()
      : h;
  }
  function i(u, h, d) {
    if (me.isUndefined(h)) {
      if (!me.isUndefined(u)) return r(void 0, u, d);
    } else return r(u, h, d);
  }
  function s(u, h) {
    if (!me.isUndefined(h)) return r(void 0, h);
  }
  function o(u, h) {
    if (me.isUndefined(h)) {
      if (!me.isUndefined(u)) return r(void 0, u);
    } else return r(void 0, h);
  }
  function a(u, h, d) {
    if (d in e) return r(u, h);
    if (d in n) return r(void 0, u);
  }
  const l = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (u, h) => i(hC(u), hC(h), !0),
  };
  return (
    me.forEach(Object.keys(Object.assign({}, n, e)), function (h) {
      const d = l[h] || i,
        p = d(n[h], e[h], h);
      (me.isUndefined(p) && d !== a) || (t[h] = p);
    }),
    t
  );
}
const SB = "1.4.0",
  jA = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(
  (n, e) => {
    jA[n] = function (r) {
      return typeof r === n || "a" + (e < 1 ? "n " : " ") + n;
    };
  }
);
const dC = {};
jA.transitional = function (e, t, r) {
  function i(s, o) {
    return (
      "[Axios v" +
      SB +
      "] Transitional option '" +
      s +
      "'" +
      o +
      (r ? ". " + r : "")
    );
  }
  return (s, o, a) => {
    if (e === !1)
      throw new Rt(
        i(o, " has been removed" + (t ? " in " + t : "")),
        Rt.ERR_DEPRECATED
      );
    return (
      t &&
        !dC[o] &&
        ((dC[o] = !0),
        console.warn(
          i(
            o,
            " has been deprecated since v" +
              t +
              " and will be removed in the near future"
          )
        )),
      e ? e(s, o, a) : !0
    );
  };
};
function UU(n, e, t) {
  if (typeof n != "object")
    throw new Rt("options must be an object", Rt.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(n);
  let i = r.length;
  for (; i-- > 0; ) {
    const s = r[i],
      o = e[s];
    if (o) {
      const a = n[s],
        l = a === void 0 || o(a, s, n);
      if (l !== !0)
        throw new Rt("option " + s + " must be " + l, Rt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0) throw new Rt("Unknown option " + s, Rt.ERR_BAD_OPTION);
  }
}
const Ux = { assertOptions: UU, validators: jA },
  Fo = Ux.validators;
class bg {
  constructor(e) {
    (this.defaults = e),
      (this.interceptors = { request: new lC(), response: new lC() });
  }
  request(e, t) {
    typeof e == "string" ? ((t = t || {}), (t.url = e)) : (t = e || {}),
      (t = yc(this.defaults, t));
    const { transitional: r, paramsSerializer: i, headers: s } = t;
    r !== void 0 &&
      Ux.assertOptions(
        r,
        {
          silentJSONParsing: Fo.transitional(Fo.boolean),
          forcedJSONParsing: Fo.transitional(Fo.boolean),
          clarifyTimeoutError: Fo.transitional(Fo.boolean),
        },
        !1
      ),
      i != null &&
        (me.isFunction(i)
          ? (t.paramsSerializer = { serialize: i })
          : Ux.assertOptions(
              i,
              { encode: Fo.function, serialize: Fo.function },
              !0
            )),
      (t.method = (t.method || this.defaults.method || "get").toLowerCase());
    let o;
    (o = s && me.merge(s.common, s[t.method])),
      o &&
        me.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (_) => {
            delete s[_];
          }
        ),
      (t.headers = fo.concat(o, s));
    const a = [];
    let l = !0;
    this.interceptors.request.forEach(function (y) {
      (typeof y.runWhen == "function" && y.runWhen(t) === !1) ||
        ((l = l && y.synchronous), a.unshift(y.fulfilled, y.rejected));
    });
    const u = [];
    this.interceptors.response.forEach(function (y) {
      u.push(y.fulfilled, y.rejected);
    });
    let h,
      d = 0,
      p;
    if (!l) {
      const _ = [fC.bind(this), void 0];
      for (
        _.unshift.apply(_, a),
          _.push.apply(_, u),
          p = _.length,
          h = Promise.resolve(t);
        d < p;

      )
        h = h.then(_[d++], _[d++]);
      return h;
    }
    p = a.length;
    let m = t;
    for (d = 0; d < p; ) {
      const _ = a[d++],
        y = a[d++];
      try {
        m = _(m);
      } catch (x) {
        y.call(this, x);
        break;
      }
    }
    try {
      h = fC.call(this, m);
    } catch (_) {
      return Promise.reject(_);
    }
    for (d = 0, p = u.length; d < p; ) h = h.then(u[d++], u[d++]);
    return h;
  }
  getUri(e) {
    e = yc(this.defaults, e);
    const t = xB(e.baseURL, e.url);
    return gB(t, e.params, e.paramsSerializer);
  }
}
me.forEach(["delete", "get", "head", "options"], function (e) {
  bg.prototype[e] = function (t, r) {
    return this.request(
      yc(r || {}, { method: e, url: t, data: (r || {}).data })
    );
  };
});
me.forEach(["post", "put", "patch"], function (e) {
  function t(r) {
    return function (s, o, a) {
      return this.request(
        yc(a || {}, {
          method: e,
          headers: r ? { "Content-Type": "multipart/form-data" } : {},
          url: s,
          data: o,
        })
      );
    };
  }
  (bg.prototype[e] = t()), (bg.prototype[e + "Form"] = t(!0));
});
const Gm = bg;
class XA {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function (s) {
      t = s;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners) return;
      let s = r._listeners.length;
      for (; s-- > 0; ) r._listeners[s](i);
      r._listeners = null;
    }),
      (this.promise.then = (i) => {
        let s;
        const o = new Promise((a) => {
          r.subscribe(a), (s = a);
        }).then(i);
        return (
          (o.cancel = function () {
            r.unsubscribe(s);
          }),
          o
        );
      }),
      e(function (s, o, a) {
        r.reason || ((r.reason = new id(s, o, a)), t(r.reason));
      });
  }
  throwIfRequested() {
    if (this.reason) throw this.reason;
  }
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : (this._listeners = [e]);
  }
  unsubscribe(e) {
    if (!this._listeners) return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  static source() {
    let e;
    return {
      token: new XA(function (i) {
        e = i;
      }),
      cancel: e,
    };
  }
}
const kU = XA;
function zU(n) {
  return function (t) {
    return n.apply(null, t);
  };
}
function HU(n) {
  return me.isObject(n) && n.isAxiosError === !0;
}
const kx = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};
Object.entries(kx).forEach(([n, e]) => {
  kx[e] = n;
});
const GU = kx;
function AB(n) {
  const e = new Gm(n),
    t = iB(Gm.prototype.request, e);
  return (
    me.extend(t, Gm.prototype, e, { allOwnKeys: !0 }),
    me.extend(t, e, null, { allOwnKeys: !0 }),
    (t.create = function (i) {
      return AB(yc(n, i));
    }),
    t
  );
}
const zn = AB(WA);
zn.Axios = Gm;
zn.CanceledError = id;
zn.CancelToken = kU;
zn.isCancel = yB;
zn.VERSION = SB;
zn.toFormData = h0;
zn.AxiosError = Rt;
zn.Cancel = zn.CanceledError;
zn.all = function (e) {
  return Promise.all(e);
};
zn.spread = zU;
zn.isAxiosError = HU;
zn.mergeConfig = yc;
zn.AxiosHeaders = fo;
zn.formToJSON = (n) => vB(me.isHTMLForm(n) ? new FormData(n) : n);
zn.HttpStatusCode = GU;
zn.default = zn;
const MB = zn,
  VU = "_container_1t18o_1",
  WU = "_cards_1t18o_20",
  jU = { container: VU, cards: WU };
function XU({ imageURL: n, title: e, date: t }) {
  return J.jsx(J.Fragment, {
    children: J.jsx("div", {
      className: jU.container,
      children: J.jsx("img", {
        src: `https://image.tmdb.org/t/p/w300${n}`,
        alt: "",
      }),
    }),
  });
}
const JU = "_cardgrid_p7475_1",
  KU = "_search_p7475_12",
  YU = { cardgrid: JU, search: KU };
function QU() {
  const [n, e] = te.useState([]),
    [t, r] = te.useState("");
  te.useRef();
  const i = "6518ae7cd3d526b4453531051cc4d408",
    s = async (o) => {
      const { data: a } = await MB.get(
        `https://api.themoviedb.org/3/movie/now_playing?api_key=${i}&language=en-US`
      ).catch((l) => {
        console.log("Error:", l.message);
      });
      e(a.results);
    };
  return (
    te.useEffect(() => {
      s();
    }, [t]),
    J.jsx(J.Fragment, {
      children: J.jsx("div", {
        className: YU.cardgrid,
        children: n.map((o) =>
          J.jsx(
            rB,
            {
              to: `/${o.id}`,
              children: J.jsx(XU, {
                imageURL: o.poster_path,
                title: o.title,
                date: o.release_date,
              }),
            },
            o.id
          )
        ),
      }),
    })
  );
}
const qU = "_container_nl394_1",
  ZU = "_backdrop_nl394_5",
  $U = "_detailscontainer_nl394_12",
  ek = "_poster_nl394_16",
  tk = "_datacontainer_nl394_24",
  nk = "_overview_nl394_32",
  ou = {
    container: qU,
    backdrop: ZU,
    detailscontainer: $U,
    poster: ek,
    datacontainer: tk,
    overview: nk,
  },
  pC = (n) => {
    let e;
    const t = new Set(),
      r = (l, u) => {
        const h = typeof l == "function" ? l(e) : l;
        if (!Object.is(h, e)) {
          const d = e;
          (e = u ?? typeof h != "object" ? h : Object.assign({}, e, h)),
            t.forEach((p) => p(e, d));
        }
      },
      i = () => e,
      a = {
        setState: r,
        getState: i,
        subscribe: (l) => (t.add(l), () => t.delete(l)),
        destroy: () => {
          t.clear();
        },
      };
    return (e = n(r, i, a)), a;
  },
  rk = (n) => (n ? pC(n) : pC);
var EB = { exports: {} },
  wB = {},
  CB = { exports: {} },
  TB = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var xc = te;
function ik(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var sk = typeof Object.is == "function" ? Object.is : ik,
  ok = xc.useState,
  ak = xc.useEffect,
  lk = xc.useLayoutEffect,
  uk = xc.useDebugValue;
function ck(n, e) {
  var t = e(),
    r = ok({ inst: { value: t, getSnapshot: e } }),
    i = r[0].inst,
    s = r[1];
  return (
    lk(
      function () {
        (i.value = t), (i.getSnapshot = e), Iv(i) && s({ inst: i });
      },
      [n, t, e]
    ),
    ak(
      function () {
        return (
          Iv(i) && s({ inst: i }),
          n(function () {
            Iv(i) && s({ inst: i });
          })
        );
      },
      [n]
    ),
    uk(t),
    t
  );
}
function Iv(n) {
  var e = n.getSnapshot;
  n = n.value;
  try {
    var t = e();
    return !sk(n, t);
  } catch {
    return !0;
  }
}
function fk(n, e) {
  return e();
}
var hk =
  typeof window > "u" ||
  typeof window.document > "u" ||
  typeof window.document.createElement > "u"
    ? fk
    : ck;
TB.useSyncExternalStore =
  xc.useSyncExternalStore !== void 0 ? xc.useSyncExternalStore : hk;
CB.exports = TB;
var dk = CB.exports;
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var m0 = te,
  pk = dk;
function mk(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var gk = typeof Object.is == "function" ? Object.is : mk,
  _k = pk.useSyncExternalStore,
  vk = m0.useRef,
  yk = m0.useEffect,
  xk = m0.useMemo,
  Sk = m0.useDebugValue;
wB.useSyncExternalStoreWithSelector = function (n, e, t, r, i) {
  var s = vk(null);
  if (s.current === null) {
    var o = { hasValue: !1, value: null };
    s.current = o;
  } else o = s.current;
  s = xk(
    function () {
      function l(m) {
        if (!u) {
          if (((u = !0), (h = m), (m = r(m)), i !== void 0 && o.hasValue)) {
            var _ = o.value;
            if (i(_, m)) return (d = _);
          }
          return (d = m);
        }
        if (((_ = d), gk(h, m))) return _;
        var y = r(m);
        return i !== void 0 && i(_, y) ? _ : ((h = m), (d = y));
      }
      var u = !1,
        h,
        d,
        p = t === void 0 ? null : t;
      return [
        function () {
          return l(e());
        },
        p === null
          ? void 0
          : function () {
              return l(p());
            },
      ];
    },
    [e, t, r, i]
  );
  var a = _k(n, s[0], s[1]);
  return (
    yk(
      function () {
        (o.hasValue = !0), (o.value = a);
      },
      [a]
    ),
    Sk(a),
    a
  );
};
EB.exports = wB;
var Ak = EB.exports;
const Mk = Nc(Ak),
  { useSyncExternalStoreWithSelector: Ek } = Mk;
function wk(n, e = n.getState, t) {
  const r = Ek(n.subscribe, n.getState, n.getServerState || n.getState, e, t);
  return te.useDebugValue(r), r;
}
const mC = (n) => {
    const e = typeof n == "function" ? rk(n) : n,
      t = (r, i) => wk(e, r, i);
    return Object.assign(t, e), t;
  },
  bB = (n) => (n ? mC(n) : mC),
  JA = bB((n) => ({ url: [], setBackdrop: (e) => n(() => ({ url: e })) })),
  g0 = bB((n) => ({ ticket: 0, setTicket: (e) => n(() => ({ ticket: e })) }));
function Ck() {
  const n = nO();
  console.log(n.id);
  const [e, t] = te.useState([]),
    r = "6518ae7cd3d526b4453531051cc4d408",
    { setBackdrop: i } = JA(),
    s = async () => {
      const { data: o } = await MB.get(
        `https://api.themoviedb.org/3/movie/${n.id}?api_key=${r}&language=en-US`
      ).catch((a) => {
        console.log("Error:", a.message);
      });
      t(o);
    };
  return (
    te.useEffect(() => {
      s();
    }, [n]),
    console.log(e),
    J.jsx(J.Fragment, {
      children: J.jsxs("div", {
        className: ou.container,
        children: [
          J.jsx("img", {
            className: ou.backdrop,
            src: `https://image.tmdb.org/t/p/w300${
              e == null ? void 0 : e.backdrop_path
            }`,
            alt: "",
          }),
          J.jsxs("div", {
            className: ou.detailscontainer,
            children: [
              J.jsx("div", {
                className: ou.poster,
                children: J.jsx("img", {
                  src: `https://image.tmdb.org/t/p/w300${
                    e == null ? void 0 : e.poster_path
                  }`,
                  alt: "",
                }),
              }),
              J.jsxs("div", {
                className: ou.datacontainer,
                children: [
                  J.jsx("h1", { children: e == null ? void 0 : e.title }),
                  J.jsxs("div", {
                    className: ou.overview,
                    children: [
                      J.jsx("h3", { children: "Overview" }),
                      J.jsx("p", { children: e == null ? void 0 : e.overview }),
                    ],
                  }),
                  J.jsx(rB, {
                    to: "/seat",
                    children: J.jsx("button", {
                      onClick: () => i(e),
                      children: "Book Tickets",
                    }),
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
    })
  );
}
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const sd = "154",
  Tk = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  bk = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  RB = 0,
  zx = 1,
  PB = 2,
  Rk = 3,
  BB = 0,
  _0 = 1,
  nh = 2,
  Zi = 3,
  Fs = 0,
  Tr = 1,
  Li = 2,
  Pk = 2,
  ho = 0,
  yl = 1,
  Hx = 2,
  Gx = 3,
  Vx = 4,
  LB = 5,
  ol = 100,
  IB = 101,
  DB = 102,
  Wx = 103,
  jx = 104,
  FB = 200,
  NB = 201,
  OB = 202,
  UB = 203,
  KA = 204,
  YA = 205,
  kB = 206,
  zB = 207,
  HB = 208,
  GB = 209,
  VB = 210,
  WB = 0,
  jB = 1,
  XB = 2,
  Rg = 3,
  JB = 4,
  KB = 5,
  YB = 6,
  QB = 7,
  od = 0,
  qB = 1,
  ZB = 2,
  is = 0,
  $B = 1,
  e2 = 2,
  t2 = 3,
  QA = 4,
  n2 = 5,
  v0 = 300,
  va = 301,
  ya = 302,
  Ph = 303,
  Bh = 304,
  Gc = 306,
  xa = 1e3,
  er = 1001,
  Sc = 1002,
  mn = 1003,
  Lh = 1004,
  Bk = 1004,
  sc = 1005,
  Lk = 1005,
  sn = 1006,
  y0 = 1007,
  Ik = 1007,
  Ns = 1008,
  Dk = 1008,
  Bs = 1009,
  r2 = 1010,
  i2 = 1011,
  x0 = 1012,
  qA = 1013,
  lo = 1014,
  Cs = 1015,
  Ac = 1016,
  ZA = 1017,
  $A = 1018,
  ua = 1020,
  s2 = 1021,
  Nr = 1023,
  o2 = 1024,
  a2 = 1025,
  ca = 1026,
  Ll = 1027,
  l2 = 1028,
  e1 = 1029,
  u2 = 1030,
  t1 = 1031,
  n1 = 1033,
  Vm = 33776,
  Wm = 33777,
  jm = 33778,
  Xm = 33779,
  Xx = 35840,
  Jx = 35841,
  Kx = 35842,
  Yx = 35843,
  c2 = 36196,
  Qx = 37492,
  qx = 37496,
  Zx = 37808,
  $x = 37809,
  eS = 37810,
  tS = 37811,
  nS = 37812,
  rS = 37813,
  iS = 37814,
  sS = 37815,
  oS = 37816,
  aS = 37817,
  lS = 37818,
  uS = 37819,
  cS = 37820,
  fS = 37821,
  Jm = 36492,
  f2 = 36283,
  hS = 36284,
  dS = 36285,
  pS = 36286,
  h2 = 2200,
  d2 = 2201,
  p2 = 2202,
  Mc = 2300,
  Il = 2301,
  Km = 2302,
  fl = 2400,
  hl = 2401,
  Ih = 2402,
  S0 = 2500,
  r1 = 2501,
  m2 = 0,
  i1 = 1,
  Pg = 2,
  s1 = 3e3,
  fa = 3001,
  g2 = 3200,
  _2 = 3201,
  ba = 0,
  v2 = 1,
  ha = "",
  ht = "srgb",
  as = "srgb-linear",
  o1 = "display-p3",
  Fk = 0,
  Ym = 7680,
  Nk = 7681,
  Ok = 7682,
  Uk = 7683,
  kk = 34055,
  zk = 34056,
  Hk = 5386,
  Gk = 512,
  Vk = 513,
  Wk = 514,
  jk = 515,
  Xk = 516,
  Jk = 517,
  Kk = 518,
  y2 = 519,
  x2 = 512,
  S2 = 513,
  A2 = 514,
  M2 = 515,
  E2 = 516,
  w2 = 517,
  C2 = 518,
  T2 = 519,
  Dh = 35044,
  Yk = 35048,
  Qk = 35040,
  qk = 35045,
  Zk = 35049,
  $k = 35041,
  ez = 35046,
  tz = 35050,
  nz = 35042,
  rz = "100",
  mS = "300 es",
  Bg = 1035,
  Ts = 2e3,
  Fh = 2001;
class Mo {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const s = i.indexOf(t);
      s !== -1 && i.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let s = 0, o = i.length; s < o; s++) i[s].call(this, e);
      e.target = null;
    }
  }
}
const fr = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let gC = 1234567;
const xl = Math.PI / 180,
  Ec = 180 / Math.PI;
function ui() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    fr[n & 255] +
    fr[(n >> 8) & 255] +
    fr[(n >> 16) & 255] +
    fr[(n >> 24) & 255] +
    "-" +
    fr[e & 255] +
    fr[(e >> 8) & 255] +
    "-" +
    fr[((e >> 16) & 15) | 64] +
    fr[(e >> 24) & 255] +
    "-" +
    fr[(t & 63) | 128] +
    fr[(t >> 8) & 255] +
    "-" +
    fr[(t >> 16) & 255] +
    fr[(t >> 24) & 255] +
    fr[r & 255] +
    fr[(r >> 8) & 255] +
    fr[(r >> 16) & 255] +
    fr[(r >> 24) & 255]
  ).toLowerCase();
}
function gn(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function a1(n, e) {
  return ((n % e) + e) % e;
}
function iz(n, e, t, r, i) {
  return r + ((n - e) * (i - r)) / (t - e);
}
function sz(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function rh(n, e, t) {
  return (1 - t) * n + t * e;
}
function oz(n, e, t, r) {
  return rh(n, e, 1 - Math.exp(-t * r));
}
function az(n, e = 1) {
  return e - Math.abs(a1(n, e * 2) - e);
}
function lz(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function uz(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function cz(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function fz(n, e) {
  return n + Math.random() * (e - n);
}
function hz(n) {
  return n * (0.5 - Math.random());
}
function dz(n) {
  n !== void 0 && (gC = n);
  let e = (gC += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function pz(n) {
  return n * xl;
}
function mz(n) {
  return n * Ec;
}
function gS(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function b2(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function Lg(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function gz(n, e, t, r, i) {
  const s = Math.cos,
    o = Math.sin,
    a = s(t / 2),
    l = o(t / 2),
    u = s((e + r) / 2),
    h = o((e + r) / 2),
    d = s((e - r) / 2),
    p = o((e - r) / 2),
    m = s((r - e) / 2),
    _ = o((r - e) / 2);
  switch (i) {
    case "XYX":
      n.set(a * h, l * d, l * p, a * u);
      break;
    case "YZY":
      n.set(l * p, a * h, l * d, a * u);
      break;
    case "ZXZ":
      n.set(l * d, l * p, a * h, a * u);
      break;
    case "XZX":
      n.set(a * h, l * _, l * m, a * u);
      break;
    case "YXY":
      n.set(l * m, a * h, l * _, a * u);
      break;
    case "ZYZ":
      n.set(l * _, l * m, a * h, a * u);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i
      );
  }
}
function ai(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function vt(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const R2 = {
  DEG2RAD: xl,
  RAD2DEG: Ec,
  generateUUID: ui,
  clamp: gn,
  euclideanModulo: a1,
  mapLinear: iz,
  inverseLerp: sz,
  lerp: rh,
  damp: oz,
  pingpong: az,
  smoothstep: lz,
  smootherstep: uz,
  randInt: cz,
  randFloat: fz,
  randFloatSpread: hz,
  seededRandom: dz,
  degToRad: pz,
  radToDeg: mz,
  isPowerOfTwo: gS,
  ceilPowerOfTwo: b2,
  floorPowerOfTwo: Lg,
  setQuaternionFromProperEuler: gz,
  normalize: vt,
  denormalize: ai,
};
class ge {
  constructor(e = 0, t = 0) {
    (ge.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      r = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * t + i[3] * r + i[6]),
      (this.y = i[1] * t + i[4] * r + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(gn(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r), (this.y = e.y + (t.y - e.y) * r), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t),
      i = Math.sin(t),
      s = this.x - e.x,
      o = this.y - e.y;
    return (this.x = s * r - o * i + e.x), (this.y = s * i + o * r + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class _t {
  constructor(e, t, r, i, s, o, a, l, u) {
    (_t.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i, s, o, a, l, u);
  }
  set(e, t, r, i, s, o, a, l, u) {
    const h = this.elements;
    return (
      (h[0] = e),
      (h[1] = i),
      (h[2] = a),
      (h[3] = t),
      (h[4] = s),
      (h[5] = l),
      (h[6] = r),
      (h[7] = o),
      (h[8] = u),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      r = e.elements;
    return (
      (t[0] = r[0]),
      (t[1] = r[1]),
      (t[2] = r[2]),
      (t[3] = r[3]),
      (t[4] = r[4]),
      (t[5] = r[5]),
      (t[6] = r[6]),
      (t[7] = r[7]),
      (t[8] = r[8]),
      this
    );
  }
  extractBasis(e, t, r) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      r.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements,
      i = t.elements,
      s = this.elements,
      o = r[0],
      a = r[3],
      l = r[6],
      u = r[1],
      h = r[4],
      d = r[7],
      p = r[2],
      m = r[5],
      _ = r[8],
      y = i[0],
      x = i[3],
      g = i[6],
      S = i[1],
      A = i[4],
      E = i[7],
      C = i[2],
      R = i[5],
      P = i[8];
    return (
      (s[0] = o * y + a * S + l * C),
      (s[3] = o * x + a * A + l * R),
      (s[6] = o * g + a * E + l * P),
      (s[1] = u * y + h * S + d * C),
      (s[4] = u * x + h * A + d * R),
      (s[7] = u * g + h * E + d * P),
      (s[2] = p * y + m * S + _ * C),
      (s[5] = p * x + m * A + _ * R),
      (s[8] = p * g + m * E + _ * P),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      u = e[7],
      h = e[8];
    return (
      t * o * h - t * a * u - r * s * h + r * a * l + i * s * u - i * o * l
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      u = e[7],
      h = e[8],
      d = h * o - a * u,
      p = a * l - h * s,
      m = u * s - o * l,
      _ = t * d + r * p + i * m;
    if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const y = 1 / _;
    return (
      (e[0] = d * y),
      (e[1] = (i * u - h * r) * y),
      (e[2] = (a * r - i * o) * y),
      (e[3] = p * y),
      (e[4] = (h * t - i * l) * y),
      (e[5] = (i * s - a * t) * y),
      (e[6] = m * y),
      (e[7] = (r * l - u * t) * y),
      (e[8] = (o * t - r * s) * y),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, r, i, s, o, a) {
    const l = Math.cos(s),
      u = Math.sin(s);
    return (
      this.set(
        r * l,
        r * u,
        -r * (l * o + u * a) + o + e,
        -i * u,
        i * l,
        -i * (-u * o + l * a) + a + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(Dv.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Dv.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Dv.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, -r, 0, r, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      r = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++) this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return (
      (e[t] = r[0]),
      (e[t + 1] = r[1]),
      (e[t + 2] = r[2]),
      (e[t + 3] = r[3]),
      (e[t + 4] = r[4]),
      (e[t + 5] = r[5]),
      (e[t + 6] = r[6]),
      (e[t + 7] = r[7]),
      (e[t + 8] = r[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Dv = new _t();
function P2(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
const _z = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function Ju(n, e) {
  return new _z[n](e);
}
function Nh(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
const _C = {};
function ih(n) {
  n in _C || ((_C[n] = !0), console.warn(n));
}
function oc(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function Fv(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
const vz = new _t().fromArray([
    0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7,
    1e-7, 0.9105199,
  ]),
  yz = new _t().fromArray([
    1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361, 1e-7,
    0, 1.0982735,
  ]);
function xz(n) {
  return n.convertSRGBToLinear().applyMatrix3(yz);
}
function Sz(n) {
  return n.applyMatrix3(vz).convertLinearToSRGB();
}
const Az = { [as]: (n) => n, [ht]: (n) => n.convertSRGBToLinear(), [o1]: xz },
  Mz = { [as]: (n) => n, [ht]: (n) => n.convertLinearToSRGB(), [o1]: Sz },
  wi = {
    enabled: !0,
    get legacyMode() {
      return (
        console.warn(
          "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
        ),
        !this.enabled
      );
    },
    set legacyMode(n) {
      console.warn(
        "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
      ),
        (this.enabled = !n);
    },
    get workingColorSpace() {
      return as;
    },
    set workingColorSpace(n) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function (n, e, t) {
      if (this.enabled === !1 || e === t || !e || !t) return n;
      const r = Az[e],
        i = Mz[t];
      if (r === void 0 || i === void 0)
        throw new Error(
          `Unsupported color space conversion, "${e}" to "${t}".`
        );
      return i(r(n));
    },
    fromWorkingColorSpace: function (n, e) {
      return this.convert(n, this.workingColorSpace, e);
    },
    toWorkingColorSpace: function (n, e) {
      return this.convert(n, e, this.workingColorSpace);
    },
  };
let au;
class l1 {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      au === void 0 && (au = Nh("canvas")),
        (au.width = e.width),
        (au.height = e.height);
      const r = au.getContext("2d");
      e instanceof ImageData
        ? r.putImageData(e, 0, 0)
        : r.drawImage(e, 0, 0, e.width, e.height),
        (t = au);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = Nh("canvas");
      (t.width = e.width), (t.height = e.height);
      const r = t.getContext("2d");
      r.drawImage(e, 0, 0, e.width, e.height);
      const i = r.getImageData(0, 0, e.width, e.height),
        s = i.data;
      for (let o = 0; o < s.length; o++) s[o] = oc(s[o] / 255) * 255;
      return r.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let r = 0; r < t.length; r++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[r] = Math.floor(oc(t[r] / 255) * 255))
          : (t[r] = oc(t[r]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let Ez = 0;
class dl {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: Ez++ }),
      (this.uuid = ui()),
      (this.data = e),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const r = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let s;
      if (Array.isArray(i)) {
        s = [];
        for (let o = 0, a = i.length; o < a; o++)
          i[o].isDataTexture ? s.push(Nv(i[o].image)) : s.push(Nv(i[o]));
      } else s = Nv(i);
      r.url = s;
    }
    return t || (e.images[this.uuid] = r), r;
  }
}
function Nv(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? l1.getDataURL(n)
    : n.data
    ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let wz = 0;
class en extends Mo {
  constructor(
    e = en.DEFAULT_IMAGE,
    t = en.DEFAULT_MAPPING,
    r = er,
    i = er,
    s = sn,
    o = Ns,
    a = Nr,
    l = Bs,
    u = en.DEFAULT_ANISOTROPY,
    h = ha
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: wz++ }),
      (this.uuid = ui()),
      (this.name = ""),
      (this.source = new dl(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = r),
      (this.wrapT = i),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = u),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new ge(0, 0)),
      (this.repeat = new ge(1, 1)),
      (this.center = new ge(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new _t()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      typeof h == "string"
        ? (this.colorSpace = h)
        : (ih(
            "THREE.Texture: Property .encoding has been replaced by .colorSpace."
          ),
          (this.colorSpace = h === fa ? ht : ha)),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const r = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      t || (e.textures[this.uuid] = r),
      r
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== v0) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case xa:
          e.x = e.x - Math.floor(e.x);
          break;
        case er:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Sc:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case xa:
          e.y = e.y - Math.floor(e.y);
          break;
        case er:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Sc:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  get encoding() {
    return (
      ih("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      this.colorSpace === ht ? fa : s1
    );
  }
  set encoding(e) {
    ih("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      (this.colorSpace = e === fa ? ht : ha);
  }
}
en.DEFAULT_IMAGE = null;
en.DEFAULT_MAPPING = v0;
en.DEFAULT_ANISOTROPY = 1;
class Nt {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    (Nt.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = r),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, r, i) {
    return (this.x = e), (this.y = t), (this.z = r), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      s = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * r + o[8] * i + o[12] * s),
      (this.y = o[1] * t + o[5] * r + o[9] * i + o[13] * s),
      (this.z = o[2] * t + o[6] * r + o[10] * i + o[14] * s),
      (this.w = o[3] * t + o[7] * r + o[11] * i + o[15] * s),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, r, i, s;
    const l = e.elements,
      u = l[0],
      h = l[4],
      d = l[8],
      p = l[1],
      m = l[5],
      _ = l[9],
      y = l[2],
      x = l[6],
      g = l[10];
    if (
      Math.abs(h - p) < 0.01 &&
      Math.abs(d - y) < 0.01 &&
      Math.abs(_ - x) < 0.01
    ) {
      if (
        Math.abs(h + p) < 0.1 &&
        Math.abs(d + y) < 0.1 &&
        Math.abs(_ + x) < 0.1 &&
        Math.abs(u + m + g - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const A = (u + 1) / 2,
        E = (m + 1) / 2,
        C = (g + 1) / 2,
        R = (h + p) / 4,
        P = (d + y) / 4,
        L = (_ + x) / 4;
      return (
        A > E && A > C
          ? A < 0.01
            ? ((r = 0), (i = 0.707106781), (s = 0.707106781))
            : ((r = Math.sqrt(A)), (i = R / r), (s = P / r))
          : E > C
          ? E < 0.01
            ? ((r = 0.707106781), (i = 0), (s = 0.707106781))
            : ((i = Math.sqrt(E)), (r = R / i), (s = L / i))
          : C < 0.01
          ? ((r = 0.707106781), (i = 0.707106781), (s = 0))
          : ((s = Math.sqrt(C)), (r = P / s), (i = L / s)),
        this.set(r, i, s, t),
        this
      );
    }
    let S = Math.sqrt(
      (x - _) * (x - _) + (d - y) * (d - y) + (p - h) * (p - h)
    );
    return (
      Math.abs(S) < 0.001 && (S = 1),
      (this.x = (x - _) / S),
      (this.y = (d - y) / S),
      (this.z = (p - h) / S),
      (this.w = Math.acos((u + m + g - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r),
      (this.y = e.y + (t.y - e.y) * r),
      (this.z = e.z + (t.z - e.z) * r),
      (this.w = e.w + (t.w - e.w) * r),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class ls extends Mo {
  constructor(e = 1, t = 1, r = {}) {
    super(),
      (this.isWebGLRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new Nt(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Nt(0, 0, e, t));
    const i = { width: e, height: t, depth: 1 };
    r.encoding !== void 0 &&
      (ih(
        "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (r.colorSpace = r.encoding === fa ? ht : ha)),
      (this.texture = new en(
        i,
        r.mapping,
        r.wrapS,
        r.wrapT,
        r.magFilter,
        r.minFilter,
        r.format,
        r.type,
        r.anisotropy,
        r.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps =
        r.generateMipmaps !== void 0 ? r.generateMipmaps : !1),
      (this.texture.internalFormat =
        r.internalFormat !== void 0 ? r.internalFormat : null),
      (this.texture.minFilter = r.minFilter !== void 0 ? r.minFilter : sn),
      (this.depthBuffer = r.depthBuffer !== void 0 ? r.depthBuffer : !0),
      (this.stencilBuffer = r.stencilBuffer !== void 0 ? r.stencilBuffer : !1),
      (this.depthTexture = r.depthTexture !== void 0 ? r.depthTexture : null),
      (this.samples = r.samples !== void 0 ? r.samples : 0);
  }
  setSize(e, t, r = 1) {
    (this.width !== e || this.height !== t || this.depth !== r) &&
      ((this.width = e),
      (this.height = t),
      (this.depth = r),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = r),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new dl(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class A0 extends en {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: r, depth: i }),
      (this.magFilter = mn),
      (this.minFilter = mn),
      (this.wrapR = er),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Cz extends ls {
  constructor(e = 1, t = 1, r = 1) {
    super(e, t),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = r),
      (this.texture = new A0(null, e, t, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class u1 extends en {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: r, depth: i }),
      (this.magFilter = mn),
      (this.minFilter = mn),
      (this.wrapR = er),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Tz extends ls {
  constructor(e = 1, t = 1, r = 1) {
    super(e, t),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = r),
      (this.texture = new u1(null, e, t, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class bz extends ls {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    super(e, t, i), (this.isWebGLMultipleRenderTargets = !0);
    const s = this.texture;
    this.texture = [];
    for (let o = 0; o < r; o++)
      (this.texture[o] = s.clone()),
        (this.texture[o].isRenderTargetTexture = !0);
  }
  setSize(e, t, r = 1) {
    if (this.width !== e || this.height !== t || this.depth !== r) {
      (this.width = e), (this.height = t), (this.depth = r);
      for (let i = 0, s = this.texture.length; i < s; i++)
        (this.texture[i].image.width = e),
          (this.texture[i].image.height = t),
          (this.texture[i].image.depth = r);
      this.dispose();
    }
    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
  }
  copy(e) {
    this.dispose(),
      (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.texture.length = 0);
    for (let t = 0, r = e.texture.length; t < r; t++)
      (this.texture[t] = e.texture[t].clone()),
        (this.texture[t].isRenderTargetTexture = !0);
    return this;
  }
}
class mr {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._w = i);
  }
  static slerpFlat(e, t, r, i, s, o, a) {
    let l = r[i + 0],
      u = r[i + 1],
      h = r[i + 2],
      d = r[i + 3];
    const p = s[o + 0],
      m = s[o + 1],
      _ = s[o + 2],
      y = s[o + 3];
    if (a === 0) {
      (e[t + 0] = l), (e[t + 1] = u), (e[t + 2] = h), (e[t + 3] = d);
      return;
    }
    if (a === 1) {
      (e[t + 0] = p), (e[t + 1] = m), (e[t + 2] = _), (e[t + 3] = y);
      return;
    }
    if (d !== y || l !== p || u !== m || h !== _) {
      let x = 1 - a;
      const g = l * p + u * m + h * _ + d * y,
        S = g >= 0 ? 1 : -1,
        A = 1 - g * g;
      if (A > Number.EPSILON) {
        const C = Math.sqrt(A),
          R = Math.atan2(C, g * S);
        (x = Math.sin(x * R) / C), (a = Math.sin(a * R) / C);
      }
      const E = a * S;
      if (
        ((l = l * x + p * E),
        (u = u * x + m * E),
        (h = h * x + _ * E),
        (d = d * x + y * E),
        x === 1 - a)
      ) {
        const C = 1 / Math.sqrt(l * l + u * u + h * h + d * d);
        (l *= C), (u *= C), (h *= C), (d *= C);
      }
    }
    (e[t] = l), (e[t + 1] = u), (e[t + 2] = h), (e[t + 3] = d);
  }
  static multiplyQuaternionsFlat(e, t, r, i, s, o) {
    const a = r[i],
      l = r[i + 1],
      u = r[i + 2],
      h = r[i + 3],
      d = s[o],
      p = s[o + 1],
      m = s[o + 2],
      _ = s[o + 3];
    return (
      (e[t] = a * _ + h * d + l * m - u * p),
      (e[t + 1] = l * _ + h * p + u * d - a * m),
      (e[t + 2] = u * _ + h * m + a * p - l * d),
      (e[t + 3] = h * _ - a * d - l * p - u * m),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, r, i) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t) {
    const r = e._x,
      i = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      l = Math.sin,
      u = a(r / 2),
      h = a(i / 2),
      d = a(s / 2),
      p = l(r / 2),
      m = l(i / 2),
      _ = l(s / 2);
    switch (o) {
      case "XYZ":
        (this._x = p * h * d + u * m * _),
          (this._y = u * m * d - p * h * _),
          (this._z = u * h * _ + p * m * d),
          (this._w = u * h * d - p * m * _);
        break;
      case "YXZ":
        (this._x = p * h * d + u * m * _),
          (this._y = u * m * d - p * h * _),
          (this._z = u * h * _ - p * m * d),
          (this._w = u * h * d + p * m * _);
        break;
      case "ZXY":
        (this._x = p * h * d - u * m * _),
          (this._y = u * m * d + p * h * _),
          (this._z = u * h * _ + p * m * d),
          (this._w = u * h * d - p * m * _);
        break;
      case "ZYX":
        (this._x = p * h * d - u * m * _),
          (this._y = u * m * d + p * h * _),
          (this._z = u * h * _ - p * m * d),
          (this._w = u * h * d + p * m * _);
        break;
      case "YZX":
        (this._x = p * h * d + u * m * _),
          (this._y = u * m * d + p * h * _),
          (this._z = u * h * _ - p * m * d),
          (this._w = u * h * d - p * m * _);
        break;
      case "XZY":
        (this._x = p * h * d - u * m * _),
          (this._y = u * m * d - p * h * _),
          (this._z = u * h * _ + p * m * d),
          (this._w = u * h * d + p * m * _);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o
        );
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2,
      i = Math.sin(r);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(r)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      r = t[0],
      i = t[4],
      s = t[8],
      o = t[1],
      a = t[5],
      l = t[9],
      u = t[2],
      h = t[6],
      d = t[10],
      p = r + a + d;
    if (p > 0) {
      const m = 0.5 / Math.sqrt(p + 1);
      (this._w = 0.25 / m),
        (this._x = (h - l) * m),
        (this._y = (s - u) * m),
        (this._z = (o - i) * m);
    } else if (r > a && r > d) {
      const m = 2 * Math.sqrt(1 + r - a - d);
      (this._w = (h - l) / m),
        (this._x = 0.25 * m),
        (this._y = (i + o) / m),
        (this._z = (s + u) / m);
    } else if (a > d) {
      const m = 2 * Math.sqrt(1 + a - r - d);
      (this._w = (s - u) / m),
        (this._x = (i + o) / m),
        (this._y = 0.25 * m),
        (this._z = (l + h) / m);
    } else {
      const m = 2 * Math.sqrt(1 + d - r - a);
      (this._w = (o - i) / m),
        (this._x = (s + u) / m),
        (this._y = (l + h) / m),
        (this._z = 0.25 * m);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return (
      r < Number.EPSILON
        ? ((r = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = r))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = r)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = r)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(gn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0) return this;
    const i = Math.min(1, t / r);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x,
      i = e._y,
      s = e._z,
      o = e._w,
      a = t._x,
      l = t._y,
      u = t._z,
      h = t._w;
    return (
      (this._x = r * h + o * a + i * u - s * l),
      (this._y = i * h + o * l + s * a - r * u),
      (this._z = s * h + o * u + r * l - i * a),
      (this._w = o * h - r * a - i * l - s * u),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const r = this._x,
      i = this._y,
      s = this._z,
      o = this._w;
    let a = o * e._w + r * e._x + i * e._y + s * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = o), (this._x = r), (this._y = i), (this._z = s), this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const m = 1 - t;
      return (
        (this._w = m * o + t * this._w),
        (this._x = m * r + t * this._x),
        (this._y = m * i + t * this._y),
        (this._z = m * s + t * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const u = Math.sqrt(l),
      h = Math.atan2(u, a),
      d = Math.sin((1 - t) * h) / u,
      p = Math.sin(t * h) / u;
    return (
      (this._w = o * d + this._w * p),
      (this._x = r * d + this._x * p),
      (this._y = i * d + this._y * p),
      (this._z = s * d + this._z * p),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      r = Math.sqrt(e),
      i = 2 * Math.PI * Math.random(),
      s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(i),
      r * Math.sin(s),
      r * Math.cos(s),
      t * Math.sin(i)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class U {
  constructor(e = 0, t = 0, r = 0) {
    (U.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = r);
  }
  set(e, t, r) {
    return (
      r === void 0 && (r = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = r),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(vC.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(vC.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * r + s[6] * i),
      (this.y = s[1] * t + s[4] * r + s[7] * i),
      (this.z = s[2] * t + s[5] * r + s[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      s = e.elements,
      o = 1 / (s[3] * t + s[7] * r + s[11] * i + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * r + s[8] * i + s[12]) * o),
      (this.y = (s[1] * t + s[5] * r + s[9] * i + s[13]) * o),
      (this.z = (s[2] * t + s[6] * r + s[10] * i + s[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      l = e.w,
      u = l * t + o * i - a * r,
      h = l * r + a * t - s * i,
      d = l * i + s * r - o * t,
      p = -s * t - o * r - a * i;
    return (
      (this.x = u * l + p * -s + h * -a - d * -o),
      (this.y = h * l + p * -o + d * -s - u * -a),
      (this.z = d * l + p * -a + u * -o - h * -s),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * r + s[8] * i),
      (this.y = s[1] * t + s[5] * r + s[9] * i),
      (this.z = s[2] * t + s[6] * r + s[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r),
      (this.y = e.y + (t.y - e.y) * r),
      (this.z = e.z + (t.z - e.z) * r),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x,
      i = e.y,
      s = e.z,
      o = t.x,
      a = t.y,
      l = t.z;
    return (
      (this.x = i * l - s * a),
      (this.y = s * o - r * l),
      (this.z = r * a - i * o),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return Ov.copy(this).projectOnVector(e), this.sub(Ov);
  }
  reflect(e) {
    return this.sub(Ov.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(gn(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      r = this.y - e.y,
      i = this.z - e.z;
    return t * t + r * r + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const i = Math.sin(t) * e;
    return (
      (this.x = i * Math.sin(r)),
      (this.y = Math.cos(t) * e),
      (this.z = i * Math.cos(r)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return (
      (this.x = e * Math.sin(t)), (this.y = r), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      r = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = r), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      t = Math.random() * Math.PI * 2,
      r = Math.sqrt(1 - e ** 2);
    return (
      (this.x = r * Math.cos(t)), (this.y = r * Math.sin(t)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Ov = new U(),
  vC = new mr();
class us {
  constructor(
    e = new U(1 / 0, 1 / 0, 1 / 0),
    t = new U(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t += 3)
      this.expandByPoint(Ks.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, r = e.count; t < r; t++)
      this.expandByPoint(Ks.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = Ks.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    if ((e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0))
      e.boundingBox === null && e.computeBoundingBox(),
        lu.copy(e.boundingBox),
        lu.applyMatrix4(e.matrixWorld),
        this.union(lu);
    else {
      const i = e.geometry;
      if (i !== void 0)
        if (t && i.attributes !== void 0 && i.attributes.position !== void 0) {
          const s = i.attributes.position;
          for (let o = 0, a = s.count; o < a; o++)
            Ks.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld),
              this.expandByPoint(Ks);
        } else
          i.boundingBox === null && i.computeBoundingBox(),
            lu.copy(i.boundingBox),
            lu.applyMatrix4(e.matrixWorld),
            this.union(lu);
    }
    const r = e.children;
    for (let i = 0, s = r.length; i < s; i++) this.expandByObject(r[i], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Ks),
      Ks.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, r;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (r = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (r = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (r += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (r += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (r += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (r += e.normal.z * this.min.z)),
      t <= -e.constant && r >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Mf),
      Fp.subVectors(this.max, Mf),
      uu.subVectors(e.a, Mf),
      cu.subVectors(e.b, Mf),
      fu.subVectors(e.c, Mf),
      No.subVectors(cu, uu),
      Oo.subVectors(fu, cu),
      Ga.subVectors(uu, fu);
    let t = [
      0,
      -No.z,
      No.y,
      0,
      -Oo.z,
      Oo.y,
      0,
      -Ga.z,
      Ga.y,
      No.z,
      0,
      -No.x,
      Oo.z,
      0,
      -Oo.x,
      Ga.z,
      0,
      -Ga.x,
      -No.y,
      No.x,
      0,
      -Oo.y,
      Oo.x,
      0,
      -Ga.y,
      Ga.x,
      0,
    ];
    return !Uv(t, uu, cu, fu, Fp) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Uv(t, uu, cu, fu, Fp))
      ? !1
      : (Np.crossVectors(No, Oo),
        (t = [Np.x, Np.y, Np.z]),
        Uv(t, uu, cu, fu, Fp));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Ks).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Ks).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Js[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Js[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Js[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Js[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Js[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Js[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Js[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Js[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Js),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Js = [
    new U(),
    new U(),
    new U(),
    new U(),
    new U(),
    new U(),
    new U(),
    new U(),
  ],
  Ks = new U(),
  lu = new us(),
  uu = new U(),
  cu = new U(),
  fu = new U(),
  No = new U(),
  Oo = new U(),
  Ga = new U(),
  Mf = new U(),
  Fp = new U(),
  Np = new U(),
  Va = new U();
function Uv(n, e, t, r, i) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    Va.fromArray(n, s);
    const a =
        i.x * Math.abs(Va.x) + i.y * Math.abs(Va.y) + i.z * Math.abs(Va.z),
      l = e.dot(Va),
      u = t.dot(Va),
      h = r.dot(Va);
    if (Math.max(-Math.max(l, u, h), Math.min(l, u, h)) > a) return !1;
  }
  return !0;
}
const Rz = new us(),
  Ef = new U(),
  kv = new U();
class Gi {
  constructor(e = new U(), t = -1) {
    (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : Rz.setFromPoints(e).getCenter(r);
    let i = 0;
    for (let s = 0, o = e.length; s < o; s++)
      i = Math.max(i, r.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      r > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    Ef.subVectors(e, this.center);
    const t = Ef.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t),
        i = (r - this.radius) * 0.5;
      this.center.addScaledVector(Ef, i / r), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (kv.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(Ef.copy(e.center).add(kv)),
            this.expandByPoint(Ef.copy(e.center).sub(kv))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ys = new U(),
  zv = new U(),
  Op = new U(),
  Uo = new U(),
  Hv = new U(),
  Up = new U(),
  Gv = new U();
class Vc {
  constructor(e = new U(), t = new U(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Ys)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const r = t.dot(this.direction);
    return r < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, r);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Ys.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Ys.copy(this.origin).addScaledVector(this.direction, t),
        Ys.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, r, i) {
    zv.copy(e).add(t).multiplyScalar(0.5),
      Op.copy(t).sub(e).normalize(),
      Uo.copy(this.origin).sub(zv);
    const s = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(Op),
      a = Uo.dot(this.direction),
      l = -Uo.dot(Op),
      u = Uo.lengthSq(),
      h = Math.abs(1 - o * o);
    let d, p, m, _;
    if (h > 0)
      if (((d = o * l - a), (p = o * a - l), (_ = s * h), d >= 0))
        if (p >= -_)
          if (p <= _) {
            const y = 1 / h;
            (d *= y),
              (p *= y),
              (m = d * (d + o * p + 2 * a) + p * (o * d + p + 2 * l) + u);
          } else
            (p = s),
              (d = Math.max(0, -(o * p + a))),
              (m = -d * d + p * (p + 2 * l) + u);
        else
          (p = -s),
            (d = Math.max(0, -(o * p + a))),
            (m = -d * d + p * (p + 2 * l) + u);
      else
        p <= -_
          ? ((d = Math.max(0, -(-o * s + a))),
            (p = d > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (m = -d * d + p * (p + 2 * l) + u))
          : p <= _
          ? ((d = 0),
            (p = Math.min(Math.max(-s, -l), s)),
            (m = p * (p + 2 * l) + u))
          : ((d = Math.max(0, -(o * s + a))),
            (p = d > 0 ? s : Math.min(Math.max(-s, -l), s)),
            (m = -d * d + p * (p + 2 * l) + u));
    else
      (p = o > 0 ? -s : s),
        (d = Math.max(0, -(o * p + a))),
        (m = -d * d + p * (p + 2 * l) + u);
    return (
      r && r.copy(this.origin).addScaledVector(this.direction, d),
      i && i.copy(zv).addScaledVector(Op, p),
      m
    );
  }
  intersectSphere(e, t) {
    Ys.subVectors(e.center, this.origin);
    const r = Ys.dot(this.direction),
      i = Ys.dot(Ys) - r * r,
      s = e.radius * e.radius;
    if (i > s) return null;
    const o = Math.sqrt(s - i),
      a = r - o,
      l = r + o;
    return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / t;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, t) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let r, i, s, o, a, l;
    const u = 1 / this.direction.x,
      h = 1 / this.direction.y,
      d = 1 / this.direction.z,
      p = this.origin;
    return (
      u >= 0
        ? ((r = (e.min.x - p.x) * u), (i = (e.max.x - p.x) * u))
        : ((r = (e.max.x - p.x) * u), (i = (e.min.x - p.x) * u)),
      h >= 0
        ? ((s = (e.min.y - p.y) * h), (o = (e.max.y - p.y) * h))
        : ((s = (e.max.y - p.y) * h), (o = (e.min.y - p.y) * h)),
      r > o ||
      s > i ||
      ((s > r || isNaN(r)) && (r = s),
      (o < i || isNaN(i)) && (i = o),
      d >= 0
        ? ((a = (e.min.z - p.z) * d), (l = (e.max.z - p.z) * d))
        : ((a = (e.max.z - p.z) * d), (l = (e.min.z - p.z) * d)),
      r > l || a > i) ||
      ((a > r || r !== r) && (r = a), (l < i || i !== i) && (i = l), i < 0)
        ? null
        : this.at(r >= 0 ? r : i, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Ys) !== null;
  }
  intersectTriangle(e, t, r, i, s) {
    Hv.subVectors(t, e), Up.subVectors(r, e), Gv.crossVectors(Hv, Up);
    let o = this.direction.dot(Gv),
      a;
    if (o > 0) {
      if (i) return null;
      a = 1;
    } else if (o < 0) (a = -1), (o = -o);
    else return null;
    Uo.subVectors(this.origin, e);
    const l = a * this.direction.dot(Up.crossVectors(Uo, Up));
    if (l < 0) return null;
    const u = a * this.direction.dot(Hv.cross(Uo));
    if (u < 0 || l + u > o) return null;
    const h = -a * Uo.dot(Gv);
    return h < 0 ? null : this.at(h / o, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class rt {
  constructor(e, t, r, i, s, o, a, l, u, h, d, p, m, _, y, x) {
    (rt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i, s, o, a, l, u, h, d, p, m, _, y, x);
  }
  set(e, t, r, i, s, o, a, l, u, h, d, p, m, _, y, x) {
    const g = this.elements;
    return (
      (g[0] = e),
      (g[4] = t),
      (g[8] = r),
      (g[12] = i),
      (g[1] = s),
      (g[5] = o),
      (g[9] = a),
      (g[13] = l),
      (g[2] = u),
      (g[6] = h),
      (g[10] = d),
      (g[14] = p),
      (g[3] = m),
      (g[7] = _),
      (g[11] = y),
      (g[15] = x),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new rt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      r = e.elements;
    return (
      (t[0] = r[0]),
      (t[1] = r[1]),
      (t[2] = r[2]),
      (t[3] = r[3]),
      (t[4] = r[4]),
      (t[5] = r[5]),
      (t[6] = r[6]),
      (t[7] = r[7]),
      (t[8] = r[8]),
      (t[9] = r[9]),
      (t[10] = r[10]),
      (t[11] = r[11]),
      (t[12] = r[12]),
      (t[13] = r[13]),
      (t[14] = r[14]),
      (t[15] = r[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      r = e.elements;
    return (t[12] = r[12]), (t[13] = r[13]), (t[14] = r[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, r) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      r.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, r) {
    return (
      this.set(
        e.x,
        t.x,
        r.x,
        0,
        e.y,
        t.y,
        r.y,
        0,
        e.z,
        t.z,
        r.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      r = e.elements,
      i = 1 / hu.setFromMatrixColumn(e, 0).length(),
      s = 1 / hu.setFromMatrixColumn(e, 1).length(),
      o = 1 / hu.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = r[0] * i),
      (t[1] = r[1] * i),
      (t[2] = r[2] * i),
      (t[3] = 0),
      (t[4] = r[4] * s),
      (t[5] = r[5] * s),
      (t[6] = r[6] * s),
      (t[7] = 0),
      (t[8] = r[8] * o),
      (t[9] = r[9] * o),
      (t[10] = r[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      r = e.x,
      i = e.y,
      s = e.z,
      o = Math.cos(r),
      a = Math.sin(r),
      l = Math.cos(i),
      u = Math.sin(i),
      h = Math.cos(s),
      d = Math.sin(s);
    if (e.order === "XYZ") {
      const p = o * h,
        m = o * d,
        _ = a * h,
        y = a * d;
      (t[0] = l * h),
        (t[4] = -l * d),
        (t[8] = u),
        (t[1] = m + _ * u),
        (t[5] = p - y * u),
        (t[9] = -a * l),
        (t[2] = y - p * u),
        (t[6] = _ + m * u),
        (t[10] = o * l);
    } else if (e.order === "YXZ") {
      const p = l * h,
        m = l * d,
        _ = u * h,
        y = u * d;
      (t[0] = p + y * a),
        (t[4] = _ * a - m),
        (t[8] = o * u),
        (t[1] = o * d),
        (t[5] = o * h),
        (t[9] = -a),
        (t[2] = m * a - _),
        (t[6] = y + p * a),
        (t[10] = o * l);
    } else if (e.order === "ZXY") {
      const p = l * h,
        m = l * d,
        _ = u * h,
        y = u * d;
      (t[0] = p - y * a),
        (t[4] = -o * d),
        (t[8] = _ + m * a),
        (t[1] = m + _ * a),
        (t[5] = o * h),
        (t[9] = y - p * a),
        (t[2] = -o * u),
        (t[6] = a),
        (t[10] = o * l);
    } else if (e.order === "ZYX") {
      const p = o * h,
        m = o * d,
        _ = a * h,
        y = a * d;
      (t[0] = l * h),
        (t[4] = _ * u - m),
        (t[8] = p * u + y),
        (t[1] = l * d),
        (t[5] = y * u + p),
        (t[9] = m * u - _),
        (t[2] = -u),
        (t[6] = a * l),
        (t[10] = o * l);
    } else if (e.order === "YZX") {
      const p = o * l,
        m = o * u,
        _ = a * l,
        y = a * u;
      (t[0] = l * h),
        (t[4] = y - p * d),
        (t[8] = _ * d + m),
        (t[1] = d),
        (t[5] = o * h),
        (t[9] = -a * h),
        (t[2] = -u * h),
        (t[6] = m * d + _),
        (t[10] = p - y * d);
    } else if (e.order === "XZY") {
      const p = o * l,
        m = o * u,
        _ = a * l,
        y = a * u;
      (t[0] = l * h),
        (t[4] = -d),
        (t[8] = u * h),
        (t[1] = p * d + y),
        (t[5] = o * h),
        (t[9] = m * d - _),
        (t[2] = _ * d - m),
        (t[6] = a * h),
        (t[10] = y * d + p);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Pz, e, Bz);
  }
  lookAt(e, t, r) {
    const i = this.elements;
    return (
      ti.subVectors(e, t),
      ti.lengthSq() === 0 && (ti.z = 1),
      ti.normalize(),
      ko.crossVectors(r, ti),
      ko.lengthSq() === 0 &&
        (Math.abs(r.z) === 1 ? (ti.x += 1e-4) : (ti.z += 1e-4),
        ti.normalize(),
        ko.crossVectors(r, ti)),
      ko.normalize(),
      kp.crossVectors(ti, ko),
      (i[0] = ko.x),
      (i[4] = kp.x),
      (i[8] = ti.x),
      (i[1] = ko.y),
      (i[5] = kp.y),
      (i[9] = ti.y),
      (i[2] = ko.z),
      (i[6] = kp.z),
      (i[10] = ti.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements,
      i = t.elements,
      s = this.elements,
      o = r[0],
      a = r[4],
      l = r[8],
      u = r[12],
      h = r[1],
      d = r[5],
      p = r[9],
      m = r[13],
      _ = r[2],
      y = r[6],
      x = r[10],
      g = r[14],
      S = r[3],
      A = r[7],
      E = r[11],
      C = r[15],
      R = i[0],
      P = i[4],
      L = i[8],
      T = i[12],
      B = i[1],
      D = i[5],
      I = i[9],
      F = i[13],
      k = i[2],
      j = i[6],
      Z = i[10],
      Q = i[14],
      N = i[3],
      W = i[7],
      G = i[11],
      X = i[15];
    return (
      (s[0] = o * R + a * B + l * k + u * N),
      (s[4] = o * P + a * D + l * j + u * W),
      (s[8] = o * L + a * I + l * Z + u * G),
      (s[12] = o * T + a * F + l * Q + u * X),
      (s[1] = h * R + d * B + p * k + m * N),
      (s[5] = h * P + d * D + p * j + m * W),
      (s[9] = h * L + d * I + p * Z + m * G),
      (s[13] = h * T + d * F + p * Q + m * X),
      (s[2] = _ * R + y * B + x * k + g * N),
      (s[6] = _ * P + y * D + x * j + g * W),
      (s[10] = _ * L + y * I + x * Z + g * G),
      (s[14] = _ * T + y * F + x * Q + g * X),
      (s[3] = S * R + A * B + E * k + C * N),
      (s[7] = S * P + A * D + E * j + C * W),
      (s[11] = S * L + A * I + E * Z + C * G),
      (s[15] = S * T + A * F + E * Q + C * X),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      r = e[4],
      i = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      l = e[9],
      u = e[13],
      h = e[2],
      d = e[6],
      p = e[10],
      m = e[14],
      _ = e[3],
      y = e[7],
      x = e[11],
      g = e[15];
    return (
      _ *
        (+s * l * d -
          i * u * d -
          s * a * p +
          r * u * p +
          i * a * m -
          r * l * m) +
      y *
        (+t * l * m -
          t * u * p +
          s * o * p -
          i * o * m +
          i * u * h -
          s * l * h) +
      x *
        (+t * u * d -
          t * a * m -
          s * o * d +
          r * o * m +
          s * a * h -
          r * u * h) +
      g *
        (-i * a * h - t * l * d + t * a * p + i * o * d - r * o * p + r * l * h)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, r) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = r)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      u = e[7],
      h = e[8],
      d = e[9],
      p = e[10],
      m = e[11],
      _ = e[12],
      y = e[13],
      x = e[14],
      g = e[15],
      S = d * x * u - y * p * u + y * l * m - a * x * m - d * l * g + a * p * g,
      A = _ * p * u - h * x * u - _ * l * m + o * x * m + h * l * g - o * p * g,
      E = h * y * u - _ * d * u + _ * a * m - o * y * m - h * a * g + o * d * g,
      C = _ * d * l - h * y * l - _ * a * p + o * y * p + h * a * x - o * d * x,
      R = t * S + r * A + i * E + s * C;
    if (R === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const P = 1 / R;
    return (
      (e[0] = S * P),
      (e[1] =
        (y * p * s -
          d * x * s -
          y * i * m +
          r * x * m +
          d * i * g -
          r * p * g) *
        P),
      (e[2] =
        (a * x * s -
          y * l * s +
          y * i * u -
          r * x * u -
          a * i * g +
          r * l * g) *
        P),
      (e[3] =
        (d * l * s -
          a * p * s -
          d * i * u +
          r * p * u +
          a * i * m -
          r * l * m) *
        P),
      (e[4] = A * P),
      (e[5] =
        (h * x * s -
          _ * p * s +
          _ * i * m -
          t * x * m -
          h * i * g +
          t * p * g) *
        P),
      (e[6] =
        (_ * l * s -
          o * x * s -
          _ * i * u +
          t * x * u +
          o * i * g -
          t * l * g) *
        P),
      (e[7] =
        (o * p * s -
          h * l * s +
          h * i * u -
          t * p * u -
          o * i * m +
          t * l * m) *
        P),
      (e[8] = E * P),
      (e[9] =
        (_ * d * s -
          h * y * s -
          _ * r * m +
          t * y * m +
          h * r * g -
          t * d * g) *
        P),
      (e[10] =
        (o * y * s -
          _ * a * s +
          _ * r * u -
          t * y * u -
          o * r * g +
          t * a * g) *
        P),
      (e[11] =
        (h * a * s -
          o * d * s -
          h * r * u +
          t * d * u +
          o * r * m -
          t * a * m) *
        P),
      (e[12] = C * P),
      (e[13] =
        (h * y * i -
          _ * d * i +
          _ * r * p -
          t * y * p -
          h * r * x +
          t * d * x) *
        P),
      (e[14] =
        (_ * a * i -
          o * y * i -
          _ * r * l +
          t * y * l +
          o * r * x -
          t * a * x) *
        P),
      (e[15] =
        (o * d * i -
          h * a * i +
          h * r * l -
          t * d * l -
          o * r * p +
          t * a * p) *
        P),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      r = e.x,
      i = e.y,
      s = e.z;
    return (
      (t[0] *= r),
      (t[4] *= i),
      (t[8] *= s),
      (t[1] *= r),
      (t[5] *= i),
      (t[9] *= s),
      (t[2] *= r),
      (t[6] *= i),
      (t[10] *= s),
      (t[3] *= r),
      (t[7] *= i),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, i));
  }
  makeTranslation(e, t, r) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t),
      i = Math.sin(t),
      s = 1 - r,
      o = e.x,
      a = e.y,
      l = e.z,
      u = s * o,
      h = s * a;
    return (
      this.set(
        u * o + r,
        u * a - i * l,
        u * l + i * a,
        0,
        u * a + i * l,
        h * a + r,
        h * l - i * o,
        0,
        u * l - i * a,
        h * l + i * o,
        s * l * l + r,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, r) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, r, i, s, o) {
    return this.set(1, r, s, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, r) {
    const i = this.elements,
      s = t._x,
      o = t._y,
      a = t._z,
      l = t._w,
      u = s + s,
      h = o + o,
      d = a + a,
      p = s * u,
      m = s * h,
      _ = s * d,
      y = o * h,
      x = o * d,
      g = a * d,
      S = l * u,
      A = l * h,
      E = l * d,
      C = r.x,
      R = r.y,
      P = r.z;
    return (
      (i[0] = (1 - (y + g)) * C),
      (i[1] = (m + E) * C),
      (i[2] = (_ - A) * C),
      (i[3] = 0),
      (i[4] = (m - E) * R),
      (i[5] = (1 - (p + g)) * R),
      (i[6] = (x + S) * R),
      (i[7] = 0),
      (i[8] = (_ + A) * P),
      (i[9] = (x - S) * P),
      (i[10] = (1 - (p + y)) * P),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, r) {
    const i = this.elements;
    let s = hu.set(i[0], i[1], i[2]).length();
    const o = hu.set(i[4], i[5], i[6]).length(),
      a = hu.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      Ki.copy(this);
    const u = 1 / s,
      h = 1 / o,
      d = 1 / a;
    return (
      (Ki.elements[0] *= u),
      (Ki.elements[1] *= u),
      (Ki.elements[2] *= u),
      (Ki.elements[4] *= h),
      (Ki.elements[5] *= h),
      (Ki.elements[6] *= h),
      (Ki.elements[8] *= d),
      (Ki.elements[9] *= d),
      (Ki.elements[10] *= d),
      t.setFromRotationMatrix(Ki),
      (r.x = s),
      (r.y = o),
      (r.z = a),
      this
    );
  }
  makePerspective(e, t, r, i, s, o, a = Ts) {
    const l = this.elements,
      u = (2 * s) / (t - e),
      h = (2 * s) / (r - i),
      d = (t + e) / (t - e),
      p = (r + i) / (r - i);
    let m, _;
    if (a === Ts) (m = -(o + s) / (o - s)), (_ = (-2 * o * s) / (o - s));
    else if (a === Fh) (m = -o / (o - s)), (_ = (-o * s) / (o - s));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = u),
      (l[4] = 0),
      (l[8] = d),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = h),
      (l[9] = p),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = m),
      (l[14] = _),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, r, i, s, o, a = Ts) {
    const l = this.elements,
      u = 1 / (t - e),
      h = 1 / (r - i),
      d = 1 / (o - s),
      p = (t + e) * u,
      m = (r + i) * h;
    let _, y;
    if (a === Ts) (_ = (o + s) * d), (y = -2 * d);
    else if (a === Fh) (_ = s * d), (y = -1 * d);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = 2 * u),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -p),
      (l[1] = 0),
      (l[5] = 2 * h),
      (l[9] = 0),
      (l[13] = -m),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = y),
      (l[14] = -_),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      r = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++) this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return (
      (e[t] = r[0]),
      (e[t + 1] = r[1]),
      (e[t + 2] = r[2]),
      (e[t + 3] = r[3]),
      (e[t + 4] = r[4]),
      (e[t + 5] = r[5]),
      (e[t + 6] = r[6]),
      (e[t + 7] = r[7]),
      (e[t + 8] = r[8]),
      (e[t + 9] = r[9]),
      (e[t + 10] = r[10]),
      (e[t + 11] = r[11]),
      (e[t + 12] = r[12]),
      (e[t + 13] = r[13]),
      (e[t + 14] = r[14]),
      (e[t + 15] = r[15]),
      e
    );
  }
}
const hu = new U(),
  Ki = new rt(),
  Pz = new U(0, 0, 0),
  Bz = new U(1, 1, 1),
  ko = new U(),
  kp = new U(),
  ti = new U(),
  yC = new rt(),
  xC = new mr();
class ad {
  constructor(e = 0, t = 0, r = 0, i = ad.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, r, i = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const i = e.elements,
      s = i[0],
      o = i[4],
      a = i[8],
      l = i[1],
      u = i[5],
      h = i[9],
      d = i[2],
      p = i[6],
      m = i[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(gn(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-h, m)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(p, u)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-gn(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(a, m)), (this._z = Math.atan2(l, u)))
            : ((this._y = Math.atan2(-d, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(gn(p, -1, 1))),
          Math.abs(p) < 0.9999999
            ? ((this._y = Math.atan2(-d, m)), (this._z = Math.atan2(-o, u)))
            : ((this._y = 0), (this._z = Math.atan2(l, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-gn(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._x = Math.atan2(p, m)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, u)));
        break;
      case "YZX":
        (this._z = Math.asin(gn(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-h, u)), (this._y = Math.atan2(-d, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, m)));
        break;
      case "XZY":
        (this._z = Math.asin(-gn(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(p, u)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-h, m)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return (
      yC.makeRotationFromQuaternion(e), this.setFromRotationMatrix(yC, t, r)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return xC.setFromEuler(this), this.setFromQuaternion(xC, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
ad.DEFAULT_ORDER = "XYZ";
class Sl {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let Lz = 0;
const SC = new U(),
  du = new mr(),
  Qs = new rt(),
  zp = new U(),
  wf = new U(),
  Iz = new U(),
  Dz = new mr(),
  AC = new U(1, 0, 0),
  MC = new U(0, 1, 0),
  EC = new U(0, 0, 1),
  Fz = { type: "added" },
  wC = { type: "removed" };
class bt extends Mo {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: Lz++ }),
      (this.uuid = ui()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = bt.DEFAULT_UP.clone());
    const e = new U(),
      t = new ad(),
      r = new mr(),
      i = new U(1, 1, 1);
    function s() {
      r.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(s),
      r._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: r },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new rt() },
        normalMatrix: { value: new _t() },
      }),
      (this.matrix = new rt()),
      (this.matrixWorld = new rt()),
      (this.matrixAutoUpdate = bt.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = bt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.layers = new Sl()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return du.setFromAxisAngle(e, t), this.quaternion.multiply(du), this;
  }
  rotateOnWorldAxis(e, t) {
    return du.setFromAxisAngle(e, t), this.quaternion.premultiply(du), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(AC, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(MC, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(EC, e);
  }
  translateOnAxis(e, t) {
    return (
      SC.copy(e).applyQuaternion(this.quaternion),
      this.position.add(SC.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(AC, e);
  }
  translateY(e) {
    return this.translateOnAxis(MC, e);
  }
  translateZ(e) {
    return this.translateOnAxis(EC, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Qs.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, r) {
    e.isVector3 ? zp.copy(e) : zp.set(e, t, r);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      wf.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Qs.lookAt(wf, zp, this.up)
        : Qs.lookAt(zp, wf, this.up),
      this.quaternion.setFromRotationMatrix(Qs),
      i &&
        (Qs.extractRotation(i.matrixWorld),
        du.setFromRotationMatrix(Qs),
        this.quaternion.premultiply(du.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(Fz))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++) this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(wC)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      (t.parent = null), t.dispatchEvent(wC);
    }
    return (this.children.length = 0), this;
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Qs.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Qs.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Qs),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let r = 0, i = this.children.length; r < i; r++) {
      const o = this.children[r].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t) {
    let r = [];
    this[e] === t && r.push(this);
    for (let i = 0, s = this.children.length; i < s; i++) {
      const o = this.children[i].getObjectsByProperty(e, t);
      o.length > 0 && (r = r.concat(o));
    }
    return r;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(wf, e, Iz), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(wf, Dz, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) {
      const s = t[r];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (
      (e === !0 &&
        r !== null &&
        r.matrixWorldAutoUpdate === !0 &&
        r.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      t === !0)
    ) {
      const i = this.children;
      for (let s = 0, o = i.length; s < o; s++) {
        const a = i[s];
        a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      r = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (r.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON()));
    function s(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let u = 0, h = l.length; u < h; u++) {
            const d = l[u];
            s(e.shapes, d);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, u = this.material.length; l < u; l++)
          a.push(s(e.materials, this.material[l]));
        i.material = a;
      } else i.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let a = 0; a < this.children.length; a++)
        i.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        i.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries),
        l = o(e.materials),
        u = o(e.textures),
        h = o(e.images),
        d = o(e.shapes),
        p = o(e.skeletons),
        m = o(e.animations),
        _ = o(e.nodes);
      a.length > 0 && (r.geometries = a),
        l.length > 0 && (r.materials = l),
        u.length > 0 && (r.textures = u),
        h.length > 0 && (r.images = h),
        d.length > 0 && (r.shapes = d),
        p.length > 0 && (r.skeletons = p),
        m.length > 0 && (r.animations = m),
        _.length > 0 && (r.nodes = _);
    }
    return (r.object = i), r;
    function o(a) {
      const l = [];
      for (const u in a) {
        const h = a[u];
        delete h.metadata, l.push(h);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let r = 0; r < e.children.length; r++) {
        const i = e.children[r];
        this.add(i.clone());
      }
    return this;
  }
}
bt.DEFAULT_UP = new U(0, 1, 0);
bt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
bt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Yi = new U(),
  qs = new U(),
  Vv = new U(),
  Zs = new U(),
  pu = new U(),
  mu = new U(),
  CC = new U(),
  Wv = new U(),
  jv = new U(),
  Xv = new U();
let Hp = !1;
class Fr {
  constructor(e = new U(), t = new U(), r = new U()) {
    (this.a = e), (this.b = t), (this.c = r);
  }
  static getNormal(e, t, r, i) {
    i.subVectors(r, t), Yi.subVectors(e, t), i.cross(Yi);
    const s = i.lengthSq();
    return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, r, i, s) {
    Yi.subVectors(i, t), qs.subVectors(r, t), Vv.subVectors(e, t);
    const o = Yi.dot(Yi),
      a = Yi.dot(qs),
      l = Yi.dot(Vv),
      u = qs.dot(qs),
      h = qs.dot(Vv),
      d = o * u - a * a;
    if (d === 0) return s.set(-2, -1, -1);
    const p = 1 / d,
      m = (u * l - a * h) * p,
      _ = (o * h - a * l) * p;
    return s.set(1 - m - _, _, m);
  }
  static containsPoint(e, t, r, i) {
    return (
      this.getBarycoord(e, t, r, i, Zs),
      Zs.x >= 0 && Zs.y >= 0 && Zs.x + Zs.y <= 1
    );
  }
  static getUV(e, t, r, i, s, o, a, l) {
    return (
      Hp === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (Hp = !0)),
      this.getInterpolation(e, t, r, i, s, o, a, l)
    );
  }
  static getInterpolation(e, t, r, i, s, o, a, l) {
    return (
      this.getBarycoord(e, t, r, i, Zs),
      l.setScalar(0),
      l.addScaledVector(s, Zs.x),
      l.addScaledVector(o, Zs.y),
      l.addScaledVector(a, Zs.z),
      l
    );
  }
  static isFrontFacing(e, t, r, i) {
    return Yi.subVectors(r, t), qs.subVectors(e, t), Yi.cross(qs).dot(i) < 0;
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, i) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, r, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, r),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      Yi.subVectors(this.c, this.b),
      qs.subVectors(this.a, this.b),
      Yi.cross(qs).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Fr.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Fr.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, r, i, s) {
    return (
      Hp === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (Hp = !0)),
      Fr.getInterpolation(e, this.a, this.b, this.c, t, r, i, s)
    );
  }
  getInterpolation(e, t, r, i, s) {
    return Fr.getInterpolation(e, this.a, this.b, this.c, t, r, i, s);
  }
  containsPoint(e) {
    return Fr.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Fr.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a,
      i = this.b,
      s = this.c;
    let o, a;
    pu.subVectors(i, r), mu.subVectors(s, r), Wv.subVectors(e, r);
    const l = pu.dot(Wv),
      u = mu.dot(Wv);
    if (l <= 0 && u <= 0) return t.copy(r);
    jv.subVectors(e, i);
    const h = pu.dot(jv),
      d = mu.dot(jv);
    if (h >= 0 && d <= h) return t.copy(i);
    const p = l * d - h * u;
    if (p <= 0 && l >= 0 && h <= 0)
      return (o = l / (l - h)), t.copy(r).addScaledVector(pu, o);
    Xv.subVectors(e, s);
    const m = pu.dot(Xv),
      _ = mu.dot(Xv);
    if (_ >= 0 && m <= _) return t.copy(s);
    const y = m * u - l * _;
    if (y <= 0 && u >= 0 && _ <= 0)
      return (a = u / (u - _)), t.copy(r).addScaledVector(mu, a);
    const x = h * _ - m * d;
    if (x <= 0 && d - h >= 0 && m - _ >= 0)
      return (
        CC.subVectors(s, i),
        (a = (d - h) / (d - h + (m - _))),
        t.copy(i).addScaledVector(CC, a)
      );
    const g = 1 / (x + y + p);
    return (
      (o = y * g),
      (a = p * g),
      t.copy(r).addScaledVector(pu, o).addScaledVector(mu, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let Nz = 0;
class In extends Mo {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: Nz++ }),
      (this.uuid = ui()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = yl),
      (this.side = Fs),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = KA),
      (this.blendDst = YA),
      (this.blendEquation = ol),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = Rg),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = y2),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Ym),
      (this.stencilZFail = Ym),
      (this.stencilZPass = Ym),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const r = e[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        i && i.isColor
          ? i.set(r)
          : i && i.isVector3 && r && r.isVector3
          ? i.copy(r)
          : (this[t] = r);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const r = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.color && this.color.isColor && (r.color = this.color.getHex()),
      this.roughness !== void 0 && (r.roughness = this.roughness),
      this.metalness !== void 0 && (r.metalness = this.metalness),
      this.sheen !== void 0 && (r.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (r.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (r.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (r.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (r.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (r.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (r.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (r.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (r.shininess = this.shininess),
      this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (r.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (r.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (r.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (r.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (r.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (r.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((r.lightMap = this.lightMap.toJSON(e).uuid),
        (r.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((r.aoMap = this.aoMap.toJSON(e).uuid),
        (r.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((r.bumpMap = this.bumpMap.toJSON(e).uuid),
        (r.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((r.normalMap = this.normalMap.toJSON(e).uuid),
        (r.normalMapType = this.normalMapType),
        (r.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((r.displacementMap = this.displacementMap.toJSON(e).uuid),
        (r.displacementScale = this.displacementScale),
        (r.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (r.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((r.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (r.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (r.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (r.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (r.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (r.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (r.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (r.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (r.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (r.size = this.size),
      this.shadowSide !== null && (r.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (r.sizeAttenuation = this.sizeAttenuation),
      this.blending !== yl && (r.blending = this.blending),
      this.side !== Fs && (r.side = this.side),
      this.vertexColors && (r.vertexColors = !0),
      this.opacity < 1 && (r.opacity = this.opacity),
      this.transparent === !0 && (r.transparent = this.transparent),
      (r.depthFunc = this.depthFunc),
      (r.depthTest = this.depthTest),
      (r.depthWrite = this.depthWrite),
      (r.colorWrite = this.colorWrite),
      (r.stencilWrite = this.stencilWrite),
      (r.stencilWriteMask = this.stencilWriteMask),
      (r.stencilFunc = this.stencilFunc),
      (r.stencilRef = this.stencilRef),
      (r.stencilFuncMask = this.stencilFuncMask),
      (r.stencilFail = this.stencilFail),
      (r.stencilZFail = this.stencilZFail),
      (r.stencilZPass = this.stencilZPass),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (r.rotation = this.rotation),
      this.polygonOffset === !0 && (r.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (r.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (r.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (r.linewidth = this.linewidth),
      this.dashSize !== void 0 && (r.dashSize = this.dashSize),
      this.gapSize !== void 0 && (r.gapSize = this.gapSize),
      this.scale !== void 0 && (r.scale = this.scale),
      this.dithering === !0 && (r.dithering = !0),
      this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (r.alphaHash = this.alphaHash),
      this.alphaToCoverage === !0 && (r.alphaToCoverage = this.alphaToCoverage),
      this.premultipliedAlpha === !0 &&
        (r.premultipliedAlpha = this.premultipliedAlpha),
      this.forceSinglePass === !0 && (r.forceSinglePass = this.forceSinglePass),
      this.wireframe === !0 && (r.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (r.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (r.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (r.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (r.flatShading = this.flatShading),
      this.visible === !1 && (r.visible = !1),
      this.toneMapped === !1 && (r.toneMapped = !1),
      this.fog === !1 && (r.fog = !1),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData);
    function i(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const s = i(e.textures),
        o = i(e.images);
      s.length > 0 && (r.textures = s), o.length > 0 && (r.images = o);
    }
    return r;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let r = null;
    if (t !== null) {
      const i = t.length;
      r = new Array(i);
      for (let s = 0; s !== i; ++s) r[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = r),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
const B2 = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Qi = { h: 0, s: 0, l: 0 },
  Gp = { h: 0, s: 0, l: 0 };
function Jv(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n
  );
}
class Be {
  constructor(e, t, r) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, r)
    );
  }
  set(e, t, r) {
    if (t === void 0 && r === void 0) {
      const i = e;
      i && i.isColor
        ? this.copy(i)
        : typeof i == "number"
        ? this.setHex(i)
        : typeof i == "string" && this.setStyle(i);
    } else this.setRGB(e, t, r);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = ht) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      wi.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, r, i = wi.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = r),
      wi.toWorkingColorSpace(this, i),
      this
    );
  }
  setHSL(e, t, r, i = wi.workingColorSpace) {
    if (((e = a1(e, 1)), (t = gn(t, 0, 1)), (r = gn(r, 0, 1)), t === 0))
      this.r = this.g = this.b = r;
    else {
      const s = r <= 0.5 ? r * (1 + t) : r + t - r * t,
        o = 2 * r - s;
      (this.r = Jv(o, s, e + 1 / 3)),
        (this.g = Jv(o, s, e)),
        (this.b = Jv(o, s, e - 1 / 3));
    }
    return wi.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = ht) {
    function r(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const o = i[1],
        a = i[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = i[1],
        o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        );
      if (o === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = ht) {
    const r = B2[e.toLowerCase()];
    return (
      r !== void 0
        ? this.setHex(r, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = oc(e.r)), (this.g = oc(e.g)), (this.b = oc(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = Fv(e.r)), (this.g = Fv(e.g)), (this.b = Fv(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = ht) {
    return (
      wi.fromWorkingColorSpace(hr.copy(this), e),
      Math.round(gn(hr.r * 255, 0, 255)) * 65536 +
        Math.round(gn(hr.g * 255, 0, 255)) * 256 +
        Math.round(gn(hr.b * 255, 0, 255))
    );
  }
  getHexString(e = ht) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = wi.workingColorSpace) {
    wi.fromWorkingColorSpace(hr.copy(this), t);
    const r = hr.r,
      i = hr.g,
      s = hr.b,
      o = Math.max(r, i, s),
      a = Math.min(r, i, s);
    let l, u;
    const h = (a + o) / 2;
    if (a === o) (l = 0), (u = 0);
    else {
      const d = o - a;
      switch (((u = h <= 0.5 ? d / (o + a) : d / (2 - o - a)), o)) {
        case r:
          l = (i - s) / d + (i < s ? 6 : 0);
          break;
        case i:
          l = (s - r) / d + 2;
          break;
        case s:
          l = (r - i) / d + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = u), (e.l = h), e;
  }
  getRGB(e, t = wi.workingColorSpace) {
    return (
      wi.fromWorkingColorSpace(hr.copy(this), t),
      (e.r = hr.r),
      (e.g = hr.g),
      (e.b = hr.b),
      e
    );
  }
  getStyle(e = ht) {
    wi.fromWorkingColorSpace(hr.copy(this), e);
    const t = hr.r,
      r = hr.g,
      i = hr.b;
    return e !== ht
      ? `color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(r * 255)},${Math.round(
          i * 255
        )})`;
  }
  offsetHSL(e, t, r) {
    return (
      this.getHSL(Qi),
      (Qi.h += e),
      (Qi.s += t),
      (Qi.l += r),
      this.setHSL(Qi.h, Qi.s, Qi.l),
      this
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, r) {
    return (
      (this.r = e.r + (t.r - e.r) * r),
      (this.g = e.g + (t.g - e.g) * r),
      (this.b = e.b + (t.b - e.b) * r),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(Qi), e.getHSL(Gp);
    const r = rh(Qi.h, Gp.h, t),
      i = rh(Qi.s, Gp.s, t),
      s = rh(Qi.l, Gp.l, t);
    return this.setHSL(r, i, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      r = this.g,
      i = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * r + s[6] * i),
      (this.g = s[1] * t + s[4] * r + s[7] * i),
      (this.b = s[2] * t + s[5] * r + s[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const hr = new Be();
Be.NAMES = B2;
class kr extends In {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Be(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = od),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const so = Oz();
function Oz() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    r = new Uint32Array(512),
    i = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const u = l - 127;
    u < -27
      ? ((r[l] = 0), (r[l | 256] = 32768), (i[l] = 24), (i[l | 256] = 24))
      : u < -14
      ? ((r[l] = 1024 >> (-u - 14)),
        (r[l | 256] = (1024 >> (-u - 14)) | 32768),
        (i[l] = -u - 1),
        (i[l | 256] = -u - 1))
      : u <= 15
      ? ((r[l] = (u + 15) << 10),
        (r[l | 256] = ((u + 15) << 10) | 32768),
        (i[l] = 13),
        (i[l | 256] = 13))
      : u < 128
      ? ((r[l] = 31744), (r[l | 256] = 64512), (i[l] = 24), (i[l | 256] = 24))
      : ((r[l] = 31744), (r[l | 256] = 64512), (i[l] = 13), (i[l | 256] = 13));
  }
  const s = new Uint32Array(2048),
    o = new Uint32Array(64),
    a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let u = l << 13,
      h = 0;
    for (; !(u & 8388608); ) (u <<= 1), (h -= 8388608);
    (u &= -8388609), (h += 947912704), (s[l] = u | h);
  }
  for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) o[l] = l << 23;
  (o[31] = 1199570944), (o[32] = 2147483648);
  for (let l = 33; l < 63; ++l) o[l] = 2147483648 + ((l - 32) << 23);
  o[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: r,
    shiftTable: i,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a,
  };
}
function Ir(n) {
  Math.abs(n) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (n = gn(n, -65504, 65504)),
    (so.floatView[0] = n);
  const e = so.uint32View[0],
    t = (e >> 23) & 511;
  return so.baseTable[t] + ((e & 8388607) >> so.shiftTable[t]);
}
function Vf(n) {
  const e = n >> 10;
  return (
    (so.uint32View[0] =
      so.mantissaTable[so.offsetTable[e] + (n & 1023)] + so.exponentTable[e]),
    so.floatView[0]
  );
}
const Uz = { toHalfFloat: Ir, fromHalfFloat: Vf },
  bn = new U(),
  Vp = new ge();
class Dt {
  constructor(e, t, r = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = r),
      (this.usage = Dh),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.gpuType = Cs),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, r) {
    (e *= this.itemSize), (r *= t.itemSize);
    for (let i = 0, s = this.itemSize; i < s; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        Vp.fromBufferAttribute(this, t),
          Vp.applyMatrix3(e),
          this.setXY(t, Vp.x, Vp.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        bn.fromBufferAttribute(this, t),
          bn.applyMatrix3(e),
          this.setXYZ(t, bn.x, bn.y, bn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      bn.fromBufferAttribute(this, t),
        bn.applyMatrix4(e),
        this.setXYZ(t, bn.x, bn.y, bn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      bn.fromBufferAttribute(this, t),
        bn.applyNormalMatrix(e),
        this.setXYZ(t, bn.x, bn.y, bn.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      bn.fromBufferAttribute(this, t),
        bn.transformDirection(e),
        this.setXYZ(t, bn.x, bn.y, bn.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = ai(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = ai(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = ai(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = ai(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = vt(t, this.array)), (r = vt(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = vt(t, this.array)),
        (r = vt(r, this.array)),
        (i = vt(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, r, i, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = vt(t, this.array)),
        (r = vt(r, this.array)),
        (i = vt(i, this.array)),
        (s = vt(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Dh && (e.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
      e
    );
  }
}
class kz extends Dt {
  constructor(e, t, r) {
    super(new Int8Array(e), t, r);
  }
}
class zz extends Dt {
  constructor(e, t, r) {
    super(new Uint8Array(e), t, r);
  }
}
class Hz extends Dt {
  constructor(e, t, r) {
    super(new Uint8ClampedArray(e), t, r);
  }
}
class Gz extends Dt {
  constructor(e, t, r) {
    super(new Int16Array(e), t, r);
  }
}
class c1 extends Dt {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class Vz extends Dt {
  constructor(e, t, r) {
    super(new Int32Array(e), t, r);
  }
}
class f1 extends Dt {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class Wz extends Dt {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = Vf(this.array[e * this.itemSize]);
    return this.normalized && (t = ai(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.array[e * this.itemSize] = Ir(t)),
      this
    );
  }
  getY(e) {
    let t = Vf(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = ai(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.array[e * this.itemSize + 1] = Ir(t)),
      this
    );
  }
  getZ(e) {
    let t = Vf(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = ai(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.array[e * this.itemSize + 2] = Ir(t)),
      this
    );
  }
  getW(e) {
    let t = Vf(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = ai(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.array[e * this.itemSize + 3] = Ir(t)),
      this
    );
  }
  setXY(e, t, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = vt(t, this.array)), (r = vt(r, this.array))),
      (this.array[e + 0] = Ir(t)),
      (this.array[e + 1] = Ir(r)),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = vt(t, this.array)),
        (r = vt(r, this.array)),
        (i = vt(i, this.array))),
      (this.array[e + 0] = Ir(t)),
      (this.array[e + 1] = Ir(r)),
      (this.array[e + 2] = Ir(i)),
      this
    );
  }
  setXYZW(e, t, r, i, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = vt(t, this.array)),
        (r = vt(r, this.array)),
        (i = vt(i, this.array)),
        (s = vt(s, this.array))),
      (this.array[e + 0] = Ir(t)),
      (this.array[e + 1] = Ir(r)),
      (this.array[e + 2] = Ir(i)),
      (this.array[e + 3] = Ir(s)),
      this
    );
  }
}
class Xe extends Dt {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
class jz extends Dt {
  constructor(e, t, r) {
    super(new Float64Array(e), t, r);
  }
}
let Xz = 0;
const Ei = new rt(),
  Kv = new bt(),
  gu = new U(),
  ni = new us(),
  Cf = new us(),
  Xn = new U();
class dt extends Mo {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: Xz++ }),
      (this.uuid = ui()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (P2(e) ? f1 : c1)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({ start: e, count: t, materialIndex: r });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const r = this.attributes.normal;
    if (r !== void 0) {
      const s = new _t().getNormalMatrix(e);
      r.applyNormalMatrix(s), (r.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Ei.makeRotationFromQuaternion(e), this.applyMatrix4(Ei), this;
  }
  rotateX(e) {
    return Ei.makeRotationX(e), this.applyMatrix4(Ei), this;
  }
  rotateY(e) {
    return Ei.makeRotationY(e), this.applyMatrix4(Ei), this;
  }
  rotateZ(e) {
    return Ei.makeRotationZ(e), this.applyMatrix4(Ei), this;
  }
  translate(e, t, r) {
    return Ei.makeTranslation(e, t, r), this.applyMatrix4(Ei), this;
  }
  scale(e, t, r) {
    return Ei.makeScale(e, t, r), this.applyMatrix4(Ei), this;
  }
  lookAt(e) {
    return Kv.lookAt(e), Kv.updateMatrix(), this.applyMatrix4(Kv.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(gu).negate(),
      this.translate(gu.x, gu.y, gu.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let r = 0, i = e.length; r < i; r++) {
      const s = e[r];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new Xe(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new us());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new U(-1 / 0, -1 / 0, -1 / 0),
          new U(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let r = 0, i = t.length; r < i; r++) {
          const s = t[r];
          ni.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (Xn.addVectors(this.boundingBox.min, ni.min),
                this.boundingBox.expandByPoint(Xn),
                Xn.addVectors(this.boundingBox.max, ni.max),
                this.boundingBox.expandByPoint(Xn))
              : (this.boundingBox.expandByPoint(ni.min),
                this.boundingBox.expandByPoint(ni.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Gi());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new U(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if ((ni.setFromBufferAttribute(e), t))
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s];
          Cf.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (Xn.addVectors(ni.min, Cf.min),
                ni.expandByPoint(Xn),
                Xn.addVectors(ni.max, Cf.max),
                ni.expandByPoint(Xn))
              : (ni.expandByPoint(Cf.min), ni.expandByPoint(Cf.max));
        }
      ni.getCenter(r);
      let i = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Xn.fromBufferAttribute(e, s),
          (i = Math.max(i, r.distanceToSquared(Xn)));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s],
            l = this.morphTargetsRelative;
          for (let u = 0, h = a.count; u < h; u++)
            Xn.fromBufferAttribute(a, u),
              l && (gu.fromBufferAttribute(e, u), Xn.add(gu)),
              (i = Math.max(i, r.distanceToSquared(Xn)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const r = e.array,
      i = t.position.array,
      s = t.normal.array,
      o = t.uv.array,
      a = i.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Dt(new Float32Array(4 * a), 4));
    const l = this.getAttribute("tangent").array,
      u = [],
      h = [];
    for (let B = 0; B < a; B++) (u[B] = new U()), (h[B] = new U());
    const d = new U(),
      p = new U(),
      m = new U(),
      _ = new ge(),
      y = new ge(),
      x = new ge(),
      g = new U(),
      S = new U();
    function A(B, D, I) {
      d.fromArray(i, B * 3),
        p.fromArray(i, D * 3),
        m.fromArray(i, I * 3),
        _.fromArray(o, B * 2),
        y.fromArray(o, D * 2),
        x.fromArray(o, I * 2),
        p.sub(d),
        m.sub(d),
        y.sub(_),
        x.sub(_);
      const F = 1 / (y.x * x.y - x.x * y.y);
      isFinite(F) &&
        (g
          .copy(p)
          .multiplyScalar(x.y)
          .addScaledVector(m, -y.y)
          .multiplyScalar(F),
        S.copy(m)
          .multiplyScalar(y.x)
          .addScaledVector(p, -x.x)
          .multiplyScalar(F),
        u[B].add(g),
        u[D].add(g),
        u[I].add(g),
        h[B].add(S),
        h[D].add(S),
        h[I].add(S));
    }
    let E = this.groups;
    E.length === 0 && (E = [{ start: 0, count: r.length }]);
    for (let B = 0, D = E.length; B < D; ++B) {
      const I = E[B],
        F = I.start,
        k = I.count;
      for (let j = F, Z = F + k; j < Z; j += 3) A(r[j + 0], r[j + 1], r[j + 2]);
    }
    const C = new U(),
      R = new U(),
      P = new U(),
      L = new U();
    function T(B) {
      P.fromArray(s, B * 3), L.copy(P);
      const D = u[B];
      C.copy(D),
        C.sub(P.multiplyScalar(P.dot(D))).normalize(),
        R.crossVectors(L, D);
      const F = R.dot(h[B]) < 0 ? -1 : 1;
      (l[B * 4] = C.x),
        (l[B * 4 + 1] = C.y),
        (l[B * 4 + 2] = C.z),
        (l[B * 4 + 3] = F);
    }
    for (let B = 0, D = E.length; B < D; ++B) {
      const I = E[B],
        F = I.start,
        k = I.count;
      for (let j = F, Z = F + k; j < Z; j += 3)
        T(r[j + 0]), T(r[j + 1]), T(r[j + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        (r = new Dt(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", r);
      else for (let p = 0, m = r.count; p < m; p++) r.setXYZ(p, 0, 0, 0);
      const i = new U(),
        s = new U(),
        o = new U(),
        a = new U(),
        l = new U(),
        u = new U(),
        h = new U(),
        d = new U();
      if (e)
        for (let p = 0, m = e.count; p < m; p += 3) {
          const _ = e.getX(p + 0),
            y = e.getX(p + 1),
            x = e.getX(p + 2);
          i.fromBufferAttribute(t, _),
            s.fromBufferAttribute(t, y),
            o.fromBufferAttribute(t, x),
            h.subVectors(o, s),
            d.subVectors(i, s),
            h.cross(d),
            a.fromBufferAttribute(r, _),
            l.fromBufferAttribute(r, y),
            u.fromBufferAttribute(r, x),
            a.add(h),
            l.add(h),
            u.add(h),
            r.setXYZ(_, a.x, a.y, a.z),
            r.setXYZ(y, l.x, l.y, l.z),
            r.setXYZ(x, u.x, u.y, u.z);
        }
      else
        for (let p = 0, m = t.count; p < m; p += 3)
          i.fromBufferAttribute(t, p + 0),
            s.fromBufferAttribute(t, p + 1),
            o.fromBufferAttribute(t, p + 2),
            h.subVectors(o, s),
            d.subVectors(i, s),
            h.cross(d),
            r.setXYZ(p + 0, h.x, h.y, h.z),
            r.setXYZ(p + 1, h.x, h.y, h.z),
            r.setXYZ(p + 2, h.x, h.y, h.z);
      this.normalizeNormals(), (r.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      Xn.fromBufferAttribute(e, t),
        Xn.normalize(),
        e.setXYZ(t, Xn.x, Xn.y, Xn.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const u = a.array,
        h = a.itemSize,
        d = a.normalized,
        p = new u.constructor(l.length * h);
      let m = 0,
        _ = 0;
      for (let y = 0, x = l.length; y < x; y++) {
        a.isInterleavedBufferAttribute
          ? (m = l[y] * a.data.stride + a.offset)
          : (m = l[y] * h);
        for (let g = 0; g < h; g++) p[_++] = u[m++];
      }
      return new Dt(p, h, d);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new dt(),
      r = this.index.array,
      i = this.attributes;
    for (const a in i) {
      const l = i[a],
        u = e(l, r);
      t.setAttribute(a, u);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [],
        u = s[a];
      for (let h = 0, d = u.length; h < d; h++) {
        const p = u[h],
          m = e(p, r);
        l.push(m);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const u = o[a];
      t.addGroup(u.start, u.count, u.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const u in l) l[u] !== void 0 && (e[u] = l[u]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const r = this.attributes;
    for (const l in r) {
      const u = r[l];
      e.data.attributes[l] = u.toJSON(e.data);
    }
    const i = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const u = this.morphAttributes[l],
        h = [];
      for (let d = 0, p = u.length; d < p; d++) {
        const m = u[d];
        h.push(m.toJSON(e.data));
      }
      h.length > 0 && ((i[l] = h), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(t));
    const i = e.attributes;
    for (const u in i) {
      const h = i[u];
      this.setAttribute(u, h.clone(t));
    }
    const s = e.morphAttributes;
    for (const u in s) {
      const h = [],
        d = s[u];
      for (let p = 0, m = d.length; p < m; p++) h.push(d[p].clone(t));
      this.morphAttributes[u] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let u = 0, h = o.length; u < h; u++) {
      const d = o[u];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const TC = new rt(),
  Wa = new Vc(),
  Wp = new Gi(),
  bC = new U(),
  _u = new U(),
  vu = new U(),
  yu = new U(),
  Yv = new U(),
  jp = new U(),
  Xp = new ge(),
  Jp = new ge(),
  Kp = new ge(),
  RC = new U(),
  PC = new U(),
  BC = new U(),
  Yp = new U(),
  Qp = new U();
class kn extends bt {
  constructor(e = new dt(), t = new kr()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = i.length; s < o; s++) {
          const a = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const r = this.geometry,
      i = r.attributes.position,
      s = r.morphAttributes.position,
      o = r.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      jp.set(0, 0, 0);
      for (let l = 0, u = s.length; l < u; l++) {
        const h = a[l],
          d = s[l];
        h !== 0 &&
          (Yv.fromBufferAttribute(d, e),
          o ? jp.addScaledVector(Yv, h) : jp.addScaledVector(Yv.sub(t), h));
      }
      t.add(jp);
    }
    return t;
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.material,
      s = this.matrixWorld;
    i !== void 0 &&
      (r.boundingSphere === null && r.computeBoundingSphere(),
      Wp.copy(r.boundingSphere),
      Wp.applyMatrix4(s),
      Wa.copy(e.ray).recast(e.near),
      !(
        Wp.containsPoint(Wa.origin) === !1 &&
        (Wa.intersectSphere(Wp, bC) === null ||
          Wa.origin.distanceToSquared(bC) > (e.far - e.near) ** 2)
      ) &&
        (TC.copy(s).invert(),
        Wa.copy(e.ray).applyMatrix4(TC),
        !(r.boundingBox !== null && Wa.intersectsBox(r.boundingBox) === !1) &&
          this._computeIntersections(e, t, Wa)));
  }
  _computeIntersections(e, t, r) {
    let i;
    const s = this.geometry,
      o = this.material,
      a = s.index,
      l = s.attributes.position,
      u = s.attributes.uv,
      h = s.attributes.uv1,
      d = s.attributes.normal,
      p = s.groups,
      m = s.drawRange;
    if (a !== null)
      if (Array.isArray(o))
        for (let _ = 0, y = p.length; _ < y; _++) {
          const x = p[_],
            g = o[x.materialIndex],
            S = Math.max(x.start, m.start),
            A = Math.min(
              a.count,
              Math.min(x.start + x.count, m.start + m.count)
            );
          for (let E = S, C = A; E < C; E += 3) {
            const R = a.getX(E),
              P = a.getX(E + 1),
              L = a.getX(E + 2);
            (i = qp(this, g, e, r, u, h, d, R, P, L)),
              i &&
                ((i.faceIndex = Math.floor(E / 3)),
                (i.face.materialIndex = x.materialIndex),
                t.push(i));
          }
        }
      else {
        const _ = Math.max(0, m.start),
          y = Math.min(a.count, m.start + m.count);
        for (let x = _, g = y; x < g; x += 3) {
          const S = a.getX(x),
            A = a.getX(x + 1),
            E = a.getX(x + 2);
          (i = qp(this, o, e, r, u, h, d, S, A, E)),
            i && ((i.faceIndex = Math.floor(x / 3)), t.push(i));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let _ = 0, y = p.length; _ < y; _++) {
          const x = p[_],
            g = o[x.materialIndex],
            S = Math.max(x.start, m.start),
            A = Math.min(
              l.count,
              Math.min(x.start + x.count, m.start + m.count)
            );
          for (let E = S, C = A; E < C; E += 3) {
            const R = E,
              P = E + 1,
              L = E + 2;
            (i = qp(this, g, e, r, u, h, d, R, P, L)),
              i &&
                ((i.faceIndex = Math.floor(E / 3)),
                (i.face.materialIndex = x.materialIndex),
                t.push(i));
          }
        }
      else {
        const _ = Math.max(0, m.start),
          y = Math.min(l.count, m.start + m.count);
        for (let x = _, g = y; x < g; x += 3) {
          const S = x,
            A = x + 1,
            E = x + 2;
          (i = qp(this, o, e, r, u, h, d, S, A, E)),
            i && ((i.faceIndex = Math.floor(x / 3)), t.push(i));
        }
      }
  }
}
function Jz(n, e, t, r, i, s, o, a) {
  let l;
  if (
    (e.side === Tr
      ? (l = r.intersectTriangle(o, s, i, !0, a))
      : (l = r.intersectTriangle(i, s, o, e.side === Fs, a)),
    l === null)
  )
    return null;
  Qp.copy(a), Qp.applyMatrix4(n.matrixWorld);
  const u = t.ray.origin.distanceTo(Qp);
  return u < t.near || u > t.far
    ? null
    : { distance: u, point: Qp.clone(), object: n };
}
function qp(n, e, t, r, i, s, o, a, l, u) {
  n.getVertexPosition(a, _u),
    n.getVertexPosition(l, vu),
    n.getVertexPosition(u, yu);
  const h = Jz(n, e, t, r, _u, vu, yu, Yp);
  if (h) {
    i &&
      (Xp.fromBufferAttribute(i, a),
      Jp.fromBufferAttribute(i, l),
      Kp.fromBufferAttribute(i, u),
      (h.uv = Fr.getInterpolation(Yp, _u, vu, yu, Xp, Jp, Kp, new ge()))),
      s &&
        (Xp.fromBufferAttribute(s, a),
        Jp.fromBufferAttribute(s, l),
        Kp.fromBufferAttribute(s, u),
        (h.uv1 = Fr.getInterpolation(Yp, _u, vu, yu, Xp, Jp, Kp, new ge())),
        (h.uv2 = h.uv1)),
      o &&
        (RC.fromBufferAttribute(o, a),
        PC.fromBufferAttribute(o, l),
        BC.fromBufferAttribute(o, u),
        (h.normal = Fr.getInterpolation(Yp, _u, vu, yu, RC, PC, BC, new U())),
        h.normal.dot(r.direction) > 0 && h.normal.multiplyScalar(-1));
    const d = { a, b: l, c: u, normal: new U(), materialIndex: 0 };
    Fr.getNormal(_u, vu, yu, d.normal), (h.face = d);
  }
  return h;
}
class zl extends dt {
  constructor(e = 1, t = 1, r = 1, i = 1, s = 1, o = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: r,
        widthSegments: i,
        heightSegments: s,
        depthSegments: o,
      });
    const a = this;
    (i = Math.floor(i)), (s = Math.floor(s)), (o = Math.floor(o));
    const l = [],
      u = [],
      h = [],
      d = [];
    let p = 0,
      m = 0;
    _("z", "y", "x", -1, -1, r, t, e, o, s, 0),
      _("z", "y", "x", 1, -1, r, t, -e, o, s, 1),
      _("x", "z", "y", 1, 1, e, r, t, i, o, 2),
      _("x", "z", "y", 1, -1, e, r, -t, i, o, 3),
      _("x", "y", "z", 1, -1, e, t, r, i, s, 4),
      _("x", "y", "z", -1, -1, e, t, -r, i, s, 5),
      this.setIndex(l),
      this.setAttribute("position", new Xe(u, 3)),
      this.setAttribute("normal", new Xe(h, 3)),
      this.setAttribute("uv", new Xe(d, 2));
    function _(y, x, g, S, A, E, C, R, P, L, T) {
      const B = E / P,
        D = C / L,
        I = E / 2,
        F = C / 2,
        k = R / 2,
        j = P + 1,
        Z = L + 1;
      let Q = 0,
        N = 0;
      const W = new U();
      for (let G = 0; G < Z; G++) {
        const X = G * D - F;
        for (let Y = 0; Y < j; Y++) {
          const de = Y * B - I;
          (W[y] = de * S),
            (W[x] = X * A),
            (W[g] = k),
            u.push(W.x, W.y, W.z),
            (W[y] = 0),
            (W[x] = 0),
            (W[g] = R > 0 ? 1 : -1),
            h.push(W.x, W.y, W.z),
            d.push(Y / P),
            d.push(1 - G / L),
            (Q += 1);
        }
      }
      for (let G = 0; G < L; G++)
        for (let X = 0; X < P; X++) {
          const Y = p + X + j * G,
            de = p + X + j * (G + 1),
            ae = p + (X + 1) + j * (G + 1),
            ye = p + (X + 1) + j * G;
          l.push(Y, de, ye), l.push(de, ae, ye), (N += 6);
        }
      a.addGroup(m, N, T), (m += N), (p += Q);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new zl(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function wc(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const r in n[t]) {
      const i = n[t][r];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][r] = null))
          : (e[t][r] = i.clone())
        : Array.isArray(i)
        ? (e[t][r] = i.slice())
        : (e[t][r] = i);
    }
  }
  return e;
}
function Er(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = wc(n[t]);
    for (const i in r) e[i] = r[i];
  }
  return e;
}
function Kz(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function L2(n) {
  return n.getRenderTarget() === null ? n.outputColorSpace : as;
}
const I2 = { clone: wc, merge: Er };
var Yz = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  Qz = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Os extends In {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = Yz),
      (this.fragmentShader = Qz),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = wc(e.uniforms)),
      (this.uniformsGroups = Kz(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const o = this.uniforms[i].value;
      o && o.isTexture
        ? (t.uniforms[i] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
        ? (t.uniforms[i] = { type: "c", value: o.getHex() })
        : o && o.isVector2
        ? (t.uniforms[i] = { type: "v2", value: o.toArray() })
        : o && o.isVector3
        ? (t.uniforms[i] = { type: "v3", value: o.toArray() })
        : o && o.isVector4
        ? (t.uniforms[i] = { type: "v4", value: o.toArray() })
        : o && o.isMatrix3
        ? (t.uniforms[i] = { type: "m3", value: o.toArray() })
        : o && o.isMatrix4
        ? (t.uniforms[i] = { type: "m4", value: o.toArray() })
        : (t.uniforms[i] = { value: o });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const r = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (r[i] = !0);
    return Object.keys(r).length > 0 && (t.extensions = r), t;
  }
}
class ld extends bt {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new rt()),
      (this.projectionMatrix = new rt()),
      (this.projectionMatrixInverse = new rt()),
      (this.coordinateSystem = Ts);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Mn extends ld {
  constructor(e = 50, t = 1, r = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = r),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = Ec * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(xl * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return Ec * 2 * Math.atan(Math.tan(xl * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, r, i, s, o) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(xl * 0.5 * this.fov)) / this.zoom,
      r = 2 * t,
      i = this.aspect * r,
      s = -0.5 * i;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth,
        u = o.fullHeight;
      (s += (o.offsetX * i) / l),
        (t -= (o.offsetY * r) / u),
        (i *= o.width / l),
        (r *= o.height / u);
    }
    const a = this.filmOffset;
    a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + i,
        t,
        t - r,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const xu = -90,
  Su = 1;
class D2 extends bt {
  constructor(e, t, r) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = r),
      (this.coordinateSystem = null);
    const i = new Mn(xu, Su, e, t);
    (i.layers = this.layers), this.add(i);
    const s = new Mn(xu, Su, e, t);
    (s.layers = this.layers), this.add(s);
    const o = new Mn(xu, Su, e, t);
    (o.layers = this.layers), this.add(o);
    const a = new Mn(xu, Su, e, t);
    (a.layers = this.layers), this.add(a);
    const l = new Mn(xu, Su, e, t);
    (l.layers = this.layers), this.add(l);
    const u = new Mn(xu, Su, e, t);
    (u.layers = this.layers), this.add(u);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [r, i, s, o, a, l] = t;
    for (const u of t) this.remove(u);
    if (e === Ts)
      r.up.set(0, 1, 0),
        r.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1);
    else if (e === Fh)
      r.up.set(0, -1, 0),
        r.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const u of t) this.add(u), u.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const r = this.renderTarget;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [i, s, o, a, l, u] = this.children,
      h = e.getRenderTarget(),
      d = e.toneMapping,
      p = e.xr.enabled;
    (e.toneMapping = is), (e.xr.enabled = !1);
    const m = r.texture.generateMipmaps;
    (r.texture.generateMipmaps = !1),
      e.setRenderTarget(r, 0),
      e.render(t, i),
      e.setRenderTarget(r, 1),
      e.render(t, s),
      e.setRenderTarget(r, 2),
      e.render(t, o),
      e.setRenderTarget(r, 3),
      e.render(t, a),
      e.setRenderTarget(r, 4),
      e.render(t, l),
      (r.texture.generateMipmaps = m),
      e.setRenderTarget(r, 5),
      e.render(t, u),
      e.setRenderTarget(h),
      (e.toneMapping = d),
      (e.xr.enabled = p),
      (r.texture.needsPMREMUpdate = !0);
  }
}
class ud extends en {
  constructor(e, t, r, i, s, o, a, l, u, h) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : va),
      super(e, t, r, i, s, o, a, l, u, h),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class F2 extends ls {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const r = { width: e, height: e, depth: 1 },
      i = [r, r, r, r, r, r];
    t.encoding !== void 0 &&
      (ih(
        "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (t.colorSpace = t.encoding === fa ? ht : ha)),
      (this.texture = new ud(
        i,
        t.mapping,
        t.wrapS,
        t.wrapT,
        t.magFilter,
        t.minFilter,
        t.format,
        t.type,
        t.anisotropy,
        t.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : sn);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const r = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new zl(5, 5, 5),
      s = new Os({
        name: "CubemapFromEquirect",
        uniforms: wc(r.uniforms),
        vertexShader: r.vertexShader,
        fragmentShader: r.fragmentShader,
        side: Tr,
        blending: ho,
      });
    s.uniforms.tEquirect.value = t;
    const o = new kn(i, s),
      a = t.minFilter;
    return (
      t.minFilter === Ns && (t.minFilter = sn),
      new D2(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, t, r, i) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, r, i);
    e.setRenderTarget(s);
  }
}
const Qv = new U(),
  qz = new U(),
  Zz = new _t();
class Wo {
  constructor(e = new U(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, r, i) {
    return this.normal.set(e, t, r), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, r) {
    const i = Qv.subVectors(r, t).cross(qz.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const r = e.delta(Qv),
      i = this.normal.dot(r);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / i;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(r, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      r = this.distanceToPoint(e.end);
    return (t < 0 && r > 0) || (r < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const r = t || Zz.getNormalMatrix(e),
      i = this.coplanarPoint(Qv).applyMatrix4(e),
      s = this.normal.applyMatrix3(r).normalize();
    return (this.constant = -i.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ja = new Gi(),
  Zp = new U();
class M0 {
  constructor(
    e = new Wo(),
    t = new Wo(),
    r = new Wo(),
    i = new Wo(),
    s = new Wo(),
    o = new Wo()
  ) {
    this.planes = [e, t, r, i, s, o];
  }
  set(e, t, r, i, s, o) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(r),
      a[3].copy(i),
      a[4].copy(s),
      a[5].copy(o),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) t[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e, t = Ts) {
    const r = this.planes,
      i = e.elements,
      s = i[0],
      o = i[1],
      a = i[2],
      l = i[3],
      u = i[4],
      h = i[5],
      d = i[6],
      p = i[7],
      m = i[8],
      _ = i[9],
      y = i[10],
      x = i[11],
      g = i[12],
      S = i[13],
      A = i[14],
      E = i[15];
    if (
      (r[0].setComponents(l - s, p - u, x - m, E - g).normalize(),
      r[1].setComponents(l + s, p + u, x + m, E + g).normalize(),
      r[2].setComponents(l + o, p + h, x + _, E + S).normalize(),
      r[3].setComponents(l - o, p - h, x - _, E - S).normalize(),
      r[4].setComponents(l - a, p - d, x - y, E - A).normalize(),
      t === Ts)
    )
      r[5].setComponents(l + a, p + d, x + y, E + A).normalize();
    else if (t === Fh) r[5].setComponents(a, d, y, A).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        ja.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        ja.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(ja);
  }
  intersectsSprite(e) {
    return (
      ja.center.set(0, 0, 0),
      (ja.radius = 0.7071067811865476),
      ja.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(ja)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      r = e.center,
      i = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(r) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) {
      const i = t[r];
      if (
        ((Zp.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (Zp.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (Zp.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(Zp) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function N2() {
  let n = null,
    e = !1,
    t = null,
    r = null;
  function i(s, o) {
    t(s, o), (r = n.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((r = n.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      n.cancelAnimationFrame(r), (e = !1);
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      n = s;
    },
  };
}
function $z(n, e) {
  const t = e.isWebGL2,
    r = new WeakMap();
  function i(u, h) {
    const d = u.array,
      p = u.usage,
      m = n.createBuffer();
    n.bindBuffer(h, m), n.bufferData(h, d, p), u.onUploadCallback();
    let _;
    if (d instanceof Float32Array) _ = n.FLOAT;
    else if (d instanceof Uint16Array)
      if (u.isFloat16BufferAttribute)
        if (t) _ = n.HALF_FLOAT;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else _ = n.UNSIGNED_SHORT;
    else if (d instanceof Int16Array) _ = n.SHORT;
    else if (d instanceof Uint32Array) _ = n.UNSIGNED_INT;
    else if (d instanceof Int32Array) _ = n.INT;
    else if (d instanceof Int8Array) _ = n.BYTE;
    else if (d instanceof Uint8Array) _ = n.UNSIGNED_BYTE;
    else if (d instanceof Uint8ClampedArray) _ = n.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + d
      );
    return {
      buffer: m,
      type: _,
      bytesPerElement: d.BYTES_PER_ELEMENT,
      version: u.version,
    };
  }
  function s(u, h, d) {
    const p = h.array,
      m = h.updateRange;
    n.bindBuffer(d, u),
      m.count === -1
        ? n.bufferSubData(d, 0, p)
        : (t
            ? n.bufferSubData(
                d,
                m.offset * p.BYTES_PER_ELEMENT,
                p,
                m.offset,
                m.count
              )
            : n.bufferSubData(
                d,
                m.offset * p.BYTES_PER_ELEMENT,
                p.subarray(m.offset, m.offset + m.count)
              ),
          (m.count = -1)),
      h.onUploadCallback();
  }
  function o(u) {
    return u.isInterleavedBufferAttribute && (u = u.data), r.get(u);
  }
  function a(u) {
    u.isInterleavedBufferAttribute && (u = u.data);
    const h = r.get(u);
    h && (n.deleteBuffer(h.buffer), r.delete(u));
  }
  function l(u, h) {
    if (u.isGLBufferAttribute) {
      const p = r.get(u);
      (!p || p.version < u.version) &&
        r.set(u, {
          buffer: u.buffer,
          type: u.type,
          bytesPerElement: u.elementSize,
          version: u.version,
        });
      return;
    }
    u.isInterleavedBufferAttribute && (u = u.data);
    const d = r.get(u);
    d === void 0
      ? r.set(u, i(u, h))
      : d.version < u.version && (s(d.buffer, u, h), (d.version = u.version));
  }
  return { get: o, remove: a, update: l };
}
class cd extends dt {
  constructor(e = 1, t = 1, r = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: r,
        heightSegments: i,
      });
    const s = e / 2,
      o = t / 2,
      a = Math.floor(r),
      l = Math.floor(i),
      u = a + 1,
      h = l + 1,
      d = e / a,
      p = t / l,
      m = [],
      _ = [],
      y = [],
      x = [];
    for (let g = 0; g < h; g++) {
      const S = g * p - o;
      for (let A = 0; A < u; A++) {
        const E = A * d - s;
        _.push(E, -S, 0), y.push(0, 0, 1), x.push(A / a), x.push(1 - g / l);
      }
    }
    for (let g = 0; g < l; g++)
      for (let S = 0; S < a; S++) {
        const A = S + u * g,
          E = S + u * (g + 1),
          C = S + 1 + u * (g + 1),
          R = S + 1 + u * g;
        m.push(A, E, R), m.push(E, C, R);
      }
    this.setIndex(m),
      this.setAttribute("position", new Xe(_, 3)),
      this.setAttribute("normal", new Xe(y, 3)),
      this.setAttribute("uv", new Xe(x, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new cd(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var eH = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  tH = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  nH = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  rH = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  iH = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  sH = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  oH = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  aH = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  lH = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  uH = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  cH = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  fH = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  hH = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  dH = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  pH = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  mH = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  gH = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  _H = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  vH = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  yH = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  xH = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  SH = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  AH = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  MH = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  EH = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  wH = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  CH = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  TH = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  bH = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  RH = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  PH = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  BH = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  LH = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  IH = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  DH = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  FH = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  NH = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  OH = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  UH = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  kH = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  zH = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  HH = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  GH = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  VH = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  WH = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  jH = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  XH = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  JH = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  KH = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  YH = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  QH = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,
  qH = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  ZH = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  $H = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  eG = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  tG = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  nG = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  rG = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  iG = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  sG = `#ifdef USE_MAP
	diffuseColor *= texture2D( map, vMapUv );
#endif`,
  oG = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  aG = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  lG = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  uG = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  cG = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  fG = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  hG = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  dG = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  pG = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  mG = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`,
  gG = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  _G = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  vG = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  yG = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  xG = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  SG = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  AG = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  MG = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  EG = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  wG = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  CG = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  TG = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  bG = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  RG = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  PG = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  BG = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  LG = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  IG = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  DG = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  FG = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  NG = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  OG = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  UG = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  kG = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  zG = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  HG = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  GG = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  VG = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  WG = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  jG = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  XG = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  JG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  KG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  YG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  QG = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const qG = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  ZG = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  $G = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  e4 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  t4 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  n4 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  r4 = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  i4 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  s4 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  o4 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  a4 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  l4 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  u4 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  c4 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  f4 = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  h4 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  d4 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  p4 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  m4 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  g4 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  _4 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  v4 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  y4 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  x4 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  S4 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  A4 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  M4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  E4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  w4 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  C4 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  T4 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  b4 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  R4 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  P4 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  pt = {
    alphahash_fragment: eH,
    alphahash_pars_fragment: tH,
    alphamap_fragment: nH,
    alphamap_pars_fragment: rH,
    alphatest_fragment: iH,
    alphatest_pars_fragment: sH,
    aomap_fragment: oH,
    aomap_pars_fragment: aH,
    begin_vertex: lH,
    beginnormal_vertex: uH,
    bsdfs: cH,
    iridescence_fragment: fH,
    bumpmap_pars_fragment: hH,
    clipping_planes_fragment: dH,
    clipping_planes_pars_fragment: pH,
    clipping_planes_pars_vertex: mH,
    clipping_planes_vertex: gH,
    color_fragment: _H,
    color_pars_fragment: vH,
    color_pars_vertex: yH,
    color_vertex: xH,
    common: SH,
    cube_uv_reflection_fragment: AH,
    defaultnormal_vertex: MH,
    displacementmap_pars_vertex: EH,
    displacementmap_vertex: wH,
    emissivemap_fragment: CH,
    emissivemap_pars_fragment: TH,
    colorspace_fragment: bH,
    colorspace_pars_fragment: RH,
    envmap_fragment: PH,
    envmap_common_pars_fragment: BH,
    envmap_pars_fragment: LH,
    envmap_pars_vertex: IH,
    envmap_physical_pars_fragment: jH,
    envmap_vertex: DH,
    fog_vertex: FH,
    fog_pars_vertex: NH,
    fog_fragment: OH,
    fog_pars_fragment: UH,
    gradientmap_pars_fragment: kH,
    lightmap_fragment: zH,
    lightmap_pars_fragment: HH,
    lights_lambert_fragment: GH,
    lights_lambert_pars_fragment: VH,
    lights_pars_begin: WH,
    lights_toon_fragment: XH,
    lights_toon_pars_fragment: JH,
    lights_phong_fragment: KH,
    lights_phong_pars_fragment: YH,
    lights_physical_fragment: QH,
    lights_physical_pars_fragment: qH,
    lights_fragment_begin: ZH,
    lights_fragment_maps: $H,
    lights_fragment_end: eG,
    logdepthbuf_fragment: tG,
    logdepthbuf_pars_fragment: nG,
    logdepthbuf_pars_vertex: rG,
    logdepthbuf_vertex: iG,
    map_fragment: sG,
    map_pars_fragment: oG,
    map_particle_fragment: aG,
    map_particle_pars_fragment: lG,
    metalnessmap_fragment: uG,
    metalnessmap_pars_fragment: cG,
    morphcolor_vertex: fG,
    morphnormal_vertex: hG,
    morphtarget_pars_vertex: dG,
    morphtarget_vertex: pG,
    normal_fragment_begin: mG,
    normal_fragment_maps: gG,
    normal_pars_fragment: _G,
    normal_pars_vertex: vG,
    normal_vertex: yG,
    normalmap_pars_fragment: xG,
    clearcoat_normal_fragment_begin: SG,
    clearcoat_normal_fragment_maps: AG,
    clearcoat_pars_fragment: MG,
    iridescence_pars_fragment: EG,
    opaque_fragment: wG,
    packing: CG,
    premultiplied_alpha_fragment: TG,
    project_vertex: bG,
    dithering_fragment: RG,
    dithering_pars_fragment: PG,
    roughnessmap_fragment: BG,
    roughnessmap_pars_fragment: LG,
    shadowmap_pars_fragment: IG,
    shadowmap_pars_vertex: DG,
    shadowmap_vertex: FG,
    shadowmask_pars_fragment: NG,
    skinbase_vertex: OG,
    skinning_pars_vertex: UG,
    skinning_vertex: kG,
    skinnormal_vertex: zG,
    specularmap_fragment: HG,
    specularmap_pars_fragment: GG,
    tonemapping_fragment: VG,
    tonemapping_pars_fragment: WG,
    transmission_fragment: jG,
    transmission_pars_fragment: XG,
    uv_pars_fragment: JG,
    uv_pars_vertex: KG,
    uv_vertex: YG,
    worldpos_vertex: QG,
    background_vert: qG,
    background_frag: ZG,
    backgroundCube_vert: $G,
    backgroundCube_frag: e4,
    cube_vert: t4,
    cube_frag: n4,
    depth_vert: r4,
    depth_frag: i4,
    distanceRGBA_vert: s4,
    distanceRGBA_frag: o4,
    equirect_vert: a4,
    equirect_frag: l4,
    linedashed_vert: u4,
    linedashed_frag: c4,
    meshbasic_vert: f4,
    meshbasic_frag: h4,
    meshlambert_vert: d4,
    meshlambert_frag: p4,
    meshmatcap_vert: m4,
    meshmatcap_frag: g4,
    meshnormal_vert: _4,
    meshnormal_frag: v4,
    meshphong_vert: y4,
    meshphong_frag: x4,
    meshphysical_vert: S4,
    meshphysical_frag: A4,
    meshtoon_vert: M4,
    meshtoon_frag: E4,
    points_vert: w4,
    points_frag: C4,
    shadow_vert: T4,
    shadow_frag: b4,
    sprite_vert: R4,
    sprite_frag: P4,
  },
  be = {
    common: {
      diffuse: { value: new Be(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new _t() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new _t() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new _t() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new _t() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new _t() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new _t() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new _t() },
      normalScale: { value: new ge(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new _t() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new _t() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new _t() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new _t() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Be(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Be(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new _t() },
      alphaTest: { value: 0 },
      uvTransform: { value: new _t() },
    },
    sprite: {
      diffuse: { value: new Be(16777215) },
      opacity: { value: 1 },
      center: { value: new ge(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new _t() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new _t() },
      alphaTest: { value: 0 },
    },
  },
  ts = {
    basic: {
      uniforms: Er([
        be.common,
        be.specularmap,
        be.envmap,
        be.aomap,
        be.lightmap,
        be.fog,
      ]),
      vertexShader: pt.meshbasic_vert,
      fragmentShader: pt.meshbasic_frag,
    },
    lambert: {
      uniforms: Er([
        be.common,
        be.specularmap,
        be.envmap,
        be.aomap,
        be.lightmap,
        be.emissivemap,
        be.bumpmap,
        be.normalmap,
        be.displacementmap,
        be.fog,
        be.lights,
        { emissive: { value: new Be(0) } },
      ]),
      vertexShader: pt.meshlambert_vert,
      fragmentShader: pt.meshlambert_frag,
    },
    phong: {
      uniforms: Er([
        be.common,
        be.specularmap,
        be.envmap,
        be.aomap,
        be.lightmap,
        be.emissivemap,
        be.bumpmap,
        be.normalmap,
        be.displacementmap,
        be.fog,
        be.lights,
        {
          emissive: { value: new Be(0) },
          specular: { value: new Be(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: pt.meshphong_vert,
      fragmentShader: pt.meshphong_frag,
    },
    standard: {
      uniforms: Er([
        be.common,
        be.envmap,
        be.aomap,
        be.lightmap,
        be.emissivemap,
        be.bumpmap,
        be.normalmap,
        be.displacementmap,
        be.roughnessmap,
        be.metalnessmap,
        be.fog,
        be.lights,
        {
          emissive: { value: new Be(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: pt.meshphysical_vert,
      fragmentShader: pt.meshphysical_frag,
    },
    toon: {
      uniforms: Er([
        be.common,
        be.aomap,
        be.lightmap,
        be.emissivemap,
        be.bumpmap,
        be.normalmap,
        be.displacementmap,
        be.gradientmap,
        be.fog,
        be.lights,
        { emissive: { value: new Be(0) } },
      ]),
      vertexShader: pt.meshtoon_vert,
      fragmentShader: pt.meshtoon_frag,
    },
    matcap: {
      uniforms: Er([
        be.common,
        be.bumpmap,
        be.normalmap,
        be.displacementmap,
        be.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: pt.meshmatcap_vert,
      fragmentShader: pt.meshmatcap_frag,
    },
    points: {
      uniforms: Er([be.points, be.fog]),
      vertexShader: pt.points_vert,
      fragmentShader: pt.points_frag,
    },
    dashed: {
      uniforms: Er([
        be.common,
        be.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: pt.linedashed_vert,
      fragmentShader: pt.linedashed_frag,
    },
    depth: {
      uniforms: Er([be.common, be.displacementmap]),
      vertexShader: pt.depth_vert,
      fragmentShader: pt.depth_frag,
    },
    normal: {
      uniforms: Er([
        be.common,
        be.bumpmap,
        be.normalmap,
        be.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: pt.meshnormal_vert,
      fragmentShader: pt.meshnormal_frag,
    },
    sprite: {
      uniforms: Er([be.sprite, be.fog]),
      vertexShader: pt.sprite_vert,
      fragmentShader: pt.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new _t() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: pt.background_vert,
      fragmentShader: pt.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: pt.backgroundCube_vert,
      fragmentShader: pt.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: pt.cube_vert,
      fragmentShader: pt.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: pt.equirect_vert,
      fragmentShader: pt.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Er([
        be.common,
        be.displacementmap,
        {
          referencePosition: { value: new U() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: pt.distanceRGBA_vert,
      fragmentShader: pt.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Er([
        be.lights,
        be.fog,
        { color: { value: new Be(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: pt.shadow_vert,
      fragmentShader: pt.shadow_frag,
    },
  };
ts.physical = {
  uniforms: Er([
    ts.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new _t() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new _t() },
      clearcoatNormalScale: { value: new ge(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new _t() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new _t() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new _t() },
      sheen: { value: 0 },
      sheenColor: { value: new Be(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new _t() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new _t() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new _t() },
      transmissionSamplerSize: { value: new ge() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new _t() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Be(0) },
      specularColor: { value: new Be(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new _t() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new _t() },
      anisotropyVector: { value: new ge() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new _t() },
    },
  ]),
  vertexShader: pt.meshphysical_vert,
  fragmentShader: pt.meshphysical_frag,
};
const $p = { r: 0, b: 0, g: 0 };
function B4(n, e, t, r, i, s, o) {
  const a = new Be(0);
  let l = s === !0 ? 0 : 1,
    u,
    h,
    d = null,
    p = 0,
    m = null;
  function _(x, g) {
    let S = !1,
      A = g.isScene === !0 ? g.background : null;
    switch (
      (A && A.isTexture && (A = (g.backgroundBlurriness > 0 ? t : e).get(A)),
      A === null ? y(a, l) : A && A.isColor && (y(A, 1), (S = !0)),
      n.xr.getEnvironmentBlendMode())
    ) {
      case "opaque":
        S = !0;
        break;
      case "additive":
        r.buffers.color.setClear(0, 0, 0, 1, o), (S = !0);
        break;
      case "alpha-blend":
        r.buffers.color.setClear(0, 0, 0, 0, o), (S = !0);
        break;
    }
    (n.autoClear || S) &&
      n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
      A && (A.isCubeTexture || A.mapping === Gc)
        ? (h === void 0 &&
            ((h = new kn(
              new zl(1, 1, 1),
              new Os({
                name: "BackgroundCubeMaterial",
                uniforms: wc(ts.backgroundCube.uniforms),
                vertexShader: ts.backgroundCube.vertexShader,
                fragmentShader: ts.backgroundCube.fragmentShader,
                side: Tr,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            h.geometry.deleteAttribute("normal"),
            h.geometry.deleteAttribute("uv"),
            (h.onBeforeRender = function (R, P, L) {
              this.matrixWorld.copyPosition(L.matrixWorld);
            }),
            Object.defineProperty(h.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            i.update(h)),
          (h.material.uniforms.envMap.value = A),
          (h.material.uniforms.flipEnvMap.value =
            A.isCubeTexture && A.isRenderTargetTexture === !1 ? -1 : 1),
          (h.material.uniforms.backgroundBlurriness.value =
            g.backgroundBlurriness),
          (h.material.uniforms.backgroundIntensity.value =
            g.backgroundIntensity),
          (h.material.toneMapped = A.colorSpace !== ht),
          (d !== A || p !== A.version || m !== n.toneMapping) &&
            ((h.material.needsUpdate = !0),
            (d = A),
            (p = A.version),
            (m = n.toneMapping)),
          h.layers.enableAll(),
          x.unshift(h, h.geometry, h.material, 0, 0, null))
        : A &&
          A.isTexture &&
          (u === void 0 &&
            ((u = new kn(
              new cd(2, 2),
              new Os({
                name: "BackgroundMaterial",
                uniforms: wc(ts.background.uniforms),
                vertexShader: ts.background.vertexShader,
                fragmentShader: ts.background.fragmentShader,
                side: Fs,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            u.geometry.deleteAttribute("normal"),
            Object.defineProperty(u.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            i.update(u)),
          (u.material.uniforms.t2D.value = A),
          (u.material.uniforms.backgroundIntensity.value =
            g.backgroundIntensity),
          (u.material.toneMapped = A.colorSpace !== ht),
          A.matrixAutoUpdate === !0 && A.updateMatrix(),
          u.material.uniforms.uvTransform.value.copy(A.matrix),
          (d !== A || p !== A.version || m !== n.toneMapping) &&
            ((u.material.needsUpdate = !0),
            (d = A),
            (p = A.version),
            (m = n.toneMapping)),
          u.layers.enableAll(),
          x.unshift(u, u.geometry, u.material, 0, 0, null));
  }
  function y(x, g) {
    x.getRGB($p, L2(n)), r.buffers.color.setClear($p.r, $p.g, $p.b, g, o);
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (x, g = 1) {
      a.set(x), (l = g), y(a, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (x) {
      (l = x), y(a, l);
    },
    render: _,
  };
}
function L4(n, e, t, r) {
  const i = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    s = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    o = r.isWebGL2 || s !== null,
    a = {},
    l = x(null);
  let u = l,
    h = !1;
  function d(k, j, Z, Q, N) {
    let W = !1;
    if (o) {
      const G = y(Q, Z, j);
      u !== G && ((u = G), m(u.object)),
        (W = g(k, Q, Z, N)),
        W && S(k, Q, Z, N);
    } else {
      const G = j.wireframe === !0;
      (u.geometry !== Q.id || u.program !== Z.id || u.wireframe !== G) &&
        ((u.geometry = Q.id), (u.program = Z.id), (u.wireframe = G), (W = !0));
    }
    N !== null && t.update(N, n.ELEMENT_ARRAY_BUFFER),
      (W || h) &&
        ((h = !1),
        L(k, j, Z, Q),
        N !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(N).buffer));
  }
  function p() {
    return r.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES();
  }
  function m(k) {
    return r.isWebGL2 ? n.bindVertexArray(k) : s.bindVertexArrayOES(k);
  }
  function _(k) {
    return r.isWebGL2 ? n.deleteVertexArray(k) : s.deleteVertexArrayOES(k);
  }
  function y(k, j, Z) {
    const Q = Z.wireframe === !0;
    let N = a[k.id];
    N === void 0 && ((N = {}), (a[k.id] = N));
    let W = N[j.id];
    W === void 0 && ((W = {}), (N[j.id] = W));
    let G = W[Q];
    return G === void 0 && ((G = x(p())), (W[Q] = G)), G;
  }
  function x(k) {
    const j = [],
      Z = [],
      Q = [];
    for (let N = 0; N < i; N++) (j[N] = 0), (Z[N] = 0), (Q[N] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: j,
      enabledAttributes: Z,
      attributeDivisors: Q,
      object: k,
      attributes: {},
      index: null,
    };
  }
  function g(k, j, Z, Q) {
    const N = u.attributes,
      W = j.attributes;
    let G = 0;
    const X = Z.getAttributes();
    for (const Y in X)
      if (X[Y].location >= 0) {
        const ae = N[Y];
        let ye = W[Y];
        if (
          (ye === void 0 &&
            (Y === "instanceMatrix" &&
              k.instanceMatrix &&
              (ye = k.instanceMatrix),
            Y === "instanceColor" && k.instanceColor && (ye = k.instanceColor)),
          ae === void 0 || ae.attribute !== ye || (ye && ae.data !== ye.data))
        )
          return !0;
        G++;
      }
    return u.attributesNum !== G || u.index !== Q;
  }
  function S(k, j, Z, Q) {
    const N = {},
      W = j.attributes;
    let G = 0;
    const X = Z.getAttributes();
    for (const Y in X)
      if (X[Y].location >= 0) {
        let ae = W[Y];
        ae === void 0 &&
          (Y === "instanceMatrix" &&
            k.instanceMatrix &&
            (ae = k.instanceMatrix),
          Y === "instanceColor" && k.instanceColor && (ae = k.instanceColor));
        const ye = {};
        (ye.attribute = ae),
          ae && ae.data && (ye.data = ae.data),
          (N[Y] = ye),
          G++;
      }
    (u.attributes = N), (u.attributesNum = G), (u.index = Q);
  }
  function A() {
    const k = u.newAttributes;
    for (let j = 0, Z = k.length; j < Z; j++) k[j] = 0;
  }
  function E(k) {
    C(k, 0);
  }
  function C(k, j) {
    const Z = u.newAttributes,
      Q = u.enabledAttributes,
      N = u.attributeDivisors;
    (Z[k] = 1),
      Q[k] === 0 && (n.enableVertexAttribArray(k), (Q[k] = 1)),
      N[k] !== j &&
        ((r.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[
          r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](k, j),
        (N[k] = j));
  }
  function R() {
    const k = u.newAttributes,
      j = u.enabledAttributes;
    for (let Z = 0, Q = j.length; Z < Q; Z++)
      j[Z] !== k[Z] && (n.disableVertexAttribArray(Z), (j[Z] = 0));
  }
  function P(k, j, Z, Q, N, W, G) {
    G === !0
      ? n.vertexAttribIPointer(k, j, Z, N, W)
      : n.vertexAttribPointer(k, j, Z, Q, N, W);
  }
  function L(k, j, Z, Q) {
    if (
      r.isWebGL2 === !1 &&
      (k.isInstancedMesh || Q.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    A();
    const N = Q.attributes,
      W = Z.getAttributes(),
      G = j.defaultAttributeValues;
    for (const X in W) {
      const Y = W[X];
      if (Y.location >= 0) {
        let de = N[X];
        if (
          (de === void 0 &&
            (X === "instanceMatrix" &&
              k.instanceMatrix &&
              (de = k.instanceMatrix),
            X === "instanceColor" && k.instanceColor && (de = k.instanceColor)),
          de !== void 0)
        ) {
          const ae = de.normalized,
            ye = de.itemSize,
            we = t.get(de);
          if (we === void 0) continue;
          const Ne = we.buffer,
            je = we.type,
            At = we.bytesPerElement,
            lt =
              r.isWebGL2 === !0 &&
              (je === n.INT || je === n.UNSIGNED_INT || de.gpuType === qA);
          if (de.isInterleavedBufferAttribute) {
            const Ce = de.data,
              K = Ce.stride,
              _e = de.offset;
            if (Ce.isInstancedInterleavedBuffer) {
              for (let pe = 0; pe < Y.locationSize; pe++)
                C(Y.location + pe, Ce.meshPerAttribute);
              k.isInstancedMesh !== !0 &&
                Q._maxInstanceCount === void 0 &&
                (Q._maxInstanceCount = Ce.meshPerAttribute * Ce.count);
            } else
              for (let pe = 0; pe < Y.locationSize; pe++) E(Y.location + pe);
            n.bindBuffer(n.ARRAY_BUFFER, Ne);
            for (let pe = 0; pe < Y.locationSize; pe++)
              P(
                Y.location + pe,
                ye / Y.locationSize,
                je,
                ae,
                K * At,
                (_e + (ye / Y.locationSize) * pe) * At,
                lt
              );
          } else {
            if (de.isInstancedBufferAttribute) {
              for (let Ce = 0; Ce < Y.locationSize; Ce++)
                C(Y.location + Ce, de.meshPerAttribute);
              k.isInstancedMesh !== !0 &&
                Q._maxInstanceCount === void 0 &&
                (Q._maxInstanceCount = de.meshPerAttribute * de.count);
            } else
              for (let Ce = 0; Ce < Y.locationSize; Ce++) E(Y.location + Ce);
            n.bindBuffer(n.ARRAY_BUFFER, Ne);
            for (let Ce = 0; Ce < Y.locationSize; Ce++)
              P(
                Y.location + Ce,
                ye / Y.locationSize,
                je,
                ae,
                ye * At,
                (ye / Y.locationSize) * Ce * At,
                lt
              );
          }
        } else if (G !== void 0) {
          const ae = G[X];
          if (ae !== void 0)
            switch (ae.length) {
              case 2:
                n.vertexAttrib2fv(Y.location, ae);
                break;
              case 3:
                n.vertexAttrib3fv(Y.location, ae);
                break;
              case 4:
                n.vertexAttrib4fv(Y.location, ae);
                break;
              default:
                n.vertexAttrib1fv(Y.location, ae);
            }
        }
      }
    }
    R();
  }
  function T() {
    I();
    for (const k in a) {
      const j = a[k];
      for (const Z in j) {
        const Q = j[Z];
        for (const N in Q) _(Q[N].object), delete Q[N];
        delete j[Z];
      }
      delete a[k];
    }
  }
  function B(k) {
    if (a[k.id] === void 0) return;
    const j = a[k.id];
    for (const Z in j) {
      const Q = j[Z];
      for (const N in Q) _(Q[N].object), delete Q[N];
      delete j[Z];
    }
    delete a[k.id];
  }
  function D(k) {
    for (const j in a) {
      const Z = a[j];
      if (Z[k.id] === void 0) continue;
      const Q = Z[k.id];
      for (const N in Q) _(Q[N].object), delete Q[N];
      delete Z[k.id];
    }
  }
  function I() {
    F(), (h = !0), u !== l && ((u = l), m(u.object));
  }
  function F() {
    (l.geometry = null), (l.program = null), (l.wireframe = !1);
  }
  return {
    setup: d,
    reset: I,
    resetDefaultState: F,
    dispose: T,
    releaseStatesOfGeometry: B,
    releaseStatesOfProgram: D,
    initAttributes: A,
    enableAttribute: E,
    disableUnusedAttributes: R,
  };
}
function I4(n, e, t, r) {
  const i = r.isWebGL2;
  let s;
  function o(u) {
    s = u;
  }
  function a(u, h) {
    n.drawArrays(s, u, h), t.update(h, s, 1);
  }
  function l(u, h, d) {
    if (d === 0) return;
    let p, m;
    if (i) (p = n), (m = "drawArraysInstanced");
    else if (
      ((p = e.get("ANGLE_instanced_arrays")),
      (m = "drawArraysInstancedANGLE"),
      p === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    p[m](s, u, h, d), t.update(h, s, d);
  }
  (this.setMode = o), (this.render = a), (this.renderInstances = l);
}
function D4(n, e, t) {
  let r;
  function i() {
    if (r !== void 0) return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const P = e.get("EXT_texture_filter_anisotropic");
      r = n.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else r = 0;
    return r;
  }
  function s(P) {
    if (P === "highp") {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision >
          0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      P = "mediump";
    }
    return P === "mediump" &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision >
        0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  const o =
    typeof WebGL2RenderingContext < "u" &&
    n.constructor.name === "WebGL2RenderingContext";
  let a = t.precision !== void 0 ? t.precision : "highp";
  const l = s(a);
  l !== a &&
    (console.warn(
      "THREE.WebGLRenderer:",
      a,
      "not supported, using",
      l,
      "instead."
    ),
    (a = l));
  const u = o || e.has("WEBGL_draw_buffers"),
    h = t.logarithmicDepthBuffer === !0,
    d = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    p = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    m = n.getParameter(n.MAX_TEXTURE_SIZE),
    _ = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    y = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    x = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    g = n.getParameter(n.MAX_VARYING_VECTORS),
    S = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    A = p > 0,
    E = o || e.has("OES_texture_float"),
    C = A && E,
    R = o ? n.getParameter(n.MAX_SAMPLES) : 0;
  return {
    isWebGL2: o,
    drawBuffers: u,
    getMaxAnisotropy: i,
    getMaxPrecision: s,
    precision: a,
    logarithmicDepthBuffer: h,
    maxTextures: d,
    maxVertexTextures: p,
    maxTextureSize: m,
    maxCubemapSize: _,
    maxAttributes: y,
    maxVertexUniforms: x,
    maxVaryings: g,
    maxFragmentUniforms: S,
    vertexTextures: A,
    floatFragmentTextures: E,
    floatVertexTextures: C,
    maxSamples: R,
  };
}
function F4(n) {
  const e = this;
  let t = null,
    r = 0,
    i = !1,
    s = !1;
  const o = new Wo(),
    a = new _t(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (d, p) {
      const m = d.length !== 0 || p || r !== 0 || i;
      return (i = p), (r = d.length), m;
    }),
    (this.beginShadows = function () {
      (s = !0), h(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (d, p) {
      t = h(d, p, 0);
    }),
    (this.setState = function (d, p, m) {
      const _ = d.clippingPlanes,
        y = d.clipIntersection,
        x = d.clipShadows,
        g = n.get(d);
      if (!i || _ === null || _.length === 0 || (s && !x)) s ? h(null) : u();
      else {
        const S = s ? 0 : r,
          A = S * 4;
        let E = g.clippingState || null;
        (l.value = E), (E = h(_, p, A, m));
        for (let C = 0; C !== A; ++C) E[C] = t[C];
        (g.clippingState = E),
          (this.numIntersection = y ? this.numPlanes : 0),
          (this.numPlanes += S);
      }
    });
  function u() {
    l.value !== t && ((l.value = t), (l.needsUpdate = r > 0)),
      (e.numPlanes = r),
      (e.numIntersection = 0);
  }
  function h(d, p, m, _) {
    const y = d !== null ? d.length : 0;
    let x = null;
    if (y !== 0) {
      if (((x = l.value), _ !== !0 || x === null)) {
        const g = m + y * 4,
          S = p.matrixWorldInverse;
        a.getNormalMatrix(S),
          (x === null || x.length < g) && (x = new Float32Array(g));
        for (let A = 0, E = m; A !== y; ++A, E += 4)
          o.copy(d[A]).applyMatrix4(S, a),
            o.normal.toArray(x, E),
            (x[E + 3] = o.constant);
      }
      (l.value = x), (l.needsUpdate = !0);
    }
    return (e.numPlanes = y), (e.numIntersection = 0), x;
  }
}
function N4(n) {
  let e = new WeakMap();
  function t(o, a) {
    return a === Ph ? (o.mapping = va) : a === Bh && (o.mapping = ya), o;
  }
  function r(o) {
    if (o && o.isTexture && o.isRenderTargetTexture === !1) {
      const a = o.mapping;
      if (a === Ph || a === Bh)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const u = new F2(l.height / 2);
            return (
              u.fromEquirectangularTexture(n, o),
              e.set(o, u),
              o.addEventListener("dispose", i),
              t(u.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function i(o) {
    const a = o.target;
    a.removeEventListener("dispose", i);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: r, dispose: s };
}
class Ra extends ld {
  constructor(e = -1, t = 1, r = 1, i = -1, s = 0.1, o = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = r),
      (this.bottom = i),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, r, i, s, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      r = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let s = r - e,
      o = r + e,
      a = i + t,
      l = i - t;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom,
        h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += u * this.view.offsetX),
        (o = s + u * this.view.width),
        (a -= h * this.view.offsetY),
        (l = a - h * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      o,
      a,
      l,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const Ku = 4,
  LC = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  al = 20,
  qv = new Ra(),
  IC = new Be();
let Zv = null;
const rl = (1 + Math.sqrt(5)) / 2,
  Au = 1 / rl,
  DC = [
    new U(1, 1, 1),
    new U(-1, 1, 1),
    new U(1, 1, -1),
    new U(-1, 1, -1),
    new U(0, rl, Au),
    new U(0, rl, -Au),
    new U(Au, 0, rl),
    new U(-Au, 0, rl),
    new U(rl, Au, 0),
    new U(-rl, Au, 0),
  ];
class _S {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, r = 0.1, i = 100) {
    (Zv = this._renderer.getRenderTarget()), this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, r, i, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = OC()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = NC()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Zv),
      (e.scissorTest = !1),
      em(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === va || e.mapping === ya
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (Zv = this._renderer.getRenderTarget());
    const r = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      r = {
        magFilter: sn,
        minFilter: sn,
        generateMipmaps: !1,
        type: Ac,
        format: Nr,
        colorSpace: as,
        depthBuffer: !1,
      },
      i = FC(e, t, r);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = FC(e, t, r));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = O4(s)),
        (this._blurMaterial = U4(s, e, t));
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new kn(this._lodPlanes[0], e);
    this._renderer.compile(t, qv);
  }
  _sceneToCubeUV(e, t, r, i) {
    const a = new Mn(90, 1, t, r),
      l = [1, -1, 1, 1, 1, 1],
      u = [1, 1, 1, -1, -1, -1],
      h = this._renderer,
      d = h.autoClear,
      p = h.toneMapping;
    h.getClearColor(IC), (h.toneMapping = is), (h.autoClear = !1);
    const m = new kr({
        name: "PMREM.Background",
        side: Tr,
        depthWrite: !1,
        depthTest: !1,
      }),
      _ = new kn(new zl(), m);
    let y = !1;
    const x = e.background;
    x
      ? x.isColor && (m.color.copy(x), (e.background = null), (y = !0))
      : (m.color.copy(IC), (y = !0));
    for (let g = 0; g < 6; g++) {
      const S = g % 3;
      S === 0
        ? (a.up.set(0, l[g], 0), a.lookAt(u[g], 0, 0))
        : S === 1
        ? (a.up.set(0, 0, l[g]), a.lookAt(0, u[g], 0))
        : (a.up.set(0, l[g], 0), a.lookAt(0, 0, u[g]));
      const A = this._cubeSize;
      em(i, S * A, g > 2 ? A : 0, A, A),
        h.setRenderTarget(i),
        y && h.render(_, a),
        h.render(e, a);
    }
    _.geometry.dispose(),
      _.material.dispose(),
      (h.toneMapping = p),
      (h.autoClear = d),
      (e.background = x);
  }
  _textureToCubeUV(e, t) {
    const r = this._renderer,
      i = e.mapping === va || e.mapping === ya;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = OC()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = NC());
    const s = i ? this._cubemapMaterial : this._equirectMaterial,
      o = new kn(this._lodPlanes[0], s),
      a = s.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    em(t, 0, 0, 3 * l, 2 * l), r.setRenderTarget(t), r.render(o, qv);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      r = t.autoClear;
    t.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const s = Math.sqrt(
          this._sigmas[i] * this._sigmas[i] -
            this._sigmas[i - 1] * this._sigmas[i - 1]
        ),
        o = DC[(i - 1) % DC.length];
      this._blur(e, i - 1, i, s, o);
    }
    t.autoClear = r;
  }
  _blur(e, t, r, i, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, t, r, i, "latitudinal", s),
      this._halfBlur(o, e, r, r, i, "longitudinal", s);
  }
  _halfBlur(e, t, r, i, s, o, a) {
    const l = this._renderer,
      u = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const h = 3,
      d = new kn(this._lodPlanes[i], u),
      p = u.uniforms,
      m = this._sizeLods[r] - 1,
      _ = isFinite(s) ? Math.PI / (2 * m) : (2 * Math.PI) / (2 * al - 1),
      y = s / _,
      x = isFinite(s) ? 1 + Math.floor(h * y) : al;
    x > al &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${al}`
      );
    const g = [];
    let S = 0;
    for (let P = 0; P < al; ++P) {
      const L = P / y,
        T = Math.exp((-L * L) / 2);
      g.push(T), P === 0 ? (S += T) : P < x && (S += 2 * T);
    }
    for (let P = 0; P < g.length; P++) g[P] = g[P] / S;
    (p.envMap.value = e.texture),
      (p.samples.value = x),
      (p.weights.value = g),
      (p.latitudinal.value = o === "latitudinal"),
      a && (p.poleAxis.value = a);
    const { _lodMax: A } = this;
    (p.dTheta.value = _), (p.mipInt.value = A - r);
    const E = this._sizeLods[i],
      C = 3 * E * (i > A - Ku ? i - A + Ku : 0),
      R = 4 * (this._cubeSize - E);
    em(t, C, R, 3 * E, 2 * E), l.setRenderTarget(t), l.render(d, qv);
  }
}
function O4(n) {
  const e = [],
    t = [],
    r = [];
  let i = n;
  const s = n - Ku + 1 + LC.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, i);
    t.push(a);
    let l = 1 / a;
    o > n - Ku ? (l = LC[o - n + Ku - 1]) : o === 0 && (l = 0), r.push(l);
    const u = 1 / (a - 2),
      h = -u,
      d = 1 + u,
      p = [h, h, d, h, d, d, h, h, d, d, h, d],
      m = 6,
      _ = 6,
      y = 3,
      x = 2,
      g = 1,
      S = new Float32Array(y * _ * m),
      A = new Float32Array(x * _ * m),
      E = new Float32Array(g * _ * m);
    for (let R = 0; R < m; R++) {
      const P = ((R % 3) * 2) / 3 - 1,
        L = R > 2 ? 0 : -1,
        T = [
          P,
          L,
          0,
          P + 2 / 3,
          L,
          0,
          P + 2 / 3,
          L + 1,
          0,
          P,
          L,
          0,
          P + 2 / 3,
          L + 1,
          0,
          P,
          L + 1,
          0,
        ];
      S.set(T, y * _ * R), A.set(p, x * _ * R);
      const B = [R, R, R, R, R, R];
      E.set(B, g * _ * R);
    }
    const C = new dt();
    C.setAttribute("position", new Dt(S, y)),
      C.setAttribute("uv", new Dt(A, x)),
      C.setAttribute("faceIndex", new Dt(E, g)),
      e.push(C),
      i > Ku && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: r };
}
function FC(n, e, t) {
  const r = new ls(n, e, t);
  return (
    (r.texture.mapping = Gc),
    (r.texture.name = "PMREM.cubeUv"),
    (r.scissorTest = !0),
    r
  );
}
function em(n, e, t, r, i) {
  n.viewport.set(e, t, r, i), n.scissor.set(e, t, r, i);
}
function U4(n, e, t) {
  const r = new Float32Array(al),
    i = new U(0, 1, 0);
  return new Os({
    name: "SphericalGaussianBlur",
    defines: {
      n: al,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: h1(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: ho,
    depthTest: !1,
    depthWrite: !1,
  });
}
function NC() {
  return new Os({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: h1(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: ho,
    depthTest: !1,
    depthWrite: !1,
  });
}
function OC() {
  return new Os({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: h1(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: ho,
    depthTest: !1,
    depthWrite: !1,
  });
}
function h1() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function k4(n) {
  let e = new WeakMap(),
    t = null;
  function r(a) {
    if (a && a.isTexture) {
      const l = a.mapping,
        u = l === Ph || l === Bh,
        h = l === va || l === ya;
      if (u || h)
        if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
          a.needsPMREMUpdate = !1;
          let d = e.get(a);
          return (
            t === null && (t = new _S(n)),
            (d = u ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d)),
            e.set(a, d),
            d.texture
          );
        } else {
          if (e.has(a)) return e.get(a).texture;
          {
            const d = a.image;
            if ((u && d && d.height > 0) || (h && d && i(d))) {
              t === null && (t = new _S(n));
              const p = u ? t.fromEquirectangular(a) : t.fromCubemap(a);
              return e.set(a, p), a.addEventListener("dispose", s), p.texture;
            } else return null;
          }
        }
    }
    return a;
  }
  function i(a) {
    let l = 0;
    const u = 6;
    for (let h = 0; h < u; h++) a[h] !== void 0 && l++;
    return l === u;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const u = e.get(l);
    u !== void 0 && (e.delete(l), u.dispose());
  }
  function o() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: r, dispose: o };
}
function z4(n) {
  const e = {};
  function t(r) {
    if (e[r] !== void 0) return e[r];
    let i;
    switch (r) {
      case "WEBGL_depth_texture":
        i =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = n.getExtension(r);
    }
    return (e[r] = i), i;
  }
  return {
    has: function (r) {
      return t(r) !== null;
    },
    init: function (r) {
      r.isWebGL2
        ? t("EXT_color_buffer_float")
        : (t("WEBGL_depth_texture"),
          t("OES_texture_float"),
          t("OES_texture_half_float"),
          t("OES_texture_half_float_linear"),
          t("OES_standard_derivatives"),
          t("OES_element_index_uint"),
          t("OES_vertex_array_object"),
          t("ANGLE_instanced_arrays")),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture");
    },
    get: function (r) {
      const i = t(r);
      return (
        i === null &&
          console.warn(
            "THREE.WebGLRenderer: " + r + " extension not supported."
          ),
        i
      );
    },
  };
}
function H4(n, e, t, r) {
  const i = {},
    s = new WeakMap();
  function o(d) {
    const p = d.target;
    p.index !== null && e.remove(p.index);
    for (const _ in p.attributes) e.remove(p.attributes[_]);
    for (const _ in p.morphAttributes) {
      const y = p.morphAttributes[_];
      for (let x = 0, g = y.length; x < g; x++) e.remove(y[x]);
    }
    p.removeEventListener("dispose", o), delete i[p.id];
    const m = s.get(p);
    m && (e.remove(m), s.delete(p)),
      r.releaseStatesOfGeometry(p),
      p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
      t.memory.geometries--;
  }
  function a(d, p) {
    return (
      i[p.id] === !0 ||
        (p.addEventListener("dispose", o),
        (i[p.id] = !0),
        t.memory.geometries++),
      p
    );
  }
  function l(d) {
    const p = d.attributes;
    for (const _ in p) e.update(p[_], n.ARRAY_BUFFER);
    const m = d.morphAttributes;
    for (const _ in m) {
      const y = m[_];
      for (let x = 0, g = y.length; x < g; x++) e.update(y[x], n.ARRAY_BUFFER);
    }
  }
  function u(d) {
    const p = [],
      m = d.index,
      _ = d.attributes.position;
    let y = 0;
    if (m !== null) {
      const S = m.array;
      y = m.version;
      for (let A = 0, E = S.length; A < E; A += 3) {
        const C = S[A + 0],
          R = S[A + 1],
          P = S[A + 2];
        p.push(C, R, R, P, P, C);
      }
    } else {
      const S = _.array;
      y = _.version;
      for (let A = 0, E = S.length / 3 - 1; A < E; A += 3) {
        const C = A + 0,
          R = A + 1,
          P = A + 2;
        p.push(C, R, R, P, P, C);
      }
    }
    const x = new (P2(p) ? f1 : c1)(p, 1);
    x.version = y;
    const g = s.get(d);
    g && e.remove(g), s.set(d, x);
  }
  function h(d) {
    const p = s.get(d);
    if (p) {
      const m = d.index;
      m !== null && p.version < m.version && u(d);
    } else u(d);
    return s.get(d);
  }
  return { get: a, update: l, getWireframeAttribute: h };
}
function G4(n, e, t, r) {
  const i = r.isWebGL2;
  let s;
  function o(p) {
    s = p;
  }
  let a, l;
  function u(p) {
    (a = p.type), (l = p.bytesPerElement);
  }
  function h(p, m) {
    n.drawElements(s, m, a, p * l), t.update(m, s, 1);
  }
  function d(p, m, _) {
    if (_ === 0) return;
    let y, x;
    if (i) (y = n), (x = "drawElementsInstanced");
    else if (
      ((y = e.get("ANGLE_instanced_arrays")),
      (x = "drawElementsInstancedANGLE"),
      y === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    y[x](s, m, a, p * l, _), t.update(m, s, _);
  }
  (this.setMode = o),
    (this.setIndex = u),
    (this.render = h),
    (this.renderInstances = d);
}
function V4(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function r(s, o, a) {
    switch ((t.calls++, o)) {
      case n.TRIANGLES:
        t.triangles += a * (s / 3);
        break;
      case n.LINES:
        t.lines += a * (s / 2);
        break;
      case n.LINE_STRIP:
        t.lines += a * (s - 1);
        break;
      case n.LINE_LOOP:
        t.lines += a * s;
        break;
      case n.POINTS:
        t.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function i() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: r,
  };
}
function W4(n, e) {
  return n[0] - e[0];
}
function j4(n, e) {
  return Math.abs(e[1]) - Math.abs(n[1]);
}
function X4(n, e, t) {
  const r = {},
    i = new Float32Array(8),
    s = new WeakMap(),
    o = new Nt(),
    a = [];
  for (let u = 0; u < 8; u++) a[u] = [u, 0];
  function l(u, h, d) {
    const p = u.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const _ =
          h.morphAttributes.position ||
          h.morphAttributes.normal ||
          h.morphAttributes.color,
        y = _ !== void 0 ? _.length : 0;
      let x = s.get(h);
      if (x === void 0 || x.count !== y) {
        let j = function () {
          F.dispose(), s.delete(h), h.removeEventListener("dispose", j);
        };
        var m = j;
        x !== void 0 && x.texture.dispose();
        const A = h.morphAttributes.position !== void 0,
          E = h.morphAttributes.normal !== void 0,
          C = h.morphAttributes.color !== void 0,
          R = h.morphAttributes.position || [],
          P = h.morphAttributes.normal || [],
          L = h.morphAttributes.color || [];
        let T = 0;
        A === !0 && (T = 1), E === !0 && (T = 2), C === !0 && (T = 3);
        let B = h.attributes.position.count * T,
          D = 1;
        B > e.maxTextureSize &&
          ((D = Math.ceil(B / e.maxTextureSize)), (B = e.maxTextureSize));
        const I = new Float32Array(B * D * 4 * y),
          F = new A0(I, B, D, y);
        (F.type = Cs), (F.needsUpdate = !0);
        const k = T * 4;
        for (let Z = 0; Z < y; Z++) {
          const Q = R[Z],
            N = P[Z],
            W = L[Z],
            G = B * D * 4 * Z;
          for (let X = 0; X < Q.count; X++) {
            const Y = X * k;
            A === !0 &&
              (o.fromBufferAttribute(Q, X),
              (I[G + Y + 0] = o.x),
              (I[G + Y + 1] = o.y),
              (I[G + Y + 2] = o.z),
              (I[G + Y + 3] = 0)),
              E === !0 &&
                (o.fromBufferAttribute(N, X),
                (I[G + Y + 4] = o.x),
                (I[G + Y + 5] = o.y),
                (I[G + Y + 6] = o.z),
                (I[G + Y + 7] = 0)),
              C === !0 &&
                (o.fromBufferAttribute(W, X),
                (I[G + Y + 8] = o.x),
                (I[G + Y + 9] = o.y),
                (I[G + Y + 10] = o.z),
                (I[G + Y + 11] = W.itemSize === 4 ? o.w : 1));
          }
        }
        (x = { count: y, texture: F, size: new ge(B, D) }),
          s.set(h, x),
          h.addEventListener("dispose", j);
      }
      let g = 0;
      for (let A = 0; A < p.length; A++) g += p[A];
      const S = h.morphTargetsRelative ? 1 : 1 - g;
      d.getUniforms().setValue(n, "morphTargetBaseInfluence", S),
        d.getUniforms().setValue(n, "morphTargetInfluences", p),
        d.getUniforms().setValue(n, "morphTargetsTexture", x.texture, t),
        d.getUniforms().setValue(n, "morphTargetsTextureSize", x.size);
    } else {
      const _ = p === void 0 ? 0 : p.length;
      let y = r[h.id];
      if (y === void 0 || y.length !== _) {
        y = [];
        for (let E = 0; E < _; E++) y[E] = [E, 0];
        r[h.id] = y;
      }
      for (let E = 0; E < _; E++) {
        const C = y[E];
        (C[0] = E), (C[1] = p[E]);
      }
      y.sort(j4);
      for (let E = 0; E < 8; E++)
        E < _ && y[E][1]
          ? ((a[E][0] = y[E][0]), (a[E][1] = y[E][1]))
          : ((a[E][0] = Number.MAX_SAFE_INTEGER), (a[E][1] = 0));
      a.sort(W4);
      const x = h.morphAttributes.position,
        g = h.morphAttributes.normal;
      let S = 0;
      for (let E = 0; E < 8; E++) {
        const C = a[E],
          R = C[0],
          P = C[1];
        R !== Number.MAX_SAFE_INTEGER && P
          ? (x &&
              h.getAttribute("morphTarget" + E) !== x[R] &&
              h.setAttribute("morphTarget" + E, x[R]),
            g &&
              h.getAttribute("morphNormal" + E) !== g[R] &&
              h.setAttribute("morphNormal" + E, g[R]),
            (i[E] = P),
            (S += P))
          : (x &&
              h.hasAttribute("morphTarget" + E) === !0 &&
              h.deleteAttribute("morphTarget" + E),
            g &&
              h.hasAttribute("morphNormal" + E) === !0 &&
              h.deleteAttribute("morphNormal" + E),
            (i[E] = 0));
      }
      const A = h.morphTargetsRelative ? 1 : 1 - S;
      d.getUniforms().setValue(n, "morphTargetBaseInfluence", A),
        d.getUniforms().setValue(n, "morphTargetInfluences", i);
    }
  }
  return { update: l };
}
function J4(n, e, t, r) {
  let i = new WeakMap();
  function s(l) {
    const u = r.render.frame,
      h = l.geometry,
      d = e.get(l, h);
    if (
      (i.get(d) !== u && (e.update(d), i.set(d, u)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", a) === !1 &&
          l.addEventListener("dispose", a),
        i.get(l) !== u &&
          (t.update(l.instanceMatrix, n.ARRAY_BUFFER),
          l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER),
          i.set(l, u))),
      l.isSkinnedMesh)
    ) {
      const p = l.skeleton;
      i.get(p) !== u && (p.update(), i.set(p, u));
    }
    return d;
  }
  function o() {
    i = new WeakMap();
  }
  function a(l) {
    const u = l.target;
    u.removeEventListener("dispose", a),
      t.remove(u.instanceMatrix),
      u.instanceColor !== null && t.remove(u.instanceColor);
  }
  return { update: s, dispose: o };
}
const O2 = new en(),
  U2 = new A0(),
  k2 = new u1(),
  z2 = new ud(),
  UC = [],
  kC = [],
  zC = new Float32Array(16),
  HC = new Float32Array(9),
  GC = new Float32Array(4);
function Wc(n, e, t) {
  const r = n[0];
  if (r <= 0 || r > 0) return n;
  const i = e * t;
  let s = UC[i];
  if ((s === void 0 && ((s = new Float32Array(i)), (UC[i] = s)), e !== 0)) {
    r.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) (a += t), n[o].toArray(s, a);
  }
  return s;
}
function Hn(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, r = n.length; t < r; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function Gn(n, e) {
  for (let t = 0, r = e.length; t < r; t++) n[t] = e[t];
}
function E0(n, e) {
  let t = kC[e];
  t === void 0 && ((t = new Int32Array(e)), (kC[e] = t));
  for (let r = 0; r !== e; ++r) t[r] = n.allocateTextureUnit();
  return t;
}
function K4(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function Y4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Hn(t, e)) return;
    n.uniform2fv(this.addr, e), Gn(t, e);
  }
}
function Q4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Hn(t, e)) return;
    n.uniform3fv(this.addr, e), Gn(t, e);
  }
}
function q4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Hn(t, e)) return;
    n.uniform4fv(this.addr, e), Gn(t, e);
  }
}
function Z4(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (Hn(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), Gn(t, e);
  } else {
    if (Hn(t, r)) return;
    GC.set(r), n.uniformMatrix2fv(this.addr, !1, GC), Gn(t, r);
  }
}
function $4(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (Hn(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), Gn(t, e);
  } else {
    if (Hn(t, r)) return;
    HC.set(r), n.uniformMatrix3fv(this.addr, !1, HC), Gn(t, r);
  }
}
function e5(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (Hn(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), Gn(t, e);
  } else {
    if (Hn(t, r)) return;
    zC.set(r), n.uniformMatrix4fv(this.addr, !1, zC), Gn(t, r);
  }
}
function t5(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function n5(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Hn(t, e)) return;
    n.uniform2iv(this.addr, e), Gn(t, e);
  }
}
function r5(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Hn(t, e)) return;
    n.uniform3iv(this.addr, e), Gn(t, e);
  }
}
function i5(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Hn(t, e)) return;
    n.uniform4iv(this.addr, e), Gn(t, e);
  }
}
function s5(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function o5(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Hn(t, e)) return;
    n.uniform2uiv(this.addr, e), Gn(t, e);
  }
}
function a5(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Hn(t, e)) return;
    n.uniform3uiv(this.addr, e), Gn(t, e);
  }
}
function l5(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Hn(t, e)) return;
    n.uniform4uiv(this.addr, e), Gn(t, e);
  }
}
function u5(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTexture2D(e || O2, i);
}
function c5(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTexture3D(e || k2, i);
}
function f5(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTextureCube(e || z2, i);
}
function h5(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTexture2DArray(e || U2, i);
}
function d5(n) {
  switch (n) {
    case 5126:
      return K4;
    case 35664:
      return Y4;
    case 35665:
      return Q4;
    case 35666:
      return q4;
    case 35674:
      return Z4;
    case 35675:
      return $4;
    case 35676:
      return e5;
    case 5124:
    case 35670:
      return t5;
    case 35667:
    case 35671:
      return n5;
    case 35668:
    case 35672:
      return r5;
    case 35669:
    case 35673:
      return i5;
    case 5125:
      return s5;
    case 36294:
      return o5;
    case 36295:
      return a5;
    case 36296:
      return l5;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return u5;
    case 35679:
    case 36299:
    case 36307:
      return c5;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return f5;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return h5;
  }
}
function p5(n, e) {
  n.uniform1fv(this.addr, e);
}
function m5(n, e) {
  const t = Wc(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function g5(n, e) {
  const t = Wc(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function _5(n, e) {
  const t = Wc(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function v5(n, e) {
  const t = Wc(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function y5(n, e) {
  const t = Wc(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function x5(n, e) {
  const t = Wc(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function S5(n, e) {
  n.uniform1iv(this.addr, e);
}
function A5(n, e) {
  n.uniform2iv(this.addr, e);
}
function M5(n, e) {
  n.uniform3iv(this.addr, e);
}
function E5(n, e) {
  n.uniform4iv(this.addr, e);
}
function w5(n, e) {
  n.uniform1uiv(this.addr, e);
}
function C5(n, e) {
  n.uniform2uiv(this.addr, e);
}
function T5(n, e) {
  n.uniform3uiv(this.addr, e);
}
function b5(n, e) {
  n.uniform4uiv(this.addr, e);
}
function R5(n, e, t) {
  const r = this.cache,
    i = e.length,
    s = E0(t, i);
  Hn(r, s) || (n.uniform1iv(this.addr, s), Gn(r, s));
  for (let o = 0; o !== i; ++o) t.setTexture2D(e[o] || O2, s[o]);
}
function P5(n, e, t) {
  const r = this.cache,
    i = e.length,
    s = E0(t, i);
  Hn(r, s) || (n.uniform1iv(this.addr, s), Gn(r, s));
  for (let o = 0; o !== i; ++o) t.setTexture3D(e[o] || k2, s[o]);
}
function B5(n, e, t) {
  const r = this.cache,
    i = e.length,
    s = E0(t, i);
  Hn(r, s) || (n.uniform1iv(this.addr, s), Gn(r, s));
  for (let o = 0; o !== i; ++o) t.setTextureCube(e[o] || z2, s[o]);
}
function L5(n, e, t) {
  const r = this.cache,
    i = e.length,
    s = E0(t, i);
  Hn(r, s) || (n.uniform1iv(this.addr, s), Gn(r, s));
  for (let o = 0; o !== i; ++o) t.setTexture2DArray(e[o] || U2, s[o]);
}
function I5(n) {
  switch (n) {
    case 5126:
      return p5;
    case 35664:
      return m5;
    case 35665:
      return g5;
    case 35666:
      return _5;
    case 35674:
      return v5;
    case 35675:
      return y5;
    case 35676:
      return x5;
    case 5124:
    case 35670:
      return S5;
    case 35667:
    case 35671:
      return A5;
    case 35668:
    case 35672:
      return M5;
    case 35669:
    case 35673:
      return E5;
    case 5125:
      return w5;
    case 36294:
      return C5;
    case 36295:
      return T5;
    case 36296:
      return b5;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return R5;
    case 35679:
    case 36299:
    case 36307:
      return P5;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return B5;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return L5;
  }
}
class D5 {
  constructor(e, t, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.setValue = d5(t.type));
  }
}
class F5 {
  constructor(e, t, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.size = t.size),
      (this.setValue = I5(t.type));
  }
}
class N5 {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, r) {
    const i = this.seq;
    for (let s = 0, o = i.length; s !== o; ++s) {
      const a = i[s];
      a.setValue(e, t[a.id], r);
    }
  }
}
const $v = /(\w+)(\])?(\[|\.)?/g;
function VC(n, e) {
  n.seq.push(e), (n.map[e.id] = e);
}
function O5(n, e, t) {
  const r = n.name,
    i = r.length;
  for ($v.lastIndex = 0; ; ) {
    const s = $v.exec(r),
      o = $v.lastIndex;
    let a = s[1];
    const l = s[2] === "]",
      u = s[3];
    if ((l && (a = a | 0), u === void 0 || (u === "[" && o + 2 === i))) {
      VC(t, u === void 0 ? new D5(a, n, e) : new F5(a, n, e));
      break;
    } else {
      let d = t.map[a];
      d === void 0 && ((d = new N5(a)), VC(t, d)), (t = d);
    }
  }
}
class Qm {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < r; ++i) {
      const s = e.getActiveUniform(t, i),
        o = e.getUniformLocation(t, s.name);
      O5(s, o, this);
    }
  }
  setValue(e, t, r, i) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, r, i);
  }
  setOptional(e, t, r) {
    const i = t[r];
    i !== void 0 && this.setValue(e, r, i);
  }
  static upload(e, t, r, i) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s],
        l = r[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, i);
    }
  }
  static seqWithValue(e, t) {
    const r = [];
    for (let i = 0, s = e.length; i !== s; ++i) {
      const o = e[i];
      o.id in t && r.push(o);
    }
    return r;
  }
}
function WC(n, e, t) {
  const r = n.createShader(e);
  return n.shaderSource(r, t), n.compileShader(r), r;
}
let U5 = 0;
function k5(n, e) {
  const t = n.split(`
`),
    r = [],
    i = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let o = i; o < s; o++) {
    const a = o + 1;
    r.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return r.join(`
`);
}
function z5(n) {
  switch (n) {
    case as:
      return ["Linear", "( value )"];
    case ht:
      return ["sRGB", "( value )"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        ["Linear", "( value )"]
      );
  }
}
function jC(n, e, t) {
  const r = n.getShaderParameter(e, n.COMPILE_STATUS),
    i = n.getShaderInfoLog(e).trim();
  if (r && i === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(i);
  if (s) {
    const o = parseInt(s[1]);
    return (
      t.toUpperCase() +
      `

` +
      i +
      `

` +
      k5(n.getShaderSource(e), o)
    );
  } else return i;
}
function H5(n, e) {
  const t = z5(e);
  return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function G5(n, e) {
  let t;
  switch (e) {
    case $B:
      t = "Linear";
      break;
    case e2:
      t = "Reinhard";
      break;
    case t2:
      t = "OptimizedCineon";
      break;
    case QA:
      t = "ACESFilmic";
      break;
    case n2:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
function V5(n) {
  return [
    n.extensionDerivatives ||
    n.envMapCubeUVHeight ||
    n.bumpMap ||
    n.normalMapTangentSpace ||
    n.clearcoatNormalMap ||
    n.flatShading ||
    n.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (n.extensionFragDepth || n.logarithmicDepthBuffer) &&
    n.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    n.extensionDrawBuffers && n.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (n.extensionShaderTextureLOD || n.envMap || n.transmission) &&
    n.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(Wf).join(`
`);
}
function W5(n) {
  const e = [];
  for (const t in n) {
    const r = n[t];
    r !== !1 && e.push("#define " + t + " " + r);
  }
  return e.join(`
`);
}
function j5(n, e) {
  const t = {},
    r = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < r; i++) {
    const s = n.getActiveAttrib(e, i),
      o = s.name;
    let a = 1;
    s.type === n.FLOAT_MAT2 && (a = 2),
      s.type === n.FLOAT_MAT3 && (a = 3),
      s.type === n.FLOAT_MAT4 && (a = 4),
      (t[o] = {
        type: s.type,
        location: n.getAttribLocation(e, o),
        locationSize: a,
      });
  }
  return t;
}
function Wf(n) {
  return n !== "";
}
function XC(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function JC(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const X5 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function vS(n) {
  return n.replace(X5, K5);
}
const J5 = new Map([
  ["encodings_fragment", "colorspace_fragment"],
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  ["output_fragment", "opaque_fragment"],
]);
function K5(n, e) {
  let t = pt[e];
  if (t === void 0) {
    const r = J5.get(e);
    if (r !== void 0)
      (t = pt[r]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          r
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return vS(t);
}
const Y5 =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function KC(n) {
  return n.replace(Y5, Q5);
}
function Q5(n, e, t, r) {
  let i = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    i += r
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return i;
}
function YC(n) {
  let e =
    "precision " +
    n.precision +
    ` float;
precision ` +
    n.precision +
    " int;";
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : n.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function q5(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === _0
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === nh
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : n.shadowMapType === Zi && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function Z5(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case va:
      case ya:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Gc:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function $5(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case ya:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function e9(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case od:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case qB:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case ZB:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function t9(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    r = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: r,
    maxMip: t,
  };
}
function n9(n, e, t, r) {
  const i = n.getContext(),
    s = t.defines;
  let o = t.vertexShader,
    a = t.fragmentShader;
  const l = q5(t),
    u = Z5(t),
    h = $5(t),
    d = e9(t),
    p = t9(t),
    m = t.isWebGL2 ? "" : V5(t),
    _ = W5(s),
    y = i.createProgram();
  let x,
    g,
    S = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((x = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
      ].filter(Wf).join(`
`)),
      x.length > 0 &&
        (x += `
`),
      (g = [
        m,
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
      ].filter(Wf).join(`
`)),
      g.length > 0 &&
        (g += `
`))
    : ((x = [
        YC(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + h : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(Wf).join(`
`)),
      (g = [
        m,
        YC(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        _,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + u : "",
        t.envMap ? "#define " + h : "",
        t.envMap ? "#define " + d : "",
        p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
        p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
        p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== is ? "#define TONE_MAPPING" : "",
        t.toneMapping !== is ? pt.tonemapping_pars_fragment : "",
        t.toneMapping !== is ? G5("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        pt.colorspace_pars_fragment,
        H5("linearToOutputTexel", t.outputColorSpace),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(Wf).join(`
`))),
    (o = vS(o)),
    (o = XC(o, t)),
    (o = JC(o, t)),
    (a = vS(a)),
    (a = XC(a, t)),
    (a = JC(a, t)),
    (o = KC(o)),
    (a = KC(a)),
    t.isWebGL2 &&
      t.isRawShaderMaterial !== !0 &&
      ((S = `#version 300 es
`),
      (x =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        x),
      (g =
        [
          "#define varying in",
          t.glslVersion === mS
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === mS ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        g));
  const A = S + x + o,
    E = S + g + a,
    C = WC(i, i.VERTEX_SHADER, A),
    R = WC(i, i.FRAGMENT_SHADER, E);
  if (
    (i.attachShader(y, C),
    i.attachShader(y, R),
    t.index0AttributeName !== void 0
      ? i.bindAttribLocation(y, 0, t.index0AttributeName)
      : t.morphTargets === !0 && i.bindAttribLocation(y, 0, "position"),
    i.linkProgram(y),
    n.debug.checkShaderErrors)
  ) {
    const T = i.getProgramInfoLog(y).trim(),
      B = i.getShaderInfoLog(C).trim(),
      D = i.getShaderInfoLog(R).trim();
    let I = !0,
      F = !0;
    if (i.getProgramParameter(y, i.LINK_STATUS) === !1)
      if (((I = !1), typeof n.debug.onShaderError == "function"))
        n.debug.onShaderError(i, y, C, R);
      else {
        const k = jC(i, C, "vertex"),
          j = jC(i, R, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " +
            i.getError() +
            " - VALIDATE_STATUS " +
            i.getProgramParameter(y, i.VALIDATE_STATUS) +
            `

Program Info Log: ` +
            T +
            `
` +
            k +
            `
` +
            j
        );
      }
    else
      T !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", T)
        : (B === "" || D === "") && (F = !1);
    F &&
      (this.diagnostics = {
        runnable: I,
        programLog: T,
        vertexShader: { log: B, prefix: x },
        fragmentShader: { log: D, prefix: g },
      });
  }
  i.deleteShader(C), i.deleteShader(R);
  let P;
  this.getUniforms = function () {
    return P === void 0 && (P = new Qm(i, y)), P;
  };
  let L;
  return (
    (this.getAttributes = function () {
      return L === void 0 && (L = j5(i, y)), L;
    }),
    (this.destroy = function () {
      r.releaseStatesOfProgram(this),
        i.deleteProgram(y),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = U5++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = y),
    (this.vertexShader = C),
    (this.fragmentShader = R),
    this
  );
}
let r9 = 0;
class i9 {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      r = e.fragmentShader,
      i = this._getShaderStage(t),
      s = this._getShaderStage(r),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(i) === !1 && (o.add(i), i.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const r of t)
      r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let r = t.get(e);
    return r === void 0 && ((r = new Set()), t.set(e, r)), r;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let r = t.get(e);
    return r === void 0 && ((r = new s9(e)), t.set(e, r)), r;
  }
}
class s9 {
  constructor(e) {
    (this.id = r9++), (this.code = e), (this.usedTimes = 0);
  }
}
function o9(n, e, t, r, i, s, o) {
  const a = new Sl(),
    l = new i9(),
    u = [],
    h = i.isWebGL2,
    d = i.logarithmicDepthBuffer,
    p = i.vertexTextures;
  let m = i.precision;
  const _ = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function y(T) {
    return T === 0 ? "uv" : `uv${T}`;
  }
  function x(T, B, D, I, F) {
    const k = I.fog,
      j = F.geometry,
      Z = T.isMeshStandardMaterial ? I.environment : null,
      Q = (T.isMeshStandardMaterial ? t : e).get(T.envMap || Z),
      N = Q && Q.mapping === Gc ? Q.image.height : null,
      W = _[T.type];
    T.precision !== null &&
      ((m = i.getMaxPrecision(T.precision)),
      m !== T.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          T.precision,
          "not supported, using",
          m,
          "instead."
        ));
    const G =
        j.morphAttributes.position ||
        j.morphAttributes.normal ||
        j.morphAttributes.color,
      X = G !== void 0 ? G.length : 0;
    let Y = 0;
    j.morphAttributes.position !== void 0 && (Y = 1),
      j.morphAttributes.normal !== void 0 && (Y = 2),
      j.morphAttributes.color !== void 0 && (Y = 3);
    let de, ae, ye, we;
    if (W) {
      const Jr = ts[W];
      (de = Jr.vertexShader), (ae = Jr.fragmentShader);
    } else
      (de = T.vertexShader),
        (ae = T.fragmentShader),
        l.update(T),
        (ye = l.getVertexShaderID(T)),
        (we = l.getFragmentShaderID(T));
    const Ne = n.getRenderTarget(),
      je = F.isInstancedMesh === !0,
      At = !!T.map,
      lt = !!T.matcap,
      Ce = !!Q,
      K = !!T.aoMap,
      _e = !!T.lightMap,
      pe = !!T.bumpMap,
      Ae = !!T.normalMap,
      ve = !!T.displacementMap,
      Ge = !!T.emissiveMap,
      Oe = !!T.metalnessMap,
      Ue = !!T.roughnessMap,
      Qe = T.anisotropy > 0,
      yt = T.clearcoat > 0,
      Vt = T.iridescence > 0,
      V = T.sheen > 0,
      O = T.transmission > 0,
      ue = Qe && !!T.anisotropyMap,
      Me = yt && !!T.clearcoatMap,
      xe = yt && !!T.clearcoatNormalMap,
      Re = yt && !!T.clearcoatRoughnessMap,
      Je = Vt && !!T.iridescenceMap,
      Pe = Vt && !!T.iridescenceThicknessMap,
      he = V && !!T.sheenColorMap,
      qe = V && !!T.sheenRoughnessMap,
      Ze = !!T.specularMap,
      tt = !!T.specularColorMap,
      Ve = !!T.specularIntensityMap,
      We = O && !!T.transmissionMap,
      mt = O && !!T.thicknessMap,
      Ut = !!T.gradientMap,
      q = !!T.alphaMap,
      Le = T.alphaTest > 0,
      oe = !!T.alphaHash,
      Te = !!T.extensions,
      De = !!j.attributes.uv1,
      Et = !!j.attributes.uv2,
      Wt = !!j.attributes.uv3;
    return {
      isWebGL2: h,
      shaderID: W,
      shaderType: T.type,
      shaderName: T.name,
      vertexShader: de,
      fragmentShader: ae,
      defines: T.defines,
      customVertexShaderID: ye,
      customFragmentShaderID: we,
      isRawShaderMaterial: T.isRawShaderMaterial === !0,
      glslVersion: T.glslVersion,
      precision: m,
      instancing: je,
      instancingColor: je && F.instanceColor !== null,
      supportsVertexTextures: p,
      outputColorSpace:
        Ne === null
          ? n.outputColorSpace
          : Ne.isXRRenderTarget === !0
          ? Ne.texture.colorSpace
          : as,
      map: At,
      matcap: lt,
      envMap: Ce,
      envMapMode: Ce && Q.mapping,
      envMapCubeUVHeight: N,
      aoMap: K,
      lightMap: _e,
      bumpMap: pe,
      normalMap: Ae,
      displacementMap: p && ve,
      emissiveMap: Ge,
      normalMapObjectSpace: Ae && T.normalMapType === v2,
      normalMapTangentSpace: Ae && T.normalMapType === ba,
      metalnessMap: Oe,
      roughnessMap: Ue,
      anisotropy: Qe,
      anisotropyMap: ue,
      clearcoat: yt,
      clearcoatMap: Me,
      clearcoatNormalMap: xe,
      clearcoatRoughnessMap: Re,
      iridescence: Vt,
      iridescenceMap: Je,
      iridescenceThicknessMap: Pe,
      sheen: V,
      sheenColorMap: he,
      sheenRoughnessMap: qe,
      specularMap: Ze,
      specularColorMap: tt,
      specularIntensityMap: Ve,
      transmission: O,
      transmissionMap: We,
      thicknessMap: mt,
      gradientMap: Ut,
      opaque: T.transparent === !1 && T.blending === yl,
      alphaMap: q,
      alphaTest: Le,
      alphaHash: oe,
      combine: T.combine,
      mapUv: At && y(T.map.channel),
      aoMapUv: K && y(T.aoMap.channel),
      lightMapUv: _e && y(T.lightMap.channel),
      bumpMapUv: pe && y(T.bumpMap.channel),
      normalMapUv: Ae && y(T.normalMap.channel),
      displacementMapUv: ve && y(T.displacementMap.channel),
      emissiveMapUv: Ge && y(T.emissiveMap.channel),
      metalnessMapUv: Oe && y(T.metalnessMap.channel),
      roughnessMapUv: Ue && y(T.roughnessMap.channel),
      anisotropyMapUv: ue && y(T.anisotropyMap.channel),
      clearcoatMapUv: Me && y(T.clearcoatMap.channel),
      clearcoatNormalMapUv: xe && y(T.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Re && y(T.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Je && y(T.iridescenceMap.channel),
      iridescenceThicknessMapUv: Pe && y(T.iridescenceThicknessMap.channel),
      sheenColorMapUv: he && y(T.sheenColorMap.channel),
      sheenRoughnessMapUv: qe && y(T.sheenRoughnessMap.channel),
      specularMapUv: Ze && y(T.specularMap.channel),
      specularColorMapUv: tt && y(T.specularColorMap.channel),
      specularIntensityMapUv: Ve && y(T.specularIntensityMap.channel),
      transmissionMapUv: We && y(T.transmissionMap.channel),
      thicknessMapUv: mt && y(T.thicknessMap.channel),
      alphaMapUv: q && y(T.alphaMap.channel),
      vertexTangents: !!j.attributes.tangent && (Ae || Qe),
      vertexColors: T.vertexColors,
      vertexAlphas:
        T.vertexColors === !0 &&
        !!j.attributes.color &&
        j.attributes.color.itemSize === 4,
      vertexUv1s: De,
      vertexUv2s: Et,
      vertexUv3s: Wt,
      pointsUvs: F.isPoints === !0 && !!j.attributes.uv && (At || q),
      fog: !!k,
      useFog: T.fog === !0,
      fogExp2: k && k.isFogExp2,
      flatShading: T.flatShading === !0,
      sizeAttenuation: T.sizeAttenuation === !0,
      logarithmicDepthBuffer: d,
      skinning: F.isSkinnedMesh === !0,
      morphTargets: j.morphAttributes.position !== void 0,
      morphNormals: j.morphAttributes.normal !== void 0,
      morphColors: j.morphAttributes.color !== void 0,
      morphTargetsCount: X,
      morphTextureStride: Y,
      numDirLights: B.directional.length,
      numPointLights: B.point.length,
      numSpotLights: B.spot.length,
      numSpotLightMaps: B.spotLightMap.length,
      numRectAreaLights: B.rectArea.length,
      numHemiLights: B.hemi.length,
      numDirLightShadows: B.directionalShadowMap.length,
      numPointLightShadows: B.pointShadowMap.length,
      numSpotLightShadows: B.spotShadowMap.length,
      numSpotLightShadowsWithMaps: B.numSpotLightShadowsWithMaps,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: T.dithering,
      shadowMapEnabled: n.shadowMap.enabled && D.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: T.toneMapped ? n.toneMapping : is,
      useLegacyLights: n.useLegacyLights,
      premultipliedAlpha: T.premultipliedAlpha,
      doubleSided: T.side === Li,
      flipSided: T.side === Tr,
      useDepthPacking: T.depthPacking >= 0,
      depthPacking: T.depthPacking || 0,
      index0AttributeName: T.index0AttributeName,
      extensionDerivatives: Te && T.extensions.derivatives === !0,
      extensionFragDepth: Te && T.extensions.fragDepth === !0,
      extensionDrawBuffers: Te && T.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: Te && T.extensions.shaderTextureLOD === !0,
      rendererExtensionFragDepth: h || r.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: h || r.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: h || r.has("EXT_shader_texture_lod"),
      customProgramCacheKey: T.customProgramCacheKey(),
    };
  }
  function g(T) {
    const B = [];
    if (
      (T.shaderID
        ? B.push(T.shaderID)
        : (B.push(T.customVertexShaderID), B.push(T.customFragmentShaderID)),
      T.defines !== void 0)
    )
      for (const D in T.defines) B.push(D), B.push(T.defines[D]);
    return (
      T.isRawShaderMaterial === !1 &&
        (S(B, T), A(B, T), B.push(n.outputColorSpace)),
      B.push(T.customProgramCacheKey),
      B.join()
    );
  }
  function S(T, B) {
    T.push(B.precision),
      T.push(B.outputColorSpace),
      T.push(B.envMapMode),
      T.push(B.envMapCubeUVHeight),
      T.push(B.mapUv),
      T.push(B.alphaMapUv),
      T.push(B.lightMapUv),
      T.push(B.aoMapUv),
      T.push(B.bumpMapUv),
      T.push(B.normalMapUv),
      T.push(B.displacementMapUv),
      T.push(B.emissiveMapUv),
      T.push(B.metalnessMapUv),
      T.push(B.roughnessMapUv),
      T.push(B.anisotropyMapUv),
      T.push(B.clearcoatMapUv),
      T.push(B.clearcoatNormalMapUv),
      T.push(B.clearcoatRoughnessMapUv),
      T.push(B.iridescenceMapUv),
      T.push(B.iridescenceThicknessMapUv),
      T.push(B.sheenColorMapUv),
      T.push(B.sheenRoughnessMapUv),
      T.push(B.specularMapUv),
      T.push(B.specularColorMapUv),
      T.push(B.specularIntensityMapUv),
      T.push(B.transmissionMapUv),
      T.push(B.thicknessMapUv),
      T.push(B.combine),
      T.push(B.fogExp2),
      T.push(B.sizeAttenuation),
      T.push(B.morphTargetsCount),
      T.push(B.morphAttributeCount),
      T.push(B.numDirLights),
      T.push(B.numPointLights),
      T.push(B.numSpotLights),
      T.push(B.numSpotLightMaps),
      T.push(B.numHemiLights),
      T.push(B.numRectAreaLights),
      T.push(B.numDirLightShadows),
      T.push(B.numPointLightShadows),
      T.push(B.numSpotLightShadows),
      T.push(B.numSpotLightShadowsWithMaps),
      T.push(B.shadowMapType),
      T.push(B.toneMapping),
      T.push(B.numClippingPlanes),
      T.push(B.numClipIntersection),
      T.push(B.depthPacking);
  }
  function A(T, B) {
    a.disableAll(),
      B.isWebGL2 && a.enable(0),
      B.supportsVertexTextures && a.enable(1),
      B.instancing && a.enable(2),
      B.instancingColor && a.enable(3),
      B.matcap && a.enable(4),
      B.envMap && a.enable(5),
      B.normalMapObjectSpace && a.enable(6),
      B.normalMapTangentSpace && a.enable(7),
      B.clearcoat && a.enable(8),
      B.iridescence && a.enable(9),
      B.alphaTest && a.enable(10),
      B.vertexColors && a.enable(11),
      B.vertexAlphas && a.enable(12),
      B.vertexUv1s && a.enable(13),
      B.vertexUv2s && a.enable(14),
      B.vertexUv3s && a.enable(15),
      B.vertexTangents && a.enable(16),
      B.anisotropy && a.enable(17),
      T.push(a.mask),
      a.disableAll(),
      B.fog && a.enable(0),
      B.useFog && a.enable(1),
      B.flatShading && a.enable(2),
      B.logarithmicDepthBuffer && a.enable(3),
      B.skinning && a.enable(4),
      B.morphTargets && a.enable(5),
      B.morphNormals && a.enable(6),
      B.morphColors && a.enable(7),
      B.premultipliedAlpha && a.enable(8),
      B.shadowMapEnabled && a.enable(9),
      B.useLegacyLights && a.enable(10),
      B.doubleSided && a.enable(11),
      B.flipSided && a.enable(12),
      B.useDepthPacking && a.enable(13),
      B.dithering && a.enable(14),
      B.transmission && a.enable(15),
      B.sheen && a.enable(16),
      B.opaque && a.enable(17),
      B.pointsUvs && a.enable(18),
      T.push(a.mask);
  }
  function E(T) {
    const B = _[T.type];
    let D;
    if (B) {
      const I = ts[B];
      D = I2.clone(I.uniforms);
    } else D = T.uniforms;
    return D;
  }
  function C(T, B) {
    let D;
    for (let I = 0, F = u.length; I < F; I++) {
      const k = u[I];
      if (k.cacheKey === B) {
        (D = k), ++D.usedTimes;
        break;
      }
    }
    return D === void 0 && ((D = new n9(n, B, T, s)), u.push(D)), D;
  }
  function R(T) {
    if (--T.usedTimes === 0) {
      const B = u.indexOf(T);
      (u[B] = u[u.length - 1]), u.pop(), T.destroy();
    }
  }
  function P(T) {
    l.remove(T);
  }
  function L() {
    l.dispose();
  }
  return {
    getParameters: x,
    getProgramCacheKey: g,
    getUniforms: E,
    acquireProgram: C,
    releaseProgram: R,
    releaseShaderCache: P,
    programs: u,
    dispose: L,
  };
}
function a9() {
  let n = new WeakMap();
  function e(s) {
    let o = n.get(s);
    return o === void 0 && ((o = {}), n.set(s, o)), o;
  }
  function t(s) {
    n.delete(s);
  }
  function r(s, o, a) {
    n.get(s)[o] = a;
  }
  function i() {
    n = new WeakMap();
  }
  return { get: e, remove: t, update: r, dispose: i };
}
function l9(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id;
}
function QC(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id;
}
function qC() {
  const n = [];
  let e = 0;
  const t = [],
    r = [],
    i = [];
  function s() {
    (e = 0), (t.length = 0), (r.length = 0), (i.length = 0);
  }
  function o(d, p, m, _, y, x) {
    let g = n[e];
    return (
      g === void 0
        ? ((g = {
            id: d.id,
            object: d,
            geometry: p,
            material: m,
            groupOrder: _,
            renderOrder: d.renderOrder,
            z: y,
            group: x,
          }),
          (n[e] = g))
        : ((g.id = d.id),
          (g.object = d),
          (g.geometry = p),
          (g.material = m),
          (g.groupOrder = _),
          (g.renderOrder = d.renderOrder),
          (g.z = y),
          (g.group = x)),
      e++,
      g
    );
  }
  function a(d, p, m, _, y, x) {
    const g = o(d, p, m, _, y, x);
    m.transmission > 0
      ? r.push(g)
      : m.transparent === !0
      ? i.push(g)
      : t.push(g);
  }
  function l(d, p, m, _, y, x) {
    const g = o(d, p, m, _, y, x);
    m.transmission > 0
      ? r.unshift(g)
      : m.transparent === !0
      ? i.unshift(g)
      : t.unshift(g);
  }
  function u(d, p) {
    t.length > 1 && t.sort(d || l9),
      r.length > 1 && r.sort(p || QC),
      i.length > 1 && i.sort(p || QC);
  }
  function h() {
    for (let d = e, p = n.length; d < p; d++) {
      const m = n[d];
      if (m.id === null) break;
      (m.id = null),
        (m.object = null),
        (m.geometry = null),
        (m.material = null),
        (m.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: r,
    transparent: i,
    init: s,
    push: a,
    unshift: l,
    finish: h,
    sort: u,
  };
}
function u9() {
  let n = new WeakMap();
  function e(r, i) {
    const s = n.get(r);
    let o;
    return (
      s === void 0
        ? ((o = new qC()), n.set(r, [o]))
        : i >= s.length
        ? ((o = new qC()), s.push(o))
        : (o = s[i]),
      o
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function c9() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new U(), color: new Be() };
          break;
        case "SpotLight":
          t = {
            position: new U(),
            direction: new U(),
            color: new Be(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new U(), color: new Be(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new U(), skyColor: new Be(), groundColor: new Be() };
          break;
        case "RectAreaLight":
          t = {
            color: new Be(),
            position: new U(),
            halfWidth: new U(),
            halfHeight: new U(),
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
function f9() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ge(),
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ge(),
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ge(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
let h9 = 0;
function d9(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function p9(n, e) {
  const t = new c9(),
    r = f9(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
    };
  for (let h = 0; h < 9; h++) i.probe.push(new U());
  const s = new U(),
    o = new rt(),
    a = new rt();
  function l(h, d) {
    let p = 0,
      m = 0,
      _ = 0;
    for (let D = 0; D < 9; D++) i.probe[D].set(0, 0, 0);
    let y = 0,
      x = 0,
      g = 0,
      S = 0,
      A = 0,
      E = 0,
      C = 0,
      R = 0,
      P = 0,
      L = 0;
    h.sort(d9);
    const T = d === !0 ? Math.PI : 1;
    for (let D = 0, I = h.length; D < I; D++) {
      const F = h[D],
        k = F.color,
        j = F.intensity,
        Z = F.distance,
        Q = F.shadow && F.shadow.map ? F.shadow.map.texture : null;
      if (F.isAmbientLight)
        (p += k.r * j * T), (m += k.g * j * T), (_ += k.b * j * T);
      else if (F.isLightProbe)
        for (let N = 0; N < 9; N++)
          i.probe[N].addScaledVector(F.sh.coefficients[N], j);
      else if (F.isDirectionalLight) {
        const N = t.get(F);
        if (
          (N.color.copy(F.color).multiplyScalar(F.intensity * T), F.castShadow)
        ) {
          const W = F.shadow,
            G = r.get(F);
          (G.shadowBias = W.bias),
            (G.shadowNormalBias = W.normalBias),
            (G.shadowRadius = W.radius),
            (G.shadowMapSize = W.mapSize),
            (i.directionalShadow[y] = G),
            (i.directionalShadowMap[y] = Q),
            (i.directionalShadowMatrix[y] = F.shadow.matrix),
            E++;
        }
        (i.directional[y] = N), y++;
      } else if (F.isSpotLight) {
        const N = t.get(F);
        N.position.setFromMatrixPosition(F.matrixWorld),
          N.color.copy(k).multiplyScalar(j * T),
          (N.distance = Z),
          (N.coneCos = Math.cos(F.angle)),
          (N.penumbraCos = Math.cos(F.angle * (1 - F.penumbra))),
          (N.decay = F.decay),
          (i.spot[g] = N);
        const W = F.shadow;
        if (
          (F.map &&
            ((i.spotLightMap[P] = F.map),
            P++,
            W.updateMatrices(F),
            F.castShadow && L++),
          (i.spotLightMatrix[g] = W.matrix),
          F.castShadow)
        ) {
          const G = r.get(F);
          (G.shadowBias = W.bias),
            (G.shadowNormalBias = W.normalBias),
            (G.shadowRadius = W.radius),
            (G.shadowMapSize = W.mapSize),
            (i.spotShadow[g] = G),
            (i.spotShadowMap[g] = Q),
            R++;
        }
        g++;
      } else if (F.isRectAreaLight) {
        const N = t.get(F);
        N.color.copy(k).multiplyScalar(j),
          N.halfWidth.set(F.width * 0.5, 0, 0),
          N.halfHeight.set(0, F.height * 0.5, 0),
          (i.rectArea[S] = N),
          S++;
      } else if (F.isPointLight) {
        const N = t.get(F);
        if (
          (N.color.copy(F.color).multiplyScalar(F.intensity * T),
          (N.distance = F.distance),
          (N.decay = F.decay),
          F.castShadow)
        ) {
          const W = F.shadow,
            G = r.get(F);
          (G.shadowBias = W.bias),
            (G.shadowNormalBias = W.normalBias),
            (G.shadowRadius = W.radius),
            (G.shadowMapSize = W.mapSize),
            (G.shadowCameraNear = W.camera.near),
            (G.shadowCameraFar = W.camera.far),
            (i.pointShadow[x] = G),
            (i.pointShadowMap[x] = Q),
            (i.pointShadowMatrix[x] = F.shadow.matrix),
            C++;
        }
        (i.point[x] = N), x++;
      } else if (F.isHemisphereLight) {
        const N = t.get(F);
        N.skyColor.copy(F.color).multiplyScalar(j * T),
          N.groundColor.copy(F.groundColor).multiplyScalar(j * T),
          (i.hemi[A] = N),
          A++;
      }
    }
    S > 0 &&
      (e.isWebGL2 || n.has("OES_texture_float_linear") === !0
        ? ((i.rectAreaLTC1 = be.LTC_FLOAT_1), (i.rectAreaLTC2 = be.LTC_FLOAT_2))
        : n.has("OES_texture_half_float_linear") === !0
        ? ((i.rectAreaLTC1 = be.LTC_HALF_1), (i.rectAreaLTC2 = be.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (i.ambient[0] = p),
      (i.ambient[1] = m),
      (i.ambient[2] = _);
    const B = i.hash;
    (B.directionalLength !== y ||
      B.pointLength !== x ||
      B.spotLength !== g ||
      B.rectAreaLength !== S ||
      B.hemiLength !== A ||
      B.numDirectionalShadows !== E ||
      B.numPointShadows !== C ||
      B.numSpotShadows !== R ||
      B.numSpotMaps !== P) &&
      ((i.directional.length = y),
      (i.spot.length = g),
      (i.rectArea.length = S),
      (i.point.length = x),
      (i.hemi.length = A),
      (i.directionalShadow.length = E),
      (i.directionalShadowMap.length = E),
      (i.pointShadow.length = C),
      (i.pointShadowMap.length = C),
      (i.spotShadow.length = R),
      (i.spotShadowMap.length = R),
      (i.directionalShadowMatrix.length = E),
      (i.pointShadowMatrix.length = C),
      (i.spotLightMatrix.length = R + P - L),
      (i.spotLightMap.length = P),
      (i.numSpotLightShadowsWithMaps = L),
      (B.directionalLength = y),
      (B.pointLength = x),
      (B.spotLength = g),
      (B.rectAreaLength = S),
      (B.hemiLength = A),
      (B.numDirectionalShadows = E),
      (B.numPointShadows = C),
      (B.numSpotShadows = R),
      (B.numSpotMaps = P),
      (i.version = h9++));
  }
  function u(h, d) {
    let p = 0,
      m = 0,
      _ = 0,
      y = 0,
      x = 0;
    const g = d.matrixWorldInverse;
    for (let S = 0, A = h.length; S < A; S++) {
      const E = h[S];
      if (E.isDirectionalLight) {
        const C = i.directional[p];
        C.direction.setFromMatrixPosition(E.matrixWorld),
          s.setFromMatrixPosition(E.target.matrixWorld),
          C.direction.sub(s),
          C.direction.transformDirection(g),
          p++;
      } else if (E.isSpotLight) {
        const C = i.spot[_];
        C.position.setFromMatrixPosition(E.matrixWorld),
          C.position.applyMatrix4(g),
          C.direction.setFromMatrixPosition(E.matrixWorld),
          s.setFromMatrixPosition(E.target.matrixWorld),
          C.direction.sub(s),
          C.direction.transformDirection(g),
          _++;
      } else if (E.isRectAreaLight) {
        const C = i.rectArea[y];
        C.position.setFromMatrixPosition(E.matrixWorld),
          C.position.applyMatrix4(g),
          a.identity(),
          o.copy(E.matrixWorld),
          o.premultiply(g),
          a.extractRotation(o),
          C.halfWidth.set(E.width * 0.5, 0, 0),
          C.halfHeight.set(0, E.height * 0.5, 0),
          C.halfWidth.applyMatrix4(a),
          C.halfHeight.applyMatrix4(a),
          y++;
      } else if (E.isPointLight) {
        const C = i.point[m];
        C.position.setFromMatrixPosition(E.matrixWorld),
          C.position.applyMatrix4(g),
          m++;
      } else if (E.isHemisphereLight) {
        const C = i.hemi[x];
        C.direction.setFromMatrixPosition(E.matrixWorld),
          C.direction.transformDirection(g),
          x++;
      }
    }
  }
  return { setup: l, setupView: u, state: i };
}
function ZC(n, e) {
  const t = new p9(n, e),
    r = [],
    i = [];
  function s() {
    (r.length = 0), (i.length = 0);
  }
  function o(d) {
    r.push(d);
  }
  function a(d) {
    i.push(d);
  }
  function l(d) {
    t.setup(r, d);
  }
  function u(d) {
    t.setupView(r, d);
  }
  return {
    init: s,
    state: { lightsArray: r, shadowsArray: i, lights: t },
    setupLights: l,
    setupLightsView: u,
    pushLight: o,
    pushShadow: a,
  };
}
function m9(n, e) {
  let t = new WeakMap();
  function r(s, o = 0) {
    const a = t.get(s);
    let l;
    return (
      a === void 0
        ? ((l = new ZC(n, e)), t.set(s, [l]))
        : o >= a.length
        ? ((l = new ZC(n, e)), a.push(l))
        : (l = a[o]),
      l
    );
  }
  function i() {
    t = new WeakMap();
  }
  return { get: r, dispose: i };
}
class d1 extends In {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = g2),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class p1 extends In {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const g9 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  _9 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function v9(n, e, t) {
  let r = new M0();
  const i = new ge(),
    s = new ge(),
    o = new Nt(),
    a = new d1({ depthPacking: _2 }),
    l = new p1(),
    u = {},
    h = t.maxTextureSize,
    d = { [Fs]: Tr, [Tr]: Fs, [Li]: Li },
    p = new Os({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new ge() },
        radius: { value: 4 },
      },
      vertexShader: g9,
      fragmentShader: _9,
    }),
    m = p.clone();
  m.defines.HORIZONTAL_PASS = 1;
  const _ = new dt();
  _.setAttribute(
    "position",
    new Dt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const y = new kn(_, p),
    x = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = _0);
  let g = this.type;
  this.render = function (C, R, P) {
    if (
      x.enabled === !1 ||
      (x.autoUpdate === !1 && x.needsUpdate === !1) ||
      C.length === 0
    )
      return;
    const L = n.getRenderTarget(),
      T = n.getActiveCubeFace(),
      B = n.getActiveMipmapLevel(),
      D = n.state;
    D.setBlending(ho),
      D.buffers.color.setClear(1, 1, 1, 1),
      D.buffers.depth.setTest(!0),
      D.setScissorTest(!1);
    const I = g !== Zi && this.type === Zi,
      F = g === Zi && this.type !== Zi;
    for (let k = 0, j = C.length; k < j; k++) {
      const Z = C[k],
        Q = Z.shadow;
      if (Q === void 0) {
        console.warn("THREE.WebGLShadowMap:", Z, "has no shadow.");
        continue;
      }
      if (Q.autoUpdate === !1 && Q.needsUpdate === !1) continue;
      i.copy(Q.mapSize);
      const N = Q.getFrameExtents();
      if (
        (i.multiply(N),
        s.copy(Q.mapSize),
        (i.x > h || i.y > h) &&
          (i.x > h &&
            ((s.x = Math.floor(h / N.x)),
            (i.x = s.x * N.x),
            (Q.mapSize.x = s.x)),
          i.y > h &&
            ((s.y = Math.floor(h / N.y)),
            (i.y = s.y * N.y),
            (Q.mapSize.y = s.y))),
        Q.map === null || I === !0 || F === !0)
      ) {
        const G = this.type !== Zi ? { minFilter: mn, magFilter: mn } : {};
        Q.map !== null && Q.map.dispose(),
          (Q.map = new ls(i.x, i.y, G)),
          (Q.map.texture.name = Z.name + ".shadowMap"),
          Q.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(Q.map), n.clear();
      const W = Q.getViewportCount();
      for (let G = 0; G < W; G++) {
        const X = Q.getViewport(G);
        o.set(s.x * X.x, s.y * X.y, s.x * X.z, s.y * X.w),
          D.viewport(o),
          Q.updateMatrices(Z, G),
          (r = Q.getFrustum()),
          E(R, P, Q.camera, Z, this.type);
      }
      Q.isPointLightShadow !== !0 && this.type === Zi && S(Q, P),
        (Q.needsUpdate = !1);
    }
    (g = this.type), (x.needsUpdate = !1), n.setRenderTarget(L, T, B);
  };
  function S(C, R) {
    const P = e.update(y);
    p.defines.VSM_SAMPLES !== C.blurSamples &&
      ((p.defines.VSM_SAMPLES = C.blurSamples),
      (m.defines.VSM_SAMPLES = C.blurSamples),
      (p.needsUpdate = !0),
      (m.needsUpdate = !0)),
      C.mapPass === null && (C.mapPass = new ls(i.x, i.y)),
      (p.uniforms.shadow_pass.value = C.map.texture),
      (p.uniforms.resolution.value = C.mapSize),
      (p.uniforms.radius.value = C.radius),
      n.setRenderTarget(C.mapPass),
      n.clear(),
      n.renderBufferDirect(R, null, P, p, y, null),
      (m.uniforms.shadow_pass.value = C.mapPass.texture),
      (m.uniforms.resolution.value = C.mapSize),
      (m.uniforms.radius.value = C.radius),
      n.setRenderTarget(C.map),
      n.clear(),
      n.renderBufferDirect(R, null, P, m, y, null);
  }
  function A(C, R, P, L) {
    let T = null;
    const B =
      P.isPointLight === !0 ? C.customDistanceMaterial : C.customDepthMaterial;
    if (B !== void 0) T = B;
    else if (
      ((T = P.isPointLight === !0 ? l : a),
      (n.localClippingEnabled &&
        R.clipShadows === !0 &&
        Array.isArray(R.clippingPlanes) &&
        R.clippingPlanes.length !== 0) ||
        (R.displacementMap && R.displacementScale !== 0) ||
        (R.alphaMap && R.alphaTest > 0) ||
        (R.map && R.alphaTest > 0))
    ) {
      const D = T.uuid,
        I = R.uuid;
      let F = u[D];
      F === void 0 && ((F = {}), (u[D] = F));
      let k = F[I];
      k === void 0 && ((k = T.clone()), (F[I] = k)), (T = k);
    }
    if (
      ((T.visible = R.visible),
      (T.wireframe = R.wireframe),
      L === Zi
        ? (T.side = R.shadowSide !== null ? R.shadowSide : R.side)
        : (T.side = R.shadowSide !== null ? R.shadowSide : d[R.side]),
      (T.alphaMap = R.alphaMap),
      (T.alphaTest = R.alphaTest),
      (T.map = R.map),
      (T.clipShadows = R.clipShadows),
      (T.clippingPlanes = R.clippingPlanes),
      (T.clipIntersection = R.clipIntersection),
      (T.displacementMap = R.displacementMap),
      (T.displacementScale = R.displacementScale),
      (T.displacementBias = R.displacementBias),
      (T.wireframeLinewidth = R.wireframeLinewidth),
      (T.linewidth = R.linewidth),
      P.isPointLight === !0 && T.isMeshDistanceMaterial === !0)
    ) {
      const D = n.properties.get(T);
      D.light = P;
    }
    return T;
  }
  function E(C, R, P, L, T) {
    if (C.visible === !1) return;
    if (
      C.layers.test(R.layers) &&
      (C.isMesh || C.isLine || C.isPoints) &&
      (C.castShadow || (C.receiveShadow && T === Zi)) &&
      (!C.frustumCulled || r.intersectsObject(C))
    ) {
      C.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, C.matrixWorld);
      const I = e.update(C),
        F = C.material;
      if (Array.isArray(F)) {
        const k = I.groups;
        for (let j = 0, Z = k.length; j < Z; j++) {
          const Q = k[j],
            N = F[Q.materialIndex];
          if (N && N.visible) {
            const W = A(C, N, L, T);
            n.renderBufferDirect(P, null, I, W, C, Q);
          }
        }
      } else if (F.visible) {
        const k = A(C, F, L, T);
        n.renderBufferDirect(P, null, I, k, C, null);
      }
    }
    const D = C.children;
    for (let I = 0, F = D.length; I < F; I++) E(D[I], R, P, L, T);
  }
}
function y9(n, e, t) {
  const r = t.isWebGL2;
  function i() {
    let q = !1;
    const Le = new Nt();
    let oe = null;
    const Te = new Nt(0, 0, 0, 0);
    return {
      setMask: function (De) {
        oe !== De && !q && (n.colorMask(De, De, De, De), (oe = De));
      },
      setLocked: function (De) {
        q = De;
      },
      setClear: function (De, Et, Wt, En, Jr) {
        Jr === !0 && ((De *= En), (Et *= En), (Wt *= En)),
          Le.set(De, Et, Wt, En),
          Te.equals(Le) === !1 && (n.clearColor(De, Et, Wt, En), Te.copy(Le));
      },
      reset: function () {
        (q = !1), (oe = null), Te.set(-1, 0, 0, 0);
      },
    };
  }
  function s() {
    let q = !1,
      Le = null,
      oe = null,
      Te = null;
    return {
      setTest: function (De) {
        De ? Ne(n.DEPTH_TEST) : je(n.DEPTH_TEST);
      },
      setMask: function (De) {
        Le !== De && !q && (n.depthMask(De), (Le = De));
      },
      setFunc: function (De) {
        if (oe !== De) {
          switch (De) {
            case WB:
              n.depthFunc(n.NEVER);
              break;
            case jB:
              n.depthFunc(n.ALWAYS);
              break;
            case XB:
              n.depthFunc(n.LESS);
              break;
            case Rg:
              n.depthFunc(n.LEQUAL);
              break;
            case JB:
              n.depthFunc(n.EQUAL);
              break;
            case KB:
              n.depthFunc(n.GEQUAL);
              break;
            case YB:
              n.depthFunc(n.GREATER);
              break;
            case QB:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          oe = De;
        }
      },
      setLocked: function (De) {
        q = De;
      },
      setClear: function (De) {
        Te !== De && (n.clearDepth(De), (Te = De));
      },
      reset: function () {
        (q = !1), (Le = null), (oe = null), (Te = null);
      },
    };
  }
  function o() {
    let q = !1,
      Le = null,
      oe = null,
      Te = null,
      De = null,
      Et = null,
      Wt = null,
      En = null,
      Jr = null;
    return {
      setTest: function (Jt) {
        q || (Jt ? Ne(n.STENCIL_TEST) : je(n.STENCIL_TEST));
      },
      setMask: function (Jt) {
        Le !== Jt && !q && (n.stencilMask(Jt), (Le = Jt));
      },
      setFunc: function (Jt, Kr, Qn) {
        (oe !== Jt || Te !== Kr || De !== Qn) &&
          (n.stencilFunc(Jt, Kr, Qn), (oe = Jt), (Te = Kr), (De = Qn));
      },
      setOp: function (Jt, Kr, Qn) {
        (Et !== Jt || Wt !== Kr || En !== Qn) &&
          (n.stencilOp(Jt, Kr, Qn), (Et = Jt), (Wt = Kr), (En = Qn));
      },
      setLocked: function (Jt) {
        q = Jt;
      },
      setClear: function (Jt) {
        Jr !== Jt && (n.clearStencil(Jt), (Jr = Jt));
      },
      reset: function () {
        (q = !1),
          (Le = null),
          (oe = null),
          (Te = null),
          (De = null),
          (Et = null),
          (Wt = null),
          (En = null),
          (Jr = null);
      },
    };
  }
  const a = new i(),
    l = new s(),
    u = new o(),
    h = new WeakMap(),
    d = new WeakMap();
  let p = {},
    m = {},
    _ = new WeakMap(),
    y = [],
    x = null,
    g = !1,
    S = null,
    A = null,
    E = null,
    C = null,
    R = null,
    P = null,
    L = null,
    T = !1,
    B = null,
    D = null,
    I = null,
    F = null,
    k = null;
  const j = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let Z = !1,
    Q = 0;
  const N = n.getParameter(n.VERSION);
  N.indexOf("WebGL") !== -1
    ? ((Q = parseFloat(/^WebGL (\d)/.exec(N)[1])), (Z = Q >= 1))
    : N.indexOf("OpenGL ES") !== -1 &&
      ((Q = parseFloat(/^OpenGL ES (\d)/.exec(N)[1])), (Z = Q >= 2));
  let W = null,
    G = {};
  const X = n.getParameter(n.SCISSOR_BOX),
    Y = n.getParameter(n.VIEWPORT),
    de = new Nt().fromArray(X),
    ae = new Nt().fromArray(Y);
  function ye(q, Le, oe, Te) {
    const De = new Uint8Array(4),
      Et = n.createTexture();
    n.bindTexture(q, Et),
      n.texParameteri(q, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(q, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let Wt = 0; Wt < oe; Wt++)
      r && (q === n.TEXTURE_3D || q === n.TEXTURE_2D_ARRAY)
        ? n.texImage3D(Le, 0, n.RGBA, 1, 1, Te, 0, n.RGBA, n.UNSIGNED_BYTE, De)
        : n.texImage2D(
            Le + Wt,
            0,
            n.RGBA,
            1,
            1,
            0,
            n.RGBA,
            n.UNSIGNED_BYTE,
            De
          );
    return Et;
  }
  const we = {};
  (we[n.TEXTURE_2D] = ye(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (we[n.TEXTURE_CUBE_MAP] = ye(
      n.TEXTURE_CUBE_MAP,
      n.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    r &&
      ((we[n.TEXTURE_2D_ARRAY] = ye(
        n.TEXTURE_2D_ARRAY,
        n.TEXTURE_2D_ARRAY,
        1,
        1
      )),
      (we[n.TEXTURE_3D] = ye(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1))),
    a.setClear(0, 0, 0, 1),
    l.setClear(1),
    u.setClear(0),
    Ne(n.DEPTH_TEST),
    l.setFunc(Rg),
    ve(!1),
    Ge(zx),
    Ne(n.CULL_FACE),
    pe(ho);
  function Ne(q) {
    p[q] !== !0 && (n.enable(q), (p[q] = !0));
  }
  function je(q) {
    p[q] !== !1 && (n.disable(q), (p[q] = !1));
  }
  function At(q, Le) {
    return m[q] !== Le
      ? (n.bindFramebuffer(q, Le),
        (m[q] = Le),
        r &&
          (q === n.DRAW_FRAMEBUFFER && (m[n.FRAMEBUFFER] = Le),
          q === n.FRAMEBUFFER && (m[n.DRAW_FRAMEBUFFER] = Le)),
        !0)
      : !1;
  }
  function lt(q, Le) {
    let oe = y,
      Te = !1;
    if (q)
      if (
        ((oe = _.get(Le)),
        oe === void 0 && ((oe = []), _.set(Le, oe)),
        q.isWebGLMultipleRenderTargets)
      ) {
        const De = q.texture;
        if (oe.length !== De.length || oe[0] !== n.COLOR_ATTACHMENT0) {
          for (let Et = 0, Wt = De.length; Et < Wt; Et++)
            oe[Et] = n.COLOR_ATTACHMENT0 + Et;
          (oe.length = De.length), (Te = !0);
        }
      } else
        oe[0] !== n.COLOR_ATTACHMENT0 &&
          ((oe[0] = n.COLOR_ATTACHMENT0), (Te = !0));
    else oe[0] !== n.BACK && ((oe[0] = n.BACK), (Te = !0));
    Te &&
      (t.isWebGL2
        ? n.drawBuffers(oe)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(oe));
  }
  function Ce(q) {
    return x !== q ? (n.useProgram(q), (x = q), !0) : !1;
  }
  const K = {
    [ol]: n.FUNC_ADD,
    [IB]: n.FUNC_SUBTRACT,
    [DB]: n.FUNC_REVERSE_SUBTRACT,
  };
  if (r) (K[Wx] = n.MIN), (K[jx] = n.MAX);
  else {
    const q = e.get("EXT_blend_minmax");
    q !== null && ((K[Wx] = q.MIN_EXT), (K[jx] = q.MAX_EXT));
  }
  const _e = {
    [FB]: n.ZERO,
    [NB]: n.ONE,
    [OB]: n.SRC_COLOR,
    [KA]: n.SRC_ALPHA,
    [VB]: n.SRC_ALPHA_SATURATE,
    [HB]: n.DST_COLOR,
    [kB]: n.DST_ALPHA,
    [UB]: n.ONE_MINUS_SRC_COLOR,
    [YA]: n.ONE_MINUS_SRC_ALPHA,
    [GB]: n.ONE_MINUS_DST_COLOR,
    [zB]: n.ONE_MINUS_DST_ALPHA,
  };
  function pe(q, Le, oe, Te, De, Et, Wt, En) {
    if (q === ho) {
      g === !0 && (je(n.BLEND), (g = !1));
      return;
    }
    if ((g === !1 && (Ne(n.BLEND), (g = !0)), q !== LB)) {
      if (q !== S || En !== T) {
        if (
          ((A !== ol || R !== ol) &&
            (n.blendEquation(n.FUNC_ADD), (A = ol), (R = ol)),
          En)
        )
          switch (q) {
            case yl:
              n.blendFuncSeparate(
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Hx:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case Gx:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case Vx:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", q);
              break;
          }
        else
          switch (q) {
            case yl:
              n.blendFuncSeparate(
                n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Hx:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case Gx:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case Vx:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", q);
              break;
          }
        (E = null), (C = null), (P = null), (L = null), (S = q), (T = En);
      }
      return;
    }
    (De = De || Le),
      (Et = Et || oe),
      (Wt = Wt || Te),
      (Le !== A || De !== R) &&
        (n.blendEquationSeparate(K[Le], K[De]), (A = Le), (R = De)),
      (oe !== E || Te !== C || Et !== P || Wt !== L) &&
        (n.blendFuncSeparate(_e[oe], _e[Te], _e[Et], _e[Wt]),
        (E = oe),
        (C = Te),
        (P = Et),
        (L = Wt)),
      (S = q),
      (T = !1);
  }
  function Ae(q, Le) {
    q.side === Li ? je(n.CULL_FACE) : Ne(n.CULL_FACE);
    let oe = q.side === Tr;
    Le && (oe = !oe),
      ve(oe),
      q.blending === yl && q.transparent === !1
        ? pe(ho)
        : pe(
            q.blending,
            q.blendEquation,
            q.blendSrc,
            q.blendDst,
            q.blendEquationAlpha,
            q.blendSrcAlpha,
            q.blendDstAlpha,
            q.premultipliedAlpha
          ),
      l.setFunc(q.depthFunc),
      l.setTest(q.depthTest),
      l.setMask(q.depthWrite),
      a.setMask(q.colorWrite);
    const Te = q.stencilWrite;
    u.setTest(Te),
      Te &&
        (u.setMask(q.stencilWriteMask),
        u.setFunc(q.stencilFunc, q.stencilRef, q.stencilFuncMask),
        u.setOp(q.stencilFail, q.stencilZFail, q.stencilZPass)),
      Ue(q.polygonOffset, q.polygonOffsetFactor, q.polygonOffsetUnits),
      q.alphaToCoverage === !0
        ? Ne(n.SAMPLE_ALPHA_TO_COVERAGE)
        : je(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function ve(q) {
    B !== q && (q ? n.frontFace(n.CW) : n.frontFace(n.CCW), (B = q));
  }
  function Ge(q) {
    q !== RB
      ? (Ne(n.CULL_FACE),
        q !== D &&
          (q === zx
            ? n.cullFace(n.BACK)
            : q === PB
            ? n.cullFace(n.FRONT)
            : n.cullFace(n.FRONT_AND_BACK)))
      : je(n.CULL_FACE),
      (D = q);
  }
  function Oe(q) {
    q !== I && (Z && n.lineWidth(q), (I = q));
  }
  function Ue(q, Le, oe) {
    q
      ? (Ne(n.POLYGON_OFFSET_FILL),
        (F !== Le || k !== oe) && (n.polygonOffset(Le, oe), (F = Le), (k = oe)))
      : je(n.POLYGON_OFFSET_FILL);
  }
  function Qe(q) {
    q ? Ne(n.SCISSOR_TEST) : je(n.SCISSOR_TEST);
  }
  function yt(q) {
    q === void 0 && (q = n.TEXTURE0 + j - 1),
      W !== q && (n.activeTexture(q), (W = q));
  }
  function Vt(q, Le, oe) {
    oe === void 0 && (W === null ? (oe = n.TEXTURE0 + j - 1) : (oe = W));
    let Te = G[oe];
    Te === void 0 && ((Te = { type: void 0, texture: void 0 }), (G[oe] = Te)),
      (Te.type !== q || Te.texture !== Le) &&
        (W !== oe && (n.activeTexture(oe), (W = oe)),
        n.bindTexture(q, Le || we[q]),
        (Te.type = q),
        (Te.texture = Le));
  }
  function V() {
    const q = G[W];
    q !== void 0 &&
      q.type !== void 0 &&
      (n.bindTexture(q.type, null), (q.type = void 0), (q.texture = void 0));
  }
  function O() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function ue() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function Me() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function xe() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function Re() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function Je() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function Pe() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function he() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function qe() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function Ze() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function tt(q) {
    de.equals(q) === !1 && (n.scissor(q.x, q.y, q.z, q.w), de.copy(q));
  }
  function Ve(q) {
    ae.equals(q) === !1 && (n.viewport(q.x, q.y, q.z, q.w), ae.copy(q));
  }
  function We(q, Le) {
    let oe = d.get(Le);
    oe === void 0 && ((oe = new WeakMap()), d.set(Le, oe));
    let Te = oe.get(q);
    Te === void 0 && ((Te = n.getUniformBlockIndex(Le, q.name)), oe.set(q, Te));
  }
  function mt(q, Le) {
    const Te = d.get(Le).get(q);
    h.get(Le) !== Te &&
      (n.uniformBlockBinding(Le, Te, q.__bindingPointIndex), h.set(Le, Te));
  }
  function Ut() {
    n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      r === !0 &&
        (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        n.bindFramebuffer(n.READ_FRAMEBUFFER, null)),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (p = {}),
      (W = null),
      (G = {}),
      (m = {}),
      (_ = new WeakMap()),
      (y = []),
      (x = null),
      (g = !1),
      (S = null),
      (A = null),
      (E = null),
      (C = null),
      (R = null),
      (P = null),
      (L = null),
      (T = !1),
      (B = null),
      (D = null),
      (I = null),
      (F = null),
      (k = null),
      de.set(0, 0, n.canvas.width, n.canvas.height),
      ae.set(0, 0, n.canvas.width, n.canvas.height),
      a.reset(),
      l.reset(),
      u.reset();
  }
  return {
    buffers: { color: a, depth: l, stencil: u },
    enable: Ne,
    disable: je,
    bindFramebuffer: At,
    drawBuffers: lt,
    useProgram: Ce,
    setBlending: pe,
    setMaterial: Ae,
    setFlipSided: ve,
    setCullFace: Ge,
    setLineWidth: Oe,
    setPolygonOffset: Ue,
    setScissorTest: Qe,
    activeTexture: yt,
    bindTexture: Vt,
    unbindTexture: V,
    compressedTexImage2D: O,
    compressedTexImage3D: ue,
    texImage2D: qe,
    texImage3D: Ze,
    updateUBOMapping: We,
    uniformBlockBinding: mt,
    texStorage2D: Pe,
    texStorage3D: he,
    texSubImage2D: Me,
    texSubImage3D: xe,
    compressedTexSubImage2D: Re,
    compressedTexSubImage3D: Je,
    scissor: tt,
    viewport: Ve,
    reset: Ut,
  };
}
function x9(n, e, t, r, i, s, o) {
  const a = i.isWebGL2,
    l = i.maxTextures,
    u = i.maxCubemapSize,
    h = i.maxTextureSize,
    d = i.maxSamples,
    p = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    m =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    _ = new WeakMap();
  let y;
  const x = new WeakMap();
  let g = !1;
  try {
    g =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function S(V, O) {
    return g ? new OffscreenCanvas(V, O) : Nh("canvas");
  }
  function A(V, O, ue, Me) {
    let xe = 1;
    if (
      ((V.width > Me || V.height > Me) &&
        (xe = Me / Math.max(V.width, V.height)),
      xe < 1 || O === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && V instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && V instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && V instanceof ImageBitmap)
      ) {
        const Re = O ? Lg : Math.floor,
          Je = Re(xe * V.width),
          Pe = Re(xe * V.height);
        y === void 0 && (y = S(Je, Pe));
        const he = ue ? S(Je, Pe) : y;
        return (
          (he.width = Je),
          (he.height = Pe),
          he.getContext("2d").drawImage(V, 0, 0, Je, Pe),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              V.width +
              "x" +
              V.height +
              ") to (" +
              Je +
              "x" +
              Pe +
              ")."
          ),
          he
        );
      } else
        return (
          "data" in V &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                V.width +
                "x" +
                V.height +
                ")."
            ),
          V
        );
    return V;
  }
  function E(V) {
    return gS(V.width) && gS(V.height);
  }
  function C(V) {
    return a
      ? !1
      : V.wrapS !== er ||
          V.wrapT !== er ||
          (V.minFilter !== mn && V.minFilter !== sn);
  }
  function R(V, O) {
    return V.generateMipmaps && O && V.minFilter !== mn && V.minFilter !== sn;
  }
  function P(V) {
    n.generateMipmap(V);
  }
  function L(V, O, ue, Me, xe = !1) {
    if (a === !1) return O;
    if (V !== null) {
      if (n[V] !== void 0) return n[V];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          V +
          "'"
      );
    }
    let Re = O;
    return (
      O === n.RED &&
        (ue === n.FLOAT && (Re = n.R32F),
        ue === n.HALF_FLOAT && (Re = n.R16F),
        ue === n.UNSIGNED_BYTE && (Re = n.R8)),
      O === n.RG &&
        (ue === n.FLOAT && (Re = n.RG32F),
        ue === n.HALF_FLOAT && (Re = n.RG16F),
        ue === n.UNSIGNED_BYTE && (Re = n.RG8)),
      O === n.RGBA &&
        (ue === n.FLOAT && (Re = n.RGBA32F),
        ue === n.HALF_FLOAT && (Re = n.RGBA16F),
        ue === n.UNSIGNED_BYTE &&
          (Re = Me === ht && xe === !1 ? n.SRGB8_ALPHA8 : n.RGBA8),
        ue === n.UNSIGNED_SHORT_4_4_4_4 && (Re = n.RGBA4),
        ue === n.UNSIGNED_SHORT_5_5_5_1 && (Re = n.RGB5_A1)),
      (Re === n.R16F ||
        Re === n.R32F ||
        Re === n.RG16F ||
        Re === n.RG32F ||
        Re === n.RGBA16F ||
        Re === n.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      Re
    );
  }
  function T(V, O, ue) {
    return R(V, ue) === !0 ||
      (V.isFramebufferTexture && V.minFilter !== mn && V.minFilter !== sn)
      ? Math.log2(Math.max(O.width, O.height)) + 1
      : V.mipmaps !== void 0 && V.mipmaps.length > 0
      ? V.mipmaps.length
      : V.isCompressedTexture && Array.isArray(V.image)
      ? O.mipmaps.length
      : 1;
  }
  function B(V) {
    return V === mn || V === Lh || V === sc ? n.NEAREST : n.LINEAR;
  }
  function D(V) {
    const O = V.target;
    O.removeEventListener("dispose", D), F(O), O.isVideoTexture && _.delete(O);
  }
  function I(V) {
    const O = V.target;
    O.removeEventListener("dispose", I), j(O);
  }
  function F(V) {
    const O = r.get(V);
    if (O.__webglInit === void 0) return;
    const ue = V.source,
      Me = x.get(ue);
    if (Me) {
      const xe = Me[O.__cacheKey];
      xe.usedTimes--,
        xe.usedTimes === 0 && k(V),
        Object.keys(Me).length === 0 && x.delete(ue);
    }
    r.remove(V);
  }
  function k(V) {
    const O = r.get(V);
    n.deleteTexture(O.__webglTexture);
    const ue = V.source,
      Me = x.get(ue);
    delete Me[O.__cacheKey], o.memory.textures--;
  }
  function j(V) {
    const O = V.texture,
      ue = r.get(V),
      Me = r.get(O);
    if (
      (Me.__webglTexture !== void 0 &&
        (n.deleteTexture(Me.__webglTexture), o.memory.textures--),
      V.depthTexture && V.depthTexture.dispose(),
      V.isWebGLCubeRenderTarget)
    )
      for (let xe = 0; xe < 6; xe++)
        n.deleteFramebuffer(ue.__webglFramebuffer[xe]),
          ue.__webglDepthbuffer &&
            n.deleteRenderbuffer(ue.__webglDepthbuffer[xe]);
    else {
      if (
        (n.deleteFramebuffer(ue.__webglFramebuffer),
        ue.__webglDepthbuffer && n.deleteRenderbuffer(ue.__webglDepthbuffer),
        ue.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(ue.__webglMultisampledFramebuffer),
        ue.__webglColorRenderbuffer)
      )
        for (let xe = 0; xe < ue.__webglColorRenderbuffer.length; xe++)
          ue.__webglColorRenderbuffer[xe] &&
            n.deleteRenderbuffer(ue.__webglColorRenderbuffer[xe]);
      ue.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(ue.__webglDepthRenderbuffer);
    }
    if (V.isWebGLMultipleRenderTargets)
      for (let xe = 0, Re = O.length; xe < Re; xe++) {
        const Je = r.get(O[xe]);
        Je.__webglTexture &&
          (n.deleteTexture(Je.__webglTexture), o.memory.textures--),
          r.remove(O[xe]);
      }
    r.remove(O), r.remove(V);
  }
  let Z = 0;
  function Q() {
    Z = 0;
  }
  function N() {
    const V = Z;
    return (
      V >= l &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            V +
            " texture units while this GPU supports only " +
            l
        ),
      (Z += 1),
      V
    );
  }
  function W(V) {
    const O = [];
    return (
      O.push(V.wrapS),
      O.push(V.wrapT),
      O.push(V.wrapR || 0),
      O.push(V.magFilter),
      O.push(V.minFilter),
      O.push(V.anisotropy),
      O.push(V.internalFormat),
      O.push(V.format),
      O.push(V.type),
      O.push(V.generateMipmaps),
      O.push(V.premultiplyAlpha),
      O.push(V.flipY),
      O.push(V.unpackAlignment),
      O.push(V.colorSpace),
      O.join()
    );
  }
  function G(V, O) {
    const ue = r.get(V);
    if (
      (V.isVideoTexture && yt(V),
      V.isRenderTargetTexture === !1 &&
        V.version > 0 &&
        ue.__version !== V.version)
    ) {
      const Me = V.image;
      if (Me === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (Me.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        At(ue, V, O);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, ue.__webglTexture, n.TEXTURE0 + O);
  }
  function X(V, O) {
    const ue = r.get(V);
    if (V.version > 0 && ue.__version !== V.version) {
      At(ue, V, O);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, ue.__webglTexture, n.TEXTURE0 + O);
  }
  function Y(V, O) {
    const ue = r.get(V);
    if (V.version > 0 && ue.__version !== V.version) {
      At(ue, V, O);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, ue.__webglTexture, n.TEXTURE0 + O);
  }
  function de(V, O) {
    const ue = r.get(V);
    if (V.version > 0 && ue.__version !== V.version) {
      lt(ue, V, O);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, ue.__webglTexture, n.TEXTURE0 + O);
  }
  const ae = { [xa]: n.REPEAT, [er]: n.CLAMP_TO_EDGE, [Sc]: n.MIRRORED_REPEAT },
    ye = {
      [mn]: n.NEAREST,
      [Lh]: n.NEAREST_MIPMAP_NEAREST,
      [sc]: n.NEAREST_MIPMAP_LINEAR,
      [sn]: n.LINEAR,
      [y0]: n.LINEAR_MIPMAP_NEAREST,
      [Ns]: n.LINEAR_MIPMAP_LINEAR,
    },
    we = {
      [x2]: n.NEVER,
      [T2]: n.ALWAYS,
      [S2]: n.LESS,
      [M2]: n.LEQUAL,
      [A2]: n.EQUAL,
      [C2]: n.GEQUAL,
      [E2]: n.GREATER,
      [w2]: n.NOTEQUAL,
    };
  function Ne(V, O, ue) {
    if (
      (ue
        ? (n.texParameteri(V, n.TEXTURE_WRAP_S, ae[O.wrapS]),
          n.texParameteri(V, n.TEXTURE_WRAP_T, ae[O.wrapT]),
          (V === n.TEXTURE_3D || V === n.TEXTURE_2D_ARRAY) &&
            n.texParameteri(V, n.TEXTURE_WRAP_R, ae[O.wrapR]),
          n.texParameteri(V, n.TEXTURE_MAG_FILTER, ye[O.magFilter]),
          n.texParameteri(V, n.TEXTURE_MIN_FILTER, ye[O.minFilter]))
        : (n.texParameteri(V, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE),
          n.texParameteri(V, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE),
          (V === n.TEXTURE_3D || V === n.TEXTURE_2D_ARRAY) &&
            n.texParameteri(V, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE),
          (O.wrapS !== er || O.wrapT !== er) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          n.texParameteri(V, n.TEXTURE_MAG_FILTER, B(O.magFilter)),
          n.texParameteri(V, n.TEXTURE_MIN_FILTER, B(O.minFilter)),
          O.minFilter !== mn &&
            O.minFilter !== sn &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      O.compareFunction &&
        (n.texParameteri(V, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(V, n.TEXTURE_COMPARE_FUNC, we[O.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const Me = e.get("EXT_texture_filter_anisotropic");
      if (
        O.magFilter === mn ||
        (O.minFilter !== sc && O.minFilter !== Ns) ||
        (O.type === Cs && e.has("OES_texture_float_linear") === !1) ||
        (a === !1 &&
          O.type === Ac &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (O.anisotropy > 1 || r.get(O).__currentAnisotropy) &&
        (n.texParameterf(
          V,
          Me.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(O.anisotropy, i.getMaxAnisotropy())
        ),
        (r.get(O).__currentAnisotropy = O.anisotropy));
    }
  }
  function je(V, O) {
    let ue = !1;
    V.__webglInit === void 0 &&
      ((V.__webglInit = !0), O.addEventListener("dispose", D));
    const Me = O.source;
    let xe = x.get(Me);
    xe === void 0 && ((xe = {}), x.set(Me, xe));
    const Re = W(O);
    if (Re !== V.__cacheKey) {
      xe[Re] === void 0 &&
        ((xe[Re] = { texture: n.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (ue = !0)),
        xe[Re].usedTimes++;
      const Je = xe[V.__cacheKey];
      Je !== void 0 &&
        (xe[V.__cacheKey].usedTimes--, Je.usedTimes === 0 && k(O)),
        (V.__cacheKey = Re),
        (V.__webglTexture = xe[Re].texture);
    }
    return ue;
  }
  function At(V, O, ue) {
    let Me = n.TEXTURE_2D;
    (O.isDataArrayTexture || O.isCompressedArrayTexture) &&
      (Me = n.TEXTURE_2D_ARRAY),
      O.isData3DTexture && (Me = n.TEXTURE_3D);
    const xe = je(V, O),
      Re = O.source;
    t.bindTexture(Me, V.__webglTexture, n.TEXTURE0 + ue);
    const Je = r.get(Re);
    if (Re.version !== Je.__version || xe === !0) {
      t.activeTexture(n.TEXTURE0 + ue),
        n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, O.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, O.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE);
      const Pe = C(O) && E(O.image) === !1;
      let he = A(O.image, Pe, !1, h);
      he = Vt(O, he);
      const qe = E(he) || a,
        Ze = s.convert(O.format, O.colorSpace);
      let tt = s.convert(O.type),
        Ve = L(O.internalFormat, Ze, tt, O.colorSpace);
      Ne(Me, O, qe);
      let We;
      const mt = O.mipmaps,
        Ut = a && O.isVideoTexture !== !0,
        q = Je.__version === void 0 || xe === !0,
        Le = T(O, he, qe);
      if (O.isDepthTexture)
        (Ve = n.DEPTH_COMPONENT),
          a
            ? O.type === Cs
              ? (Ve = n.DEPTH_COMPONENT32F)
              : O.type === lo
              ? (Ve = n.DEPTH_COMPONENT24)
              : O.type === ua
              ? (Ve = n.DEPTH24_STENCIL8)
              : (Ve = n.DEPTH_COMPONENT16)
            : O.type === Cs &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          O.format === ca &&
            Ve === n.DEPTH_COMPONENT &&
            O.type !== x0 &&
            O.type !== lo &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (O.type = lo),
            (tt = s.convert(O.type))),
          O.format === Ll &&
            Ve === n.DEPTH_COMPONENT &&
            ((Ve = n.DEPTH_STENCIL),
            O.type !== ua &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (O.type = ua),
              (tt = s.convert(O.type)))),
          q &&
            (Ut
              ? t.texStorage2D(n.TEXTURE_2D, 1, Ve, he.width, he.height)
              : t.texImage2D(
                  n.TEXTURE_2D,
                  0,
                  Ve,
                  he.width,
                  he.height,
                  0,
                  Ze,
                  tt,
                  null
                ));
      else if (O.isDataTexture)
        if (mt.length > 0 && qe) {
          Ut &&
            q &&
            t.texStorage2D(n.TEXTURE_2D, Le, Ve, mt[0].width, mt[0].height);
          for (let oe = 0, Te = mt.length; oe < Te; oe++)
            (We = mt[oe]),
              Ut
                ? t.texSubImage2D(
                    n.TEXTURE_2D,
                    oe,
                    0,
                    0,
                    We.width,
                    We.height,
                    Ze,
                    tt,
                    We.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    oe,
                    Ve,
                    We.width,
                    We.height,
                    0,
                    Ze,
                    tt,
                    We.data
                  );
          O.generateMipmaps = !1;
        } else
          Ut
            ? (q && t.texStorage2D(n.TEXTURE_2D, Le, Ve, he.width, he.height),
              t.texSubImage2D(
                n.TEXTURE_2D,
                0,
                0,
                0,
                he.width,
                he.height,
                Ze,
                tt,
                he.data
              ))
            : t.texImage2D(
                n.TEXTURE_2D,
                0,
                Ve,
                he.width,
                he.height,
                0,
                Ze,
                tt,
                he.data
              );
      else if (O.isCompressedTexture)
        if (O.isCompressedArrayTexture) {
          Ut &&
            q &&
            t.texStorage3D(
              n.TEXTURE_2D_ARRAY,
              Le,
              Ve,
              mt[0].width,
              mt[0].height,
              he.depth
            );
          for (let oe = 0, Te = mt.length; oe < Te; oe++)
            (We = mt[oe]),
              O.format !== Nr
                ? Ze !== null
                  ? Ut
                    ? t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        oe,
                        0,
                        0,
                        0,
                        We.width,
                        We.height,
                        he.depth,
                        Ze,
                        We.data,
                        0,
                        0
                      )
                    : t.compressedTexImage3D(
                        n.TEXTURE_2D_ARRAY,
                        oe,
                        Ve,
                        We.width,
                        We.height,
                        he.depth,
                        0,
                        We.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Ut
                ? t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    oe,
                    0,
                    0,
                    0,
                    We.width,
                    We.height,
                    he.depth,
                    Ze,
                    tt,
                    We.data
                  )
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    oe,
                    Ve,
                    We.width,
                    We.height,
                    he.depth,
                    0,
                    Ze,
                    tt,
                    We.data
                  );
        } else {
          Ut &&
            q &&
            t.texStorage2D(n.TEXTURE_2D, Le, Ve, mt[0].width, mt[0].height);
          for (let oe = 0, Te = mt.length; oe < Te; oe++)
            (We = mt[oe]),
              O.format !== Nr
                ? Ze !== null
                  ? Ut
                    ? t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        oe,
                        0,
                        0,
                        We.width,
                        We.height,
                        Ze,
                        We.data
                      )
                    : t.compressedTexImage2D(
                        n.TEXTURE_2D,
                        oe,
                        Ve,
                        We.width,
                        We.height,
                        0,
                        We.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Ut
                ? t.texSubImage2D(
                    n.TEXTURE_2D,
                    oe,
                    0,
                    0,
                    We.width,
                    We.height,
                    Ze,
                    tt,
                    We.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    oe,
                    Ve,
                    We.width,
                    We.height,
                    0,
                    Ze,
                    tt,
                    We.data
                  );
        }
      else if (O.isDataArrayTexture)
        Ut
          ? (q &&
              t.texStorage3D(
                n.TEXTURE_2D_ARRAY,
                Le,
                Ve,
                he.width,
                he.height,
                he.depth
              ),
            t.texSubImage3D(
              n.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              he.width,
              he.height,
              he.depth,
              Ze,
              tt,
              he.data
            ))
          : t.texImage3D(
              n.TEXTURE_2D_ARRAY,
              0,
              Ve,
              he.width,
              he.height,
              he.depth,
              0,
              Ze,
              tt,
              he.data
            );
      else if (O.isData3DTexture)
        Ut
          ? (q &&
              t.texStorage3D(
                n.TEXTURE_3D,
                Le,
                Ve,
                he.width,
                he.height,
                he.depth
              ),
            t.texSubImage3D(
              n.TEXTURE_3D,
              0,
              0,
              0,
              0,
              he.width,
              he.height,
              he.depth,
              Ze,
              tt,
              he.data
            ))
          : t.texImage3D(
              n.TEXTURE_3D,
              0,
              Ve,
              he.width,
              he.height,
              he.depth,
              0,
              Ze,
              tt,
              he.data
            );
      else if (O.isFramebufferTexture) {
        if (q)
          if (Ut) t.texStorage2D(n.TEXTURE_2D, Le, Ve, he.width, he.height);
          else {
            let oe = he.width,
              Te = he.height;
            for (let De = 0; De < Le; De++)
              t.texImage2D(n.TEXTURE_2D, De, Ve, oe, Te, 0, Ze, tt, null),
                (oe >>= 1),
                (Te >>= 1);
          }
      } else if (mt.length > 0 && qe) {
        Ut &&
          q &&
          t.texStorage2D(n.TEXTURE_2D, Le, Ve, mt[0].width, mt[0].height);
        for (let oe = 0, Te = mt.length; oe < Te; oe++)
          (We = mt[oe]),
            Ut
              ? t.texSubImage2D(n.TEXTURE_2D, oe, 0, 0, Ze, tt, We)
              : t.texImage2D(n.TEXTURE_2D, oe, Ve, Ze, tt, We);
        O.generateMipmaps = !1;
      } else
        Ut
          ? (q && t.texStorage2D(n.TEXTURE_2D, Le, Ve, he.width, he.height),
            t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Ze, tt, he))
          : t.texImage2D(n.TEXTURE_2D, 0, Ve, Ze, tt, he);
      R(O, qe) && P(Me),
        (Je.__version = Re.version),
        O.onUpdate && O.onUpdate(O);
    }
    V.__version = O.version;
  }
  function lt(V, O, ue) {
    if (O.image.length !== 6) return;
    const Me = je(V, O),
      xe = O.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, V.__webglTexture, n.TEXTURE0 + ue);
    const Re = r.get(xe);
    if (xe.version !== Re.__version || Me === !0) {
      t.activeTexture(n.TEXTURE0 + ue),
        n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, O.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, O.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE);
      const Je = O.isCompressedTexture || O.image[0].isCompressedTexture,
        Pe = O.image[0] && O.image[0].isDataTexture,
        he = [];
      for (let oe = 0; oe < 6; oe++)
        !Je && !Pe
          ? (he[oe] = A(O.image[oe], !1, !0, u))
          : (he[oe] = Pe ? O.image[oe].image : O.image[oe]),
          (he[oe] = Vt(O, he[oe]));
      const qe = he[0],
        Ze = E(qe) || a,
        tt = s.convert(O.format, O.colorSpace),
        Ve = s.convert(O.type),
        We = L(O.internalFormat, tt, Ve, O.colorSpace),
        mt = a && O.isVideoTexture !== !0,
        Ut = Re.__version === void 0 || Me === !0;
      let q = T(O, qe, Ze);
      Ne(n.TEXTURE_CUBE_MAP, O, Ze);
      let Le;
      if (Je) {
        mt &&
          Ut &&
          t.texStorage2D(n.TEXTURE_CUBE_MAP, q, We, qe.width, qe.height);
        for (let oe = 0; oe < 6; oe++) {
          Le = he[oe].mipmaps;
          for (let Te = 0; Te < Le.length; Te++) {
            const De = Le[Te];
            O.format !== Nr
              ? tt !== null
                ? mt
                  ? t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                      Te,
                      0,
                      0,
                      De.width,
                      De.height,
                      tt,
                      De.data
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                      Te,
                      We,
                      De.width,
                      De.height,
                      0,
                      De.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : mt
              ? t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                  Te,
                  0,
                  0,
                  De.width,
                  De.height,
                  tt,
                  Ve,
                  De.data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                  Te,
                  We,
                  De.width,
                  De.height,
                  0,
                  tt,
                  Ve,
                  De.data
                );
          }
        }
      } else {
        (Le = O.mipmaps),
          mt &&
            Ut &&
            (Le.length > 0 && q++,
            t.texStorage2D(
              n.TEXTURE_CUBE_MAP,
              q,
              We,
              he[0].width,
              he[0].height
            ));
        for (let oe = 0; oe < 6; oe++)
          if (Pe) {
            mt
              ? t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                  0,
                  0,
                  0,
                  he[oe].width,
                  he[oe].height,
                  tt,
                  Ve,
                  he[oe].data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                  0,
                  We,
                  he[oe].width,
                  he[oe].height,
                  0,
                  tt,
                  Ve,
                  he[oe].data
                );
            for (let Te = 0; Te < Le.length; Te++) {
              const Et = Le[Te].image[oe].image;
              mt
                ? t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                    Te + 1,
                    0,
                    0,
                    Et.width,
                    Et.height,
                    tt,
                    Ve,
                    Et.data
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                    Te + 1,
                    We,
                    Et.width,
                    Et.height,
                    0,
                    tt,
                    Ve,
                    Et.data
                  );
            }
          } else {
            mt
              ? t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                  0,
                  0,
                  0,
                  tt,
                  Ve,
                  he[oe]
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                  0,
                  We,
                  tt,
                  Ve,
                  he[oe]
                );
            for (let Te = 0; Te < Le.length; Te++) {
              const De = Le[Te];
              mt
                ? t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                    Te + 1,
                    0,
                    0,
                    tt,
                    Ve,
                    De.image[oe]
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + oe,
                    Te + 1,
                    We,
                    tt,
                    Ve,
                    De.image[oe]
                  );
            }
          }
      }
      R(O, Ze) && P(n.TEXTURE_CUBE_MAP),
        (Re.__version = xe.version),
        O.onUpdate && O.onUpdate(O);
    }
    V.__version = O.version;
  }
  function Ce(V, O, ue, Me, xe) {
    const Re = s.convert(ue.format, ue.colorSpace),
      Je = s.convert(ue.type),
      Pe = L(ue.internalFormat, Re, Je, ue.colorSpace);
    r.get(O).__hasExternalTextures ||
      (xe === n.TEXTURE_3D || xe === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(xe, 0, Pe, O.width, O.height, O.depth, 0, Re, Je, null)
        : t.texImage2D(xe, 0, Pe, O.width, O.height, 0, Re, Je, null)),
      t.bindFramebuffer(n.FRAMEBUFFER, V),
      Qe(O)
        ? p.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            Me,
            xe,
            r.get(ue).__webglTexture,
            0,
            Ue(O)
          )
        : (xe === n.TEXTURE_2D ||
            (xe >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
              xe <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(
            n.FRAMEBUFFER,
            Me,
            xe,
            r.get(ue).__webglTexture,
            0
          ),
      t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function K(V, O, ue) {
    if (
      (n.bindRenderbuffer(n.RENDERBUFFER, V), O.depthBuffer && !O.stencilBuffer)
    ) {
      let Me = n.DEPTH_COMPONENT16;
      if (ue || Qe(O)) {
        const xe = O.depthTexture;
        xe &&
          xe.isDepthTexture &&
          (xe.type === Cs
            ? (Me = n.DEPTH_COMPONENT32F)
            : xe.type === lo && (Me = n.DEPTH_COMPONENT24));
        const Re = Ue(O);
        Qe(O)
          ? p.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              Re,
              Me,
              O.width,
              O.height
            )
          : n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              Re,
              Me,
              O.width,
              O.height
            );
      } else n.renderbufferStorage(n.RENDERBUFFER, Me, O.width, O.height);
      n.framebufferRenderbuffer(
        n.FRAMEBUFFER,
        n.DEPTH_ATTACHMENT,
        n.RENDERBUFFER,
        V
      );
    } else if (O.depthBuffer && O.stencilBuffer) {
      const Me = Ue(O);
      ue && Qe(O) === !1
        ? n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            Me,
            n.DEPTH24_STENCIL8,
            O.width,
            O.height
          )
        : Qe(O)
        ? p.renderbufferStorageMultisampleEXT(
            n.RENDERBUFFER,
            Me,
            n.DEPTH24_STENCIL8,
            O.width,
            O.height
          )
        : n.renderbufferStorage(
            n.RENDERBUFFER,
            n.DEPTH_STENCIL,
            O.width,
            O.height
          ),
        n.framebufferRenderbuffer(
          n.FRAMEBUFFER,
          n.DEPTH_STENCIL_ATTACHMENT,
          n.RENDERBUFFER,
          V
        );
    } else {
      const Me =
        O.isWebGLMultipleRenderTargets === !0 ? O.texture : [O.texture];
      for (let xe = 0; xe < Me.length; xe++) {
        const Re = Me[xe],
          Je = s.convert(Re.format, Re.colorSpace),
          Pe = s.convert(Re.type),
          he = L(Re.internalFormat, Je, Pe, Re.colorSpace),
          qe = Ue(O);
        ue && Qe(O) === !1
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              qe,
              he,
              O.width,
              O.height
            )
          : Qe(O)
          ? p.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              qe,
              he,
              O.width,
              O.height
            )
          : n.renderbufferStorage(n.RENDERBUFFER, he, O.width, O.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function _e(V, O) {
    if (O && O.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(n.FRAMEBUFFER, V),
      !(O.depthTexture && O.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!r.get(O.depthTexture).__webglTexture ||
      O.depthTexture.image.width !== O.width ||
      O.depthTexture.image.height !== O.height) &&
      ((O.depthTexture.image.width = O.width),
      (O.depthTexture.image.height = O.height),
      (O.depthTexture.needsUpdate = !0)),
      G(O.depthTexture, 0);
    const Me = r.get(O.depthTexture).__webglTexture,
      xe = Ue(O);
    if (O.depthTexture.format === ca)
      Qe(O)
        ? p.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            Me,
            0,
            xe
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            Me,
            0
          );
    else if (O.depthTexture.format === Ll)
      Qe(O)
        ? p.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            Me,
            0,
            xe
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            Me,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function pe(V) {
    const O = r.get(V),
      ue = V.isWebGLCubeRenderTarget === !0;
    if (V.depthTexture && !O.__autoAllocateDepthBuffer) {
      if (ue)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      _e(O.__webglFramebuffer, V);
    } else if (ue) {
      O.__webglDepthbuffer = [];
      for (let Me = 0; Me < 6; Me++)
        t.bindFramebuffer(n.FRAMEBUFFER, O.__webglFramebuffer[Me]),
          (O.__webglDepthbuffer[Me] = n.createRenderbuffer()),
          K(O.__webglDepthbuffer[Me], V, !1);
    } else
      t.bindFramebuffer(n.FRAMEBUFFER, O.__webglFramebuffer),
        (O.__webglDepthbuffer = n.createRenderbuffer()),
        K(O.__webglDepthbuffer, V, !1);
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Ae(V, O, ue) {
    const Me = r.get(V);
    O !== void 0 &&
      Ce(
        Me.__webglFramebuffer,
        V,
        V.texture,
        n.COLOR_ATTACHMENT0,
        n.TEXTURE_2D
      ),
      ue !== void 0 && pe(V);
  }
  function ve(V) {
    const O = V.texture,
      ue = r.get(V),
      Me = r.get(O);
    V.addEventListener("dispose", I),
      V.isWebGLMultipleRenderTargets !== !0 &&
        (Me.__webglTexture === void 0 &&
          (Me.__webglTexture = n.createTexture()),
        (Me.__version = O.version),
        o.memory.textures++);
    const xe = V.isWebGLCubeRenderTarget === !0,
      Re = V.isWebGLMultipleRenderTargets === !0,
      Je = E(V) || a;
    if (xe) {
      ue.__webglFramebuffer = [];
      for (let Pe = 0; Pe < 6; Pe++)
        ue.__webglFramebuffer[Pe] = n.createFramebuffer();
    } else {
      if (((ue.__webglFramebuffer = n.createFramebuffer()), Re))
        if (i.drawBuffers) {
          const Pe = V.texture;
          for (let he = 0, qe = Pe.length; he < qe; he++) {
            const Ze = r.get(Pe[he]);
            Ze.__webglTexture === void 0 &&
              ((Ze.__webglTexture = n.createTexture()), o.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (a && V.samples > 0 && Qe(V) === !1) {
        const Pe = Re ? O : [O];
        (ue.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (ue.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, ue.__webglMultisampledFramebuffer);
        for (let he = 0; he < Pe.length; he++) {
          const qe = Pe[he];
          (ue.__webglColorRenderbuffer[he] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, ue.__webglColorRenderbuffer[he]);
          const Ze = s.convert(qe.format, qe.colorSpace),
            tt = s.convert(qe.type),
            Ve = L(
              qe.internalFormat,
              Ze,
              tt,
              qe.colorSpace,
              V.isXRRenderTarget === !0
            ),
            We = Ue(V);
          n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            We,
            Ve,
            V.width,
            V.height
          ),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + he,
              n.RENDERBUFFER,
              ue.__webglColorRenderbuffer[he]
            );
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null),
          V.depthBuffer &&
            ((ue.__webglDepthRenderbuffer = n.createRenderbuffer()),
            K(ue.__webglDepthRenderbuffer, V, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (xe) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, Me.__webglTexture),
        Ne(n.TEXTURE_CUBE_MAP, O, Je);
      for (let Pe = 0; Pe < 6; Pe++)
        Ce(
          ue.__webglFramebuffer[Pe],
          V,
          O,
          n.COLOR_ATTACHMENT0,
          n.TEXTURE_CUBE_MAP_POSITIVE_X + Pe
        );
      R(O, Je) && P(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Re) {
      const Pe = V.texture;
      for (let he = 0, qe = Pe.length; he < qe; he++) {
        const Ze = Pe[he],
          tt = r.get(Ze);
        t.bindTexture(n.TEXTURE_2D, tt.__webglTexture),
          Ne(n.TEXTURE_2D, Ze, Je),
          Ce(
            ue.__webglFramebuffer,
            V,
            Ze,
            n.COLOR_ATTACHMENT0 + he,
            n.TEXTURE_2D
          ),
          R(Ze, Je) && P(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Pe = n.TEXTURE_2D;
      (V.isWebGL3DRenderTarget || V.isWebGLArrayRenderTarget) &&
        (a
          ? (Pe = V.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY)
          : console.error(
              "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
            )),
        t.bindTexture(Pe, Me.__webglTexture),
        Ne(Pe, O, Je),
        Ce(ue.__webglFramebuffer, V, O, n.COLOR_ATTACHMENT0, Pe),
        R(O, Je) && P(Pe),
        t.unbindTexture();
    }
    V.depthBuffer && pe(V);
  }
  function Ge(V) {
    const O = E(V) || a,
      ue = V.isWebGLMultipleRenderTargets === !0 ? V.texture : [V.texture];
    for (let Me = 0, xe = ue.length; Me < xe; Me++) {
      const Re = ue[Me];
      if (R(Re, O)) {
        const Je = V.isWebGLCubeRenderTarget
            ? n.TEXTURE_CUBE_MAP
            : n.TEXTURE_2D,
          Pe = r.get(Re).__webglTexture;
        t.bindTexture(Je, Pe), P(Je), t.unbindTexture();
      }
    }
  }
  function Oe(V) {
    if (a && V.samples > 0 && Qe(V) === !1) {
      const O = V.isWebGLMultipleRenderTargets ? V.texture : [V.texture],
        ue = V.width,
        Me = V.height;
      let xe = n.COLOR_BUFFER_BIT;
      const Re = [],
        Je = V.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        Pe = r.get(V),
        he = V.isWebGLMultipleRenderTargets === !0;
      if (he)
        for (let qe = 0; qe < O.length; qe++)
          t.bindFramebuffer(n.FRAMEBUFFER, Pe.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + qe,
              n.RENDERBUFFER,
              null
            ),
            t.bindFramebuffer(n.FRAMEBUFFER, Pe.__webglFramebuffer),
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + qe,
              n.TEXTURE_2D,
              null,
              0
            );
      t.bindFramebuffer(n.READ_FRAMEBUFFER, Pe.__webglMultisampledFramebuffer),
        t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Pe.__webglFramebuffer);
      for (let qe = 0; qe < O.length; qe++) {
        Re.push(n.COLOR_ATTACHMENT0 + qe), V.depthBuffer && Re.push(Je);
        const Ze =
          Pe.__ignoreDepthValues !== void 0 ? Pe.__ignoreDepthValues : !1;
        if (
          (Ze === !1 &&
            (V.depthBuffer && (xe |= n.DEPTH_BUFFER_BIT),
            V.stencilBuffer && (xe |= n.STENCIL_BUFFER_BIT)),
          he &&
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              Pe.__webglColorRenderbuffer[qe]
            ),
          Ze === !0 &&
            (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [Je]),
            n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [Je])),
          he)
        ) {
          const tt = r.get(O[qe]).__webglTexture;
          n.framebufferTexture2D(
            n.DRAW_FRAMEBUFFER,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_2D,
            tt,
            0
          );
        }
        n.blitFramebuffer(0, 0, ue, Me, 0, 0, ue, Me, xe, n.NEAREST),
          m && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, Re);
      }
      if (
        (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
        t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        he)
      )
        for (let qe = 0; qe < O.length; qe++) {
          t.bindFramebuffer(n.FRAMEBUFFER, Pe.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + qe,
              n.RENDERBUFFER,
              Pe.__webglColorRenderbuffer[qe]
            );
          const Ze = r.get(O[qe]).__webglTexture;
          t.bindFramebuffer(n.FRAMEBUFFER, Pe.__webglFramebuffer),
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + qe,
              n.TEXTURE_2D,
              Ze,
              0
            );
        }
      t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Pe.__webglMultisampledFramebuffer);
    }
  }
  function Ue(V) {
    return Math.min(d, V.samples);
  }
  function Qe(V) {
    const O = r.get(V);
    return (
      a &&
      V.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      O.__useRenderToTexture !== !1
    );
  }
  function yt(V) {
    const O = o.render.frame;
    _.get(V) !== O && (_.set(V, O), V.update());
  }
  function Vt(V, O) {
    const ue = V.colorSpace,
      Me = V.format,
      xe = V.type;
    return (
      V.isCompressedTexture === !0 ||
        V.format === Bg ||
        (ue !== as &&
          ue !== ha &&
          (ue === ht
            ? a === !1
              ? e.has("EXT_sRGB") === !0 && Me === Nr
                ? ((V.format = Bg),
                  (V.minFilter = sn),
                  (V.generateMipmaps = !1))
                : (O = l1.sRGBToLinear(O))
              : (Me !== Nr || xe !== Bs) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                ue
              ))),
      O
    );
  }
  (this.allocateTextureUnit = N),
    (this.resetTextureUnits = Q),
    (this.setTexture2D = G),
    (this.setTexture2DArray = X),
    (this.setTexture3D = Y),
    (this.setTextureCube = de),
    (this.rebindTextures = Ae),
    (this.setupRenderTarget = ve),
    (this.updateRenderTargetMipmap = Ge),
    (this.updateMultisampleRenderTarget = Oe),
    (this.setupDepthRenderbuffer = pe),
    (this.setupFrameBufferTexture = Ce),
    (this.useMultisampledRTT = Qe);
}
function H2(n, e, t) {
  const r = t.isWebGL2;
  function i(s, o = ha) {
    let a;
    if (s === Bs) return n.UNSIGNED_BYTE;
    if (s === ZA) return n.UNSIGNED_SHORT_4_4_4_4;
    if (s === $A) return n.UNSIGNED_SHORT_5_5_5_1;
    if (s === r2) return n.BYTE;
    if (s === i2) return n.SHORT;
    if (s === x0) return n.UNSIGNED_SHORT;
    if (s === qA) return n.INT;
    if (s === lo) return n.UNSIGNED_INT;
    if (s === Cs) return n.FLOAT;
    if (s === Ac)
      return r
        ? n.HALF_FLOAT
        : ((a = e.get("OES_texture_half_float")),
          a !== null ? a.HALF_FLOAT_OES : null);
    if (s === s2) return n.ALPHA;
    if (s === Nr) return n.RGBA;
    if (s === o2) return n.LUMINANCE;
    if (s === a2) return n.LUMINANCE_ALPHA;
    if (s === ca) return n.DEPTH_COMPONENT;
    if (s === Ll) return n.DEPTH_STENCIL;
    if (s === Bg)
      return (a = e.get("EXT_sRGB")), a !== null ? a.SRGB_ALPHA_EXT : null;
    if (s === l2) return n.RED;
    if (s === e1) return n.RED_INTEGER;
    if (s === u2) return n.RG;
    if (s === t1) return n.RG_INTEGER;
    if (s === n1) return n.RGBA_INTEGER;
    if (s === Vm || s === Wm || s === jm || s === Xm)
      if (o === ht)
        if (((a = e.get("WEBGL_compressed_texture_s3tc_srgb")), a !== null)) {
          if (s === Vm) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === Wm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === jm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === Xm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((a = e.get("WEBGL_compressed_texture_s3tc")), a !== null)) {
        if (s === Vm) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === Wm) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === jm) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === Xm) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (s === Xx || s === Jx || s === Kx || s === Yx)
      if (((a = e.get("WEBGL_compressed_texture_pvrtc")), a !== null)) {
        if (s === Xx) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === Jx) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === Kx) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === Yx) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (s === c2)
      return (
        (a = e.get("WEBGL_compressed_texture_etc1")),
        a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (s === Qx || s === qx)
      if (((a = e.get("WEBGL_compressed_texture_etc")), a !== null)) {
        if (s === Qx)
          return o === ht ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (s === qx)
          return o === ht
            ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      s === Zx ||
      s === $x ||
      s === eS ||
      s === tS ||
      s === nS ||
      s === rS ||
      s === iS ||
      s === sS ||
      s === oS ||
      s === aS ||
      s === lS ||
      s === uS ||
      s === cS ||
      s === fS
    )
      if (((a = e.get("WEBGL_compressed_texture_astc")), a !== null)) {
        if (s === Zx)
          return o === ht
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === $x)
          return o === ht
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === eS)
          return o === ht
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === tS)
          return o === ht
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === nS)
          return o === ht
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === rS)
          return o === ht
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === iS)
          return o === ht
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === sS)
          return o === ht
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === oS)
          return o === ht
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === aS)
          return o === ht
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === lS)
          return o === ht
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === uS)
          return o === ht
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === cS)
          return o === ht
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === fS)
          return o === ht
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (s === Jm)
      if (((a = e.get("EXT_texture_compression_bptc")), a !== null)) {
        if (s === Jm)
          return o === ht
            ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else return null;
    if (s === f2 || s === hS || s === dS || s === pS)
      if (((a = e.get("EXT_texture_compression_rgtc")), a !== null)) {
        if (s === Jm) return a.COMPRESSED_RED_RGTC1_EXT;
        if (s === hS) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === dS) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === pS) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return s === ua
      ? r
        ? n.UNSIGNED_INT_24_8
        : ((a = e.get("WEBGL_depth_texture")),
          a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null)
      : n[s] !== void 0
      ? n[s]
      : null;
  }
  return { convert: i };
}
class G2 extends Mn {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class uo extends bt {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const S9 = { type: "move" };
class ey {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new uo()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new uo()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new U()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new U())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new uo()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new U()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new U())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const r of e.hand.values()) this._getHandJoint(t, r);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, r) {
    let i = null,
      s = null,
      o = null;
    const a = this._targetRay,
      l = this._grip,
      u = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (u && e.hand) {
        o = !0;
        for (const y of e.hand.values()) {
          const x = t.getJointPose(y, r),
            g = this._getHandJoint(u, y);
          x !== null &&
            (g.matrix.fromArray(x.transform.matrix),
            g.matrix.decompose(g.position, g.rotation, g.scale),
            (g.matrixWorldNeedsUpdate = !0),
            (g.jointRadius = x.radius)),
            (g.visible = x !== null);
        }
        const h = u.joints["index-finger-tip"],
          d = u.joints["thumb-tip"],
          p = h.position.distanceTo(d.position),
          m = 0.02,
          _ = 0.005;
        u.inputState.pinching && p > m + _
          ? ((u.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !u.inputState.pinching &&
            p <= m - _ &&
            ((u.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, r)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      a !== null &&
        ((i = t.getPose(e.targetRaySpace, r)),
        i === null && s !== null && (i = s),
        i !== null &&
          (a.matrix.fromArray(i.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(i.linearVelocity))
            : (a.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(i.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(S9)));
    }
    return (
      a !== null && (a.visible = i !== null),
      l !== null && (l.visible = s !== null),
      u !== null && (u.visible = o !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const r = new uo();
      (r.matrixAutoUpdate = !1),
        (r.visible = !1),
        (e.joints[t.jointName] = r),
        e.add(r);
    }
    return e.joints[t.jointName];
  }
}
class V2 extends en {
  constructor(e, t, r, i, s, o, a, l, u, h) {
    if (((h = h !== void 0 ? h : ca), h !== ca && h !== Ll))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    r === void 0 && h === ca && (r = lo),
      r === void 0 && h === Ll && (r = ua),
      super(null, i, s, o, a, l, h, r, u),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : mn),
      (this.minFilter = l !== void 0 ? l : mn),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
class A9 extends Mo {
  constructor(e, t) {
    super();
    const r = this;
    let i = null,
      s = 1,
      o = null,
      a = "local-floor",
      l = 1,
      u = null,
      h = null,
      d = null,
      p = null,
      m = null,
      _ = null;
    const y = t.getContextAttributes();
    let x = null,
      g = null;
    const S = [],
      A = [],
      E = new Mn();
    E.layers.enable(1), (E.viewport = new Nt());
    const C = new Mn();
    C.layers.enable(2), (C.viewport = new Nt());
    const R = [E, C],
      P = new G2();
    P.layers.enable(1), P.layers.enable(2);
    let L = null,
      T = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (X) {
        let Y = S[X];
        return (
          Y === void 0 && ((Y = new ey()), (S[X] = Y)), Y.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (X) {
        let Y = S[X];
        return Y === void 0 && ((Y = new ey()), (S[X] = Y)), Y.getGripSpace();
      }),
      (this.getHand = function (X) {
        let Y = S[X];
        return Y === void 0 && ((Y = new ey()), (S[X] = Y)), Y.getHandSpace();
      });
    function B(X) {
      const Y = A.indexOf(X.inputSource);
      if (Y === -1) return;
      const de = S[Y];
      de !== void 0 &&
        (de.update(X.inputSource, X.frame, u || o),
        de.dispatchEvent({ type: X.type, data: X.inputSource }));
    }
    function D() {
      i.removeEventListener("select", B),
        i.removeEventListener("selectstart", B),
        i.removeEventListener("selectend", B),
        i.removeEventListener("squeeze", B),
        i.removeEventListener("squeezestart", B),
        i.removeEventListener("squeezeend", B),
        i.removeEventListener("end", D),
        i.removeEventListener("inputsourceschange", I);
      for (let X = 0; X < S.length; X++) {
        const Y = A[X];
        Y !== null && ((A[X] = null), S[X].disconnect(Y));
      }
      (L = null),
        (T = null),
        e.setRenderTarget(x),
        (m = null),
        (p = null),
        (d = null),
        (i = null),
        (g = null),
        G.stop(),
        (r.isPresenting = !1),
        r.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (X) {
      (s = X),
        r.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (X) {
        (a = X),
          r.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return u || o;
      }),
      (this.setReferenceSpace = function (X) {
        u = X;
      }),
      (this.getBaseLayer = function () {
        return p !== null ? p : m;
      }),
      (this.getBinding = function () {
        return d;
      }),
      (this.getFrame = function () {
        return _;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (X) {
        if (((i = X), i !== null)) {
          if (
            ((x = e.getRenderTarget()),
            i.addEventListener("select", B),
            i.addEventListener("selectstart", B),
            i.addEventListener("selectend", B),
            i.addEventListener("squeeze", B),
            i.addEventListener("squeezestart", B),
            i.addEventListener("squeezeend", B),
            i.addEventListener("end", D),
            i.addEventListener("inputsourceschange", I),
            y.xrCompatible !== !0 && (await t.makeXRCompatible()),
            i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const Y = {
              antialias: i.renderState.layers === void 0 ? y.antialias : !0,
              alpha: !0,
              depth: y.depth,
              stencil: y.stencil,
              framebufferScaleFactor: s,
            };
            (m = new XRWebGLLayer(i, t, Y)),
              i.updateRenderState({ baseLayer: m }),
              (g = new ls(m.framebufferWidth, m.framebufferHeight, {
                format: Nr,
                type: Bs,
                colorSpace: e.outputColorSpace,
                stencilBuffer: y.stencil,
              }));
          } else {
            let Y = null,
              de = null,
              ae = null;
            y.depth &&
              ((ae = y.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (Y = y.stencil ? Ll : ca),
              (de = y.stencil ? ua : lo));
            const ye = {
              colorFormat: t.RGBA8,
              depthFormat: ae,
              scaleFactor: s,
            };
            (d = new XRWebGLBinding(i, t)),
              (p = d.createProjectionLayer(ye)),
              i.updateRenderState({ layers: [p] }),
              (g = new ls(p.textureWidth, p.textureHeight, {
                format: Nr,
                type: Bs,
                depthTexture: new V2(
                  p.textureWidth,
                  p.textureHeight,
                  de,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  Y
                ),
                stencilBuffer: y.stencil,
                colorSpace: e.outputColorSpace,
                samples: y.antialias ? 4 : 0,
              }));
            const we = e.properties.get(g);
            we.__ignoreDepthValues = p.ignoreDepthValues;
          }
          (g.isXRRenderTarget = !0),
            this.setFoveation(l),
            (u = null),
            (o = await i.requestReferenceSpace(a)),
            G.setContext(i),
            G.start(),
            (r.isPresenting = !0),
            r.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      });
    function I(X) {
      for (let Y = 0; Y < X.removed.length; Y++) {
        const de = X.removed[Y],
          ae = A.indexOf(de);
        ae >= 0 && ((A[ae] = null), S[ae].disconnect(de));
      }
      for (let Y = 0; Y < X.added.length; Y++) {
        const de = X.added[Y];
        let ae = A.indexOf(de);
        if (ae === -1) {
          for (let we = 0; we < S.length; we++)
            if (we >= A.length) {
              A.push(de), (ae = we);
              break;
            } else if (A[we] === null) {
              (A[we] = de), (ae = we);
              break;
            }
          if (ae === -1) break;
        }
        const ye = S[ae];
        ye && ye.connect(de);
      }
    }
    const F = new U(),
      k = new U();
    function j(X, Y, de) {
      F.setFromMatrixPosition(Y.matrixWorld),
        k.setFromMatrixPosition(de.matrixWorld);
      const ae = F.distanceTo(k),
        ye = Y.projectionMatrix.elements,
        we = de.projectionMatrix.elements,
        Ne = ye[14] / (ye[10] - 1),
        je = ye[14] / (ye[10] + 1),
        At = (ye[9] + 1) / ye[5],
        lt = (ye[9] - 1) / ye[5],
        Ce = (ye[8] - 1) / ye[0],
        K = (we[8] + 1) / we[0],
        _e = Ne * Ce,
        pe = Ne * K,
        Ae = ae / (-Ce + K),
        ve = Ae * -Ce;
      Y.matrixWorld.decompose(X.position, X.quaternion, X.scale),
        X.translateX(ve),
        X.translateZ(Ae),
        X.matrixWorld.compose(X.position, X.quaternion, X.scale),
        X.matrixWorldInverse.copy(X.matrixWorld).invert();
      const Ge = Ne + Ae,
        Oe = je + Ae,
        Ue = _e - ve,
        Qe = pe + (ae - ve),
        yt = ((At * je) / Oe) * Ge,
        Vt = ((lt * je) / Oe) * Ge;
      X.projectionMatrix.makePerspective(Ue, Qe, yt, Vt, Ge, Oe),
        X.projectionMatrixInverse.copy(X.projectionMatrix).invert();
    }
    function Z(X, Y) {
      Y === null
        ? X.matrixWorld.copy(X.matrix)
        : X.matrixWorld.multiplyMatrices(Y.matrixWorld, X.matrix),
        X.matrixWorldInverse.copy(X.matrixWorld).invert();
    }
    this.updateCamera = function (X) {
      if (i === null) return;
      (P.near = C.near = E.near = X.near),
        (P.far = C.far = E.far = X.far),
        (L !== P.near || T !== P.far) &&
          (i.updateRenderState({ depthNear: P.near, depthFar: P.far }),
          (L = P.near),
          (T = P.far));
      const Y = X.parent,
        de = P.cameras;
      Z(P, Y);
      for (let ae = 0; ae < de.length; ae++) Z(de[ae], Y);
      de.length === 2
        ? j(P, E, C)
        : P.projectionMatrix.copy(E.projectionMatrix),
        Q(X, P, Y);
    };
    function Q(X, Y, de) {
      de === null
        ? X.matrix.copy(Y.matrixWorld)
        : (X.matrix.copy(de.matrixWorld),
          X.matrix.invert(),
          X.matrix.multiply(Y.matrixWorld)),
        X.matrix.decompose(X.position, X.quaternion, X.scale),
        X.updateMatrixWorld(!0);
      const ae = X.children;
      for (let ye = 0, we = ae.length; ye < we; ye++)
        ae[ye].updateMatrixWorld(!0);
      X.projectionMatrix.copy(Y.projectionMatrix),
        X.projectionMatrixInverse.copy(Y.projectionMatrixInverse),
        X.isPerspectiveCamera &&
          ((X.fov = Ec * 2 * Math.atan(1 / X.projectionMatrix.elements[5])),
          (X.zoom = 1));
    }
    (this.getCamera = function () {
      return P;
    }),
      (this.getFoveation = function () {
        if (!(p === null && m === null)) return l;
      }),
      (this.setFoveation = function (X) {
        (l = X),
          p !== null && (p.fixedFoveation = X),
          m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = X);
      });
    let N = null;
    function W(X, Y) {
      if (((h = Y.getViewerPose(u || o)), (_ = Y), h !== null)) {
        const de = h.views;
        m !== null &&
          (e.setRenderTargetFramebuffer(g, m.framebuffer),
          e.setRenderTarget(g));
        let ae = !1;
        de.length !== P.cameras.length && ((P.cameras.length = 0), (ae = !0));
        for (let ye = 0; ye < de.length; ye++) {
          const we = de[ye];
          let Ne = null;
          if (m !== null) Ne = m.getViewport(we);
          else {
            const At = d.getViewSubImage(p, we);
            (Ne = At.viewport),
              ye === 0 &&
                (e.setRenderTargetTextures(
                  g,
                  At.colorTexture,
                  p.ignoreDepthValues ? void 0 : At.depthStencilTexture
                ),
                e.setRenderTarget(g));
          }
          let je = R[ye];
          je === void 0 &&
            ((je = new Mn()),
            je.layers.enable(ye),
            (je.viewport = new Nt()),
            (R[ye] = je)),
            je.matrix.fromArray(we.transform.matrix),
            je.matrix.decompose(je.position, je.quaternion, je.scale),
            je.projectionMatrix.fromArray(we.projectionMatrix),
            je.projectionMatrixInverse.copy(je.projectionMatrix).invert(),
            je.viewport.set(Ne.x, Ne.y, Ne.width, Ne.height),
            ye === 0 &&
              (P.matrix.copy(je.matrix),
              P.matrix.decompose(P.position, P.quaternion, P.scale)),
            ae === !0 && P.cameras.push(je);
        }
      }
      for (let de = 0; de < S.length; de++) {
        const ae = A[de],
          ye = S[de];
        ae !== null && ye !== void 0 && ye.update(ae, Y, u || o);
      }
      N && N(X, Y),
        Y.detectedPlanes &&
          r.dispatchEvent({ type: "planesdetected", data: Y }),
        (_ = null);
    }
    const G = new N2();
    G.setAnimationLoop(W),
      (this.setAnimationLoop = function (X) {
        N = X;
      }),
      (this.dispose = function () {});
  }
}
function M9(n, e) {
  function t(x, g) {
    x.matrixAutoUpdate === !0 && x.updateMatrix(), g.value.copy(x.matrix);
  }
  function r(x, g) {
    g.color.getRGB(x.fogColor.value, L2(n)),
      g.isFog
        ? ((x.fogNear.value = g.near), (x.fogFar.value = g.far))
        : g.isFogExp2 && (x.fogDensity.value = g.density);
  }
  function i(x, g, S, A, E) {
    g.isMeshBasicMaterial || g.isMeshLambertMaterial
      ? s(x, g)
      : g.isMeshToonMaterial
      ? (s(x, g), d(x, g))
      : g.isMeshPhongMaterial
      ? (s(x, g), h(x, g))
      : g.isMeshStandardMaterial
      ? (s(x, g), p(x, g), g.isMeshPhysicalMaterial && m(x, g, E))
      : g.isMeshMatcapMaterial
      ? (s(x, g), _(x, g))
      : g.isMeshDepthMaterial
      ? s(x, g)
      : g.isMeshDistanceMaterial
      ? (s(x, g), y(x, g))
      : g.isMeshNormalMaterial
      ? s(x, g)
      : g.isLineBasicMaterial
      ? (o(x, g), g.isLineDashedMaterial && a(x, g))
      : g.isPointsMaterial
      ? l(x, g, S, A)
      : g.isSpriteMaterial
      ? u(x, g)
      : g.isShadowMaterial
      ? (x.color.value.copy(g.color), (x.opacity.value = g.opacity))
      : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function s(x, g) {
    (x.opacity.value = g.opacity),
      g.color && x.diffuse.value.copy(g.color),
      g.emissive &&
        x.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
      g.map && ((x.map.value = g.map), t(g.map, x.mapTransform)),
      g.alphaMap &&
        ((x.alphaMap.value = g.alphaMap), t(g.alphaMap, x.alphaMapTransform)),
      g.bumpMap &&
        ((x.bumpMap.value = g.bumpMap),
        t(g.bumpMap, x.bumpMapTransform),
        (x.bumpScale.value = g.bumpScale),
        g.side === Tr && (x.bumpScale.value *= -1)),
      g.normalMap &&
        ((x.normalMap.value = g.normalMap),
        t(g.normalMap, x.normalMapTransform),
        x.normalScale.value.copy(g.normalScale),
        g.side === Tr && x.normalScale.value.negate()),
      g.displacementMap &&
        ((x.displacementMap.value = g.displacementMap),
        t(g.displacementMap, x.displacementMapTransform),
        (x.displacementScale.value = g.displacementScale),
        (x.displacementBias.value = g.displacementBias)),
      g.emissiveMap &&
        ((x.emissiveMap.value = g.emissiveMap),
        t(g.emissiveMap, x.emissiveMapTransform)),
      g.specularMap &&
        ((x.specularMap.value = g.specularMap),
        t(g.specularMap, x.specularMapTransform)),
      g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
    const S = e.get(g).envMap;
    if (
      (S &&
        ((x.envMap.value = S),
        (x.flipEnvMap.value =
          S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1),
        (x.reflectivity.value = g.reflectivity),
        (x.ior.value = g.ior),
        (x.refractionRatio.value = g.refractionRatio)),
      g.lightMap)
    ) {
      x.lightMap.value = g.lightMap;
      const A = n.useLegacyLights === !0 ? Math.PI : 1;
      (x.lightMapIntensity.value = g.lightMapIntensity * A),
        t(g.lightMap, x.lightMapTransform);
    }
    g.aoMap &&
      ((x.aoMap.value = g.aoMap),
      (x.aoMapIntensity.value = g.aoMapIntensity),
      t(g.aoMap, x.aoMapTransform));
  }
  function o(x, g) {
    x.diffuse.value.copy(g.color),
      (x.opacity.value = g.opacity),
      g.map && ((x.map.value = g.map), t(g.map, x.mapTransform));
  }
  function a(x, g) {
    (x.dashSize.value = g.dashSize),
      (x.totalSize.value = g.dashSize + g.gapSize),
      (x.scale.value = g.scale);
  }
  function l(x, g, S, A) {
    x.diffuse.value.copy(g.color),
      (x.opacity.value = g.opacity),
      (x.size.value = g.size * S),
      (x.scale.value = A * 0.5),
      g.map && ((x.map.value = g.map), t(g.map, x.uvTransform)),
      g.alphaMap &&
        ((x.alphaMap.value = g.alphaMap), t(g.alphaMap, x.alphaMapTransform)),
      g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
  }
  function u(x, g) {
    x.diffuse.value.copy(g.color),
      (x.opacity.value = g.opacity),
      (x.rotation.value = g.rotation),
      g.map && ((x.map.value = g.map), t(g.map, x.mapTransform)),
      g.alphaMap &&
        ((x.alphaMap.value = g.alphaMap), t(g.alphaMap, x.alphaMapTransform)),
      g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
  }
  function h(x, g) {
    x.specular.value.copy(g.specular),
      (x.shininess.value = Math.max(g.shininess, 1e-4));
  }
  function d(x, g) {
    g.gradientMap && (x.gradientMap.value = g.gradientMap);
  }
  function p(x, g) {
    (x.metalness.value = g.metalness),
      g.metalnessMap &&
        ((x.metalnessMap.value = g.metalnessMap),
        t(g.metalnessMap, x.metalnessMapTransform)),
      (x.roughness.value = g.roughness),
      g.roughnessMap &&
        ((x.roughnessMap.value = g.roughnessMap),
        t(g.roughnessMap, x.roughnessMapTransform)),
      e.get(g).envMap && (x.envMapIntensity.value = g.envMapIntensity);
  }
  function m(x, g, S) {
    (x.ior.value = g.ior),
      g.sheen > 0 &&
        (x.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),
        (x.sheenRoughness.value = g.sheenRoughness),
        g.sheenColorMap &&
          ((x.sheenColorMap.value = g.sheenColorMap),
          t(g.sheenColorMap, x.sheenColorMapTransform)),
        g.sheenRoughnessMap &&
          ((x.sheenRoughnessMap.value = g.sheenRoughnessMap),
          t(g.sheenRoughnessMap, x.sheenRoughnessMapTransform))),
      g.clearcoat > 0 &&
        ((x.clearcoat.value = g.clearcoat),
        (x.clearcoatRoughness.value = g.clearcoatRoughness),
        g.clearcoatMap &&
          ((x.clearcoatMap.value = g.clearcoatMap),
          t(g.clearcoatMap, x.clearcoatMapTransform)),
        g.clearcoatRoughnessMap &&
          ((x.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap),
          t(g.clearcoatRoughnessMap, x.clearcoatRoughnessMapTransform)),
        g.clearcoatNormalMap &&
          ((x.clearcoatNormalMap.value = g.clearcoatNormalMap),
          t(g.clearcoatNormalMap, x.clearcoatNormalMapTransform),
          x.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
          g.side === Tr && x.clearcoatNormalScale.value.negate())),
      g.iridescence > 0 &&
        ((x.iridescence.value = g.iridescence),
        (x.iridescenceIOR.value = g.iridescenceIOR),
        (x.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0]),
        (x.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1]),
        g.iridescenceMap &&
          ((x.iridescenceMap.value = g.iridescenceMap),
          t(g.iridescenceMap, x.iridescenceMapTransform)),
        g.iridescenceThicknessMap &&
          ((x.iridescenceThicknessMap.value = g.iridescenceThicknessMap),
          t(g.iridescenceThicknessMap, x.iridescenceThicknessMapTransform))),
      g.transmission > 0 &&
        ((x.transmission.value = g.transmission),
        (x.transmissionSamplerMap.value = S.texture),
        x.transmissionSamplerSize.value.set(S.width, S.height),
        g.transmissionMap &&
          ((x.transmissionMap.value = g.transmissionMap),
          t(g.transmissionMap, x.transmissionMapTransform)),
        (x.thickness.value = g.thickness),
        g.thicknessMap &&
          ((x.thicknessMap.value = g.thicknessMap),
          t(g.thicknessMap, x.thicknessMapTransform)),
        (x.attenuationDistance.value = g.attenuationDistance),
        x.attenuationColor.value.copy(g.attenuationColor)),
      g.anisotropy > 0 &&
        (x.anisotropyVector.value.set(
          g.anisotropy * Math.cos(g.anisotropyRotation),
          g.anisotropy * Math.sin(g.anisotropyRotation)
        ),
        g.anisotropyMap &&
          ((x.anisotropyMap.value = g.anisotropyMap),
          t(g.anisotropyMap, x.anisotropyMapTransform))),
      (x.specularIntensity.value = g.specularIntensity),
      x.specularColor.value.copy(g.specularColor),
      g.specularColorMap &&
        ((x.specularColorMap.value = g.specularColorMap),
        t(g.specularColorMap, x.specularColorMapTransform)),
      g.specularIntensityMap &&
        ((x.specularIntensityMap.value = g.specularIntensityMap),
        t(g.specularIntensityMap, x.specularIntensityMapTransform));
  }
  function _(x, g) {
    g.matcap && (x.matcap.value = g.matcap);
  }
  function y(x, g) {
    const S = e.get(g).light;
    x.referencePosition.value.setFromMatrixPosition(S.matrixWorld),
      (x.nearDistance.value = S.shadow.camera.near),
      (x.farDistance.value = S.shadow.camera.far);
  }
  return { refreshFogUniforms: r, refreshMaterialUniforms: i };
}
function E9(n, e, t, r) {
  let i = {},
    s = {},
    o = [];
  const a = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function l(S, A) {
    const E = A.program;
    r.uniformBlockBinding(S, E);
  }
  function u(S, A) {
    let E = i[S.id];
    E === void 0 &&
      (_(S), (E = h(S)), (i[S.id] = E), S.addEventListener("dispose", x));
    const C = A.program;
    r.updateUBOMapping(S, C);
    const R = e.render.frame;
    s[S.id] !== R && (p(S), (s[S.id] = R));
  }
  function h(S) {
    const A = d();
    S.__bindingPointIndex = A;
    const E = n.createBuffer(),
      C = S.__size,
      R = S.usage;
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, E),
      n.bufferData(n.UNIFORM_BUFFER, C, R),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, A, E),
      E
    );
  }
  function d() {
    for (let S = 0; S < a; S++) if (o.indexOf(S) === -1) return o.push(S), S;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function p(S) {
    const A = i[S.id],
      E = S.uniforms,
      C = S.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, A);
    for (let R = 0, P = E.length; R < P; R++) {
      const L = E[R];
      if (m(L, R, C) === !0) {
        const T = L.__offset,
          B = Array.isArray(L.value) ? L.value : [L.value];
        let D = 0;
        for (let I = 0; I < B.length; I++) {
          const F = B[I],
            k = y(F);
          typeof F == "number"
            ? ((L.__data[0] = F),
              n.bufferSubData(n.UNIFORM_BUFFER, T + D, L.__data))
            : F.isMatrix3
            ? ((L.__data[0] = F.elements[0]),
              (L.__data[1] = F.elements[1]),
              (L.__data[2] = F.elements[2]),
              (L.__data[3] = F.elements[0]),
              (L.__data[4] = F.elements[3]),
              (L.__data[5] = F.elements[4]),
              (L.__data[6] = F.elements[5]),
              (L.__data[7] = F.elements[0]),
              (L.__data[8] = F.elements[6]),
              (L.__data[9] = F.elements[7]),
              (L.__data[10] = F.elements[8]),
              (L.__data[11] = F.elements[0]))
            : (F.toArray(L.__data, D),
              (D += k.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        n.bufferSubData(n.UNIFORM_BUFFER, T, L.__data);
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function m(S, A, E) {
    const C = S.value;
    if (E[A] === void 0) {
      if (typeof C == "number") E[A] = C;
      else {
        const R = Array.isArray(C) ? C : [C],
          P = [];
        for (let L = 0; L < R.length; L++) P.push(R[L].clone());
        E[A] = P;
      }
      return !0;
    } else if (typeof C == "number") {
      if (E[A] !== C) return (E[A] = C), !0;
    } else {
      const R = Array.isArray(E[A]) ? E[A] : [E[A]],
        P = Array.isArray(C) ? C : [C];
      for (let L = 0; L < R.length; L++) {
        const T = R[L];
        if (T.equals(P[L]) === !1) return T.copy(P[L]), !0;
      }
    }
    return !1;
  }
  function _(S) {
    const A = S.uniforms;
    let E = 0;
    const C = 16;
    let R = 0;
    for (let P = 0, L = A.length; P < L; P++) {
      const T = A[P],
        B = { boundary: 0, storage: 0 },
        D = Array.isArray(T.value) ? T.value : [T.value];
      for (let I = 0, F = D.length; I < F; I++) {
        const k = D[I],
          j = y(k);
        (B.boundary += j.boundary), (B.storage += j.storage);
      }
      if (
        ((T.__data = new Float32Array(
          B.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (T.__offset = E),
        P > 0)
      ) {
        R = E % C;
        const I = C - R;
        R !== 0 && I - B.boundary < 0 && ((E += C - R), (T.__offset = E));
      }
      E += B.storage;
    }
    return (
      (R = E % C), R > 0 && (E += C - R), (S.__size = E), (S.__cache = {}), this
    );
  }
  function y(S) {
    const A = { boundary: 0, storage: 0 };
    return (
      typeof S == "number"
        ? ((A.boundary = 4), (A.storage = 4))
        : S.isVector2
        ? ((A.boundary = 8), (A.storage = 8))
        : S.isVector3 || S.isColor
        ? ((A.boundary = 16), (A.storage = 12))
        : S.isVector4
        ? ((A.boundary = 16), (A.storage = 16))
        : S.isMatrix3
        ? ((A.boundary = 48), (A.storage = 48))
        : S.isMatrix4
        ? ((A.boundary = 64), (A.storage = 64))
        : S.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            S
          ),
      A
    );
  }
  function x(S) {
    const A = S.target;
    A.removeEventListener("dispose", x);
    const E = o.indexOf(A.__bindingPointIndex);
    o.splice(E, 1), n.deleteBuffer(i[A.id]), delete i[A.id], delete s[A.id];
  }
  function g() {
    for (const S in i) n.deleteBuffer(i[S]);
    (o = []), (i = {}), (s = {});
  }
  return { bind: l, update: u, dispose: g };
}
function w9() {
  const n = Nh("canvas");
  return (n.style.display = "block"), n;
}
class m1 {
  constructor(e = {}) {
    const {
      canvas: t = w9(),
      context: r = null,
      depth: i = !0,
      stencil: s = !0,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: d = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let p;
    r !== null ? (p = r.getContextAttributes().alpha) : (p = o);
    const m = new Uint32Array(4),
      _ = new Int32Array(4);
    let y = null,
      x = null;
    const g = [],
      S = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.outputColorSpace = ht),
      (this.useLegacyLights = !0),
      (this.toneMapping = is),
      (this.toneMappingExposure = 1);
    const A = this;
    let E = !1,
      C = 0,
      R = 0,
      P = null,
      L = -1,
      T = null;
    const B = new Nt(),
      D = new Nt();
    let I = null;
    const F = new Be(0);
    let k = 0,
      j = t.width,
      Z = t.height,
      Q = 1,
      N = null,
      W = null;
    const G = new Nt(0, 0, j, Z),
      X = new Nt(0, 0, j, Z);
    let Y = !1;
    const de = new M0();
    let ae = !1,
      ye = !1,
      we = null;
    const Ne = new rt(),
      je = new ge(),
      At = new U(),
      lt = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function Ce() {
      return P === null ? Q : 1;
    }
    let K = r;
    function _e(z, ie) {
      for (let ce = 0; ce < z.length; ce++) {
        const ne = z[ce],
          fe = t.getContext(ne, ie);
        if (fe !== null) return fe;
      }
      return null;
    }
    try {
      const z = {
        alpha: !0,
        depth: i,
        stencil: s,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: u,
        powerPreference: h,
        failIfMajorPerformanceCaveat: d,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${sd}`),
        t.addEventListener("webglcontextlost", Le, !1),
        t.addEventListener("webglcontextrestored", oe, !1),
        t.addEventListener("webglcontextcreationerror", Te, !1),
        K === null)
      ) {
        const ie = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (A.isWebGL1Renderer === !0 && ie.shift(), (K = _e(ie, z)), K === null)
        )
          throw _e(ie)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" &&
        K instanceof WebGLRenderingContext &&
        console.warn(
          "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
        ),
        K.getShaderPrecisionFormat === void 0 &&
          (K.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
    } catch (z) {
      throw (console.error("THREE.WebGLRenderer: " + z.message), z);
    }
    let pe,
      Ae,
      ve,
      Ge,
      Oe,
      Ue,
      Qe,
      yt,
      Vt,
      V,
      O,
      ue,
      Me,
      xe,
      Re,
      Je,
      Pe,
      he,
      qe,
      Ze,
      tt,
      Ve,
      We,
      mt;
    function Ut() {
      (pe = new z4(K)),
        (Ae = new D4(K, pe, e)),
        pe.init(Ae),
        (Ve = new H2(K, pe, Ae)),
        (ve = new y9(K, pe, Ae)),
        (Ge = new V4(K)),
        (Oe = new a9()),
        (Ue = new x9(K, pe, ve, Oe, Ae, Ve, Ge)),
        (Qe = new N4(A)),
        (yt = new k4(A)),
        (Vt = new $z(K, Ae)),
        (We = new L4(K, pe, Vt, Ae)),
        (V = new H4(K, Vt, Ge, We)),
        (O = new J4(K, V, Vt, Ge)),
        (qe = new X4(K, Ae, Ue)),
        (Je = new F4(Oe)),
        (ue = new o9(A, Qe, yt, pe, Ae, We, Je)),
        (Me = new M9(A, Oe)),
        (xe = new u9()),
        (Re = new m9(pe, Ae)),
        (he = new B4(A, Qe, yt, ve, O, p, l)),
        (Pe = new v9(A, O, Ae)),
        (mt = new E9(K, Ge, Ae, ve)),
        (Ze = new I4(K, pe, Ge, Ae)),
        (tt = new G4(K, pe, Ge, Ae)),
        (Ge.programs = ue.programs),
        (A.capabilities = Ae),
        (A.extensions = pe),
        (A.properties = Oe),
        (A.renderLists = xe),
        (A.shadowMap = Pe),
        (A.state = ve),
        (A.info = Ge);
    }
    Ut();
    const q = new A9(A, K);
    (this.xr = q),
      (this.getContext = function () {
        return K;
      }),
      (this.getContextAttributes = function () {
        return K.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const z = pe.get("WEBGL_lose_context");
        z && z.loseContext();
      }),
      (this.forceContextRestore = function () {
        const z = pe.get("WEBGL_lose_context");
        z && z.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return Q;
      }),
      (this.setPixelRatio = function (z) {
        z !== void 0 && ((Q = z), this.setSize(j, Z, !1));
      }),
      (this.getSize = function (z) {
        return z.set(j, Z);
      }),
      (this.setSize = function (z, ie, ce = !0) {
        if (q.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (j = z),
          (Z = ie),
          (t.width = Math.floor(z * Q)),
          (t.height = Math.floor(ie * Q)),
          ce === !0 &&
            ((t.style.width = z + "px"), (t.style.height = ie + "px")),
          this.setViewport(0, 0, z, ie);
      }),
      (this.getDrawingBufferSize = function (z) {
        return z.set(j * Q, Z * Q).floor();
      }),
      (this.setDrawingBufferSize = function (z, ie, ce) {
        (j = z),
          (Z = ie),
          (Q = ce),
          (t.width = Math.floor(z * ce)),
          (t.height = Math.floor(ie * ce)),
          this.setViewport(0, 0, z, ie);
      }),
      (this.getCurrentViewport = function (z) {
        return z.copy(B);
      }),
      (this.getViewport = function (z) {
        return z.copy(G);
      }),
      (this.setViewport = function (z, ie, ce, ne) {
        z.isVector4 ? G.set(z.x, z.y, z.z, z.w) : G.set(z, ie, ce, ne),
          ve.viewport(B.copy(G).multiplyScalar(Q).floor());
      }),
      (this.getScissor = function (z) {
        return z.copy(X);
      }),
      (this.setScissor = function (z, ie, ce, ne) {
        z.isVector4 ? X.set(z.x, z.y, z.z, z.w) : X.set(z, ie, ce, ne),
          ve.scissor(D.copy(X).multiplyScalar(Q).floor());
      }),
      (this.getScissorTest = function () {
        return Y;
      }),
      (this.setScissorTest = function (z) {
        ve.setScissorTest((Y = z));
      }),
      (this.setOpaqueSort = function (z) {
        N = z;
      }),
      (this.setTransparentSort = function (z) {
        W = z;
      }),
      (this.getClearColor = function (z) {
        return z.copy(he.getClearColor());
      }),
      (this.setClearColor = function () {
        he.setClearColor.apply(he, arguments);
      }),
      (this.getClearAlpha = function () {
        return he.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        he.setClearAlpha.apply(he, arguments);
      }),
      (this.clear = function (z = !0, ie = !0, ce = !0) {
        let ne = 0;
        if (z) {
          let fe = !1;
          if (P !== null) {
            const ze = P.texture.format;
            fe = ze === n1 || ze === t1 || ze === e1;
          }
          if (fe) {
            const ze = P.texture.type,
              $e =
                ze === Bs ||
                ze === lo ||
                ze === x0 ||
                ze === ua ||
                ze === ZA ||
                ze === $A,
              nt = he.getClearColor(),
              it = he.getClearAlpha(),
              xt = nt.r,
              st = nt.g,
              ot = nt.b;
            $e
              ? ((m[0] = xt),
                (m[1] = st),
                (m[2] = ot),
                (m[3] = it),
                K.clearBufferuiv(K.COLOR, 0, m))
              : ((_[0] = xt),
                (_[1] = st),
                (_[2] = ot),
                (_[3] = it),
                K.clearBufferiv(K.COLOR, 0, _));
          } else ne |= K.COLOR_BUFFER_BIT;
        }
        ie && (ne |= K.DEPTH_BUFFER_BIT),
          ce && (ne |= K.STENCIL_BUFFER_BIT),
          K.clear(ne);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", Le, !1),
          t.removeEventListener("webglcontextrestored", oe, !1),
          t.removeEventListener("webglcontextcreationerror", Te, !1),
          xe.dispose(),
          Re.dispose(),
          Oe.dispose(),
          Qe.dispose(),
          yt.dispose(),
          O.dispose(),
          We.dispose(),
          mt.dispose(),
          ue.dispose(),
          q.dispose(),
          q.removeEventListener("sessionstart", Jt),
          q.removeEventListener("sessionend", Kr),
          we && (we.dispose(), (we = null)),
          Qn.stop();
      });
    function Le(z) {
      z.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (E = !0);
    }
    function oe() {
      console.log("THREE.WebGLRenderer: Context Restored."), (E = !1);
      const z = Ge.autoReset,
        ie = Pe.enabled,
        ce = Pe.autoUpdate,
        ne = Pe.needsUpdate,
        fe = Pe.type;
      Ut(),
        (Ge.autoReset = z),
        (Pe.enabled = ie),
        (Pe.autoUpdate = ce),
        (Pe.needsUpdate = ne),
        (Pe.type = fe);
    }
    function Te(z) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        z.statusMessage
      );
    }
    function De(z) {
      const ie = z.target;
      ie.removeEventListener("dispose", De), Et(ie);
    }
    function Et(z) {
      Wt(z), Oe.remove(z);
    }
    function Wt(z) {
      const ie = Oe.get(z).programs;
      ie !== void 0 &&
        (ie.forEach(function (ce) {
          ue.releaseProgram(ce);
        }),
        z.isShaderMaterial && ue.releaseShaderCache(z));
    }
    (this.renderBufferDirect = function (z, ie, ce, ne, fe, ze) {
      ie === null && (ie = lt);
      const $e = fe.isMesh && fe.matrixWorld.determinant() < 0,
        nt = Y0(z, ie, ce, ne, fe);
      ve.setMaterial(ne, $e);
      let it = ce.index,
        xt = 1;
      ne.wireframe === !0 && ((it = V.getWireframeAttribute(ce)), (xt = 2));
      const st = ce.drawRange,
        ot = ce.attributes.position;
      let jt = st.start * xt,
        Kt = (st.start + st.count) * xt;
      ze !== null &&
        ((jt = Math.max(jt, ze.start * xt)),
        (Kt = Math.min(Kt, (ze.start + ze.count) * xt))),
        it !== null
          ? ((jt = Math.max(jt, 0)), (Kt = Math.min(Kt, it.count)))
          : ot != null &&
            ((jt = Math.max(jt, 0)), (Kt = Math.min(Kt, ot.count)));
      const Yr = Kt - jt;
      if (Yr < 0 || Yr === 1 / 0) return;
      We.setup(fe, ne, nt, ce, it);
      let Qr,
        kt = Ze;
      if (
        (it !== null && ((Qr = Vt.get(it)), (kt = tt), kt.setIndex(Qr)),
        fe.isMesh)
      )
        ne.wireframe === !0
          ? (ve.setLineWidth(ne.wireframeLinewidth * Ce()), kt.setMode(K.LINES))
          : kt.setMode(K.TRIANGLES);
      else if (fe.isLine) {
        let ut = ne.linewidth;
        ut === void 0 && (ut = 1),
          ve.setLineWidth(ut * Ce()),
          fe.isLineSegments
            ? kt.setMode(K.LINES)
            : fe.isLineLoop
            ? kt.setMode(K.LINE_LOOP)
            : kt.setMode(K.LINE_STRIP);
      } else
        fe.isPoints
          ? kt.setMode(K.POINTS)
          : fe.isSprite && kt.setMode(K.TRIANGLES);
      if (fe.isInstancedMesh) kt.renderInstances(jt, Yr, fe.count);
      else if (ce.isInstancedBufferGeometry) {
        const ut =
            ce._maxInstanceCount !== void 0 ? ce._maxInstanceCount : 1 / 0,
          Ft = Math.min(ce.instanceCount, ut);
        kt.renderInstances(jt, Yr, Ft);
      } else kt.render(jt, Yr);
    }),
      (this.compile = function (z, ie) {
        function ce(ne, fe, ze) {
          ne.transparent === !0 && ne.side === Li && ne.forceSinglePass === !1
            ? ((ne.side = Tr),
              (ne.needsUpdate = !0),
              ds(ne, fe, ze),
              (ne.side = Fs),
              (ne.needsUpdate = !0),
              ds(ne, fe, ze),
              (ne.side = Li))
            : ds(ne, fe, ze);
        }
        (x = Re.get(z)),
          x.init(),
          S.push(x),
          z.traverseVisible(function (ne) {
            ne.isLight &&
              ne.layers.test(ie.layers) &&
              (x.pushLight(ne), ne.castShadow && x.pushShadow(ne));
          }),
          x.setupLights(A.useLegacyLights),
          z.traverse(function (ne) {
            const fe = ne.material;
            if (fe)
              if (Array.isArray(fe))
                for (let ze = 0; ze < fe.length; ze++) {
                  const $e = fe[ze];
                  ce($e, z, ne);
                }
              else ce(fe, z, ne);
          }),
          S.pop(),
          (x = null);
      });
    let En = null;
    function Jr(z) {
      En && En(z);
    }
    function Jt() {
      Qn.stop();
    }
    function Kr() {
      Qn.start();
    }
    const Qn = new N2();
    Qn.setAnimationLoop(Jr),
      typeof self < "u" && Qn.setContext(self),
      (this.setAnimationLoop = function (z) {
        (En = z), q.setAnimationLoop(z), z === null ? Qn.stop() : Qn.start();
      }),
      q.addEventListener("sessionstart", Jt),
      q.addEventListener("sessionend", Kr),
      (this.render = function (z, ie) {
        if (ie !== void 0 && ie.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (E === !0) return;
        z.matrixWorldAutoUpdate === !0 && z.updateMatrixWorld(),
          ie.parent === null &&
            ie.matrixWorldAutoUpdate === !0 &&
            ie.updateMatrixWorld(),
          q.enabled === !0 &&
            q.isPresenting === !0 &&
            (q.cameraAutoUpdate === !0 && q.updateCamera(ie),
            (ie = q.getCamera())),
          z.isScene === !0 && z.onBeforeRender(A, z, ie, P),
          (x = Re.get(z, S.length)),
          x.init(),
          S.push(x),
          Ne.multiplyMatrices(ie.projectionMatrix, ie.matrixWorldInverse),
          de.setFromProjectionMatrix(Ne),
          (ye = this.localClippingEnabled),
          (ae = Je.init(this.clippingPlanes, ye)),
          (y = xe.get(z, g.length)),
          y.init(),
          g.push(y),
          Sd(z, ie, 0, A.sortObjects),
          y.finish(),
          A.sortObjects === !0 && y.sort(N, W),
          this.info.render.frame++,
          ae === !0 && Je.beginShadows();
        const ce = x.state.shadowsArray;
        if (
          (Pe.render(ce, z, ie),
          ae === !0 && Je.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          he.render(y, z),
          x.setupLights(A.useLegacyLights),
          ie.isArrayCamera)
        ) {
          const ne = ie.cameras;
          for (let fe = 0, ze = ne.length; fe < ze; fe++) {
            const $e = ne[fe];
            Ad(y, z, $e, $e.viewport);
          }
        } else Ad(y, z, ie);
        P !== null &&
          (Ue.updateMultisampleRenderTarget(P), Ue.updateRenderTargetMipmap(P)),
          z.isScene === !0 && z.onAfterRender(A, z, ie),
          We.resetDefaultState(),
          (L = -1),
          (T = null),
          S.pop(),
          S.length > 0 ? (x = S[S.length - 1]) : (x = null),
          g.pop(),
          g.length > 0 ? (y = g[g.length - 1]) : (y = null);
      });
    function Sd(z, ie, ce, ne) {
      if (z.visible === !1) return;
      if (z.layers.test(ie.layers)) {
        if (z.isGroup) ce = z.renderOrder;
        else if (z.isLOD) z.autoUpdate === !0 && z.update(ie);
        else if (z.isLight) x.pushLight(z), z.castShadow && x.pushShadow(z);
        else if (z.isSprite) {
          if (!z.frustumCulled || de.intersectsSprite(z)) {
            ne && At.setFromMatrixPosition(z.matrixWorld).applyMatrix4(Ne);
            const $e = O.update(z),
              nt = z.material;
            nt.visible && y.push(z, $e, nt, ce, At.z, null);
          }
        } else if (
          (z.isMesh || z.isLine || z.isPoints) &&
          (!z.frustumCulled || de.intersectsObject(z))
        ) {
          const $e = O.update(z),
            nt = z.material;
          if (
            (ne &&
              (z.boundingSphere !== void 0
                ? (z.boundingSphere === null && z.computeBoundingSphere(),
                  At.copy(z.boundingSphere.center))
                : ($e.boundingSphere === null && $e.computeBoundingSphere(),
                  At.copy($e.boundingSphere.center)),
              At.applyMatrix4(z.matrixWorld).applyMatrix4(Ne)),
            Array.isArray(nt))
          ) {
            const it = $e.groups;
            for (let xt = 0, st = it.length; xt < st; xt++) {
              const ot = it[xt],
                jt = nt[ot.materialIndex];
              jt && jt.visible && y.push(z, $e, jt, ce, At.z, ot);
            }
          } else nt.visible && y.push(z, $e, nt, ce, At.z, null);
        }
      }
      const ze = z.children;
      for (let $e = 0, nt = ze.length; $e < nt; $e++) Sd(ze[$e], ie, ce, ne);
    }
    function Ad(z, ie, ce, ne) {
      const fe = z.opaque,
        ze = z.transmissive,
        $e = z.transparent;
      x.setupLightsView(ce),
        ae === !0 && Je.setGlobalState(A.clippingPlanes, ce),
        ze.length > 0 && Md(fe, ze, ie, ce),
        ne && ve.viewport(B.copy(ne)),
        fe.length > 0 && Eo(fe, ie, ce),
        ze.length > 0 && Eo(ze, ie, ce),
        $e.length > 0 && Eo($e, ie, ce),
        ve.buffers.depth.setTest(!0),
        ve.buffers.depth.setMask(!0),
        ve.buffers.color.setMask(!0),
        ve.setPolygonOffset(!1);
    }
    function Md(z, ie, ce, ne) {
      const fe = Ae.isWebGL2;
      we === null &&
        (we = new ls(1, 1, {
          generateMipmaps: !0,
          type: pe.has("EXT_color_buffer_half_float") ? Ac : Bs,
          minFilter: Ns,
          samples: fe ? 4 : 0,
        })),
        A.getDrawingBufferSize(je),
        fe ? we.setSize(je.x, je.y) : we.setSize(Lg(je.x), Lg(je.y));
      const ze = A.getRenderTarget();
      A.setRenderTarget(we),
        A.getClearColor(F),
        (k = A.getClearAlpha()),
        k < 1 && A.setClearColor(16777215, 0.5),
        A.clear();
      const $e = A.toneMapping;
      (A.toneMapping = is),
        Eo(z, ce, ne),
        Ue.updateMultisampleRenderTarget(we),
        Ue.updateRenderTargetMipmap(we);
      let nt = !1;
      for (let it = 0, xt = ie.length; it < xt; it++) {
        const st = ie[it],
          ot = st.object,
          jt = st.geometry,
          Kt = st.material,
          Yr = st.group;
        if (Kt.side === Li && ot.layers.test(ne.layers)) {
          const Qr = Kt.side;
          (Kt.side = Tr),
            (Kt.needsUpdate = !0),
            Ed(ot, ce, ne, jt, Kt, Yr),
            (Kt.side = Qr),
            (Kt.needsUpdate = !0),
            (nt = !0);
        }
      }
      nt === !0 &&
        (Ue.updateMultisampleRenderTarget(we), Ue.updateRenderTargetMipmap(we)),
        A.setRenderTarget(ze),
        A.setClearColor(F, k),
        (A.toneMapping = $e);
    }
    function Eo(z, ie, ce) {
      const ne = ie.isScene === !0 ? ie.overrideMaterial : null;
      for (let fe = 0, ze = z.length; fe < ze; fe++) {
        const $e = z[fe],
          nt = $e.object,
          it = $e.geometry,
          xt = ne === null ? $e.material : ne,
          st = $e.group;
        nt.layers.test(ce.layers) && Ed(nt, ie, ce, it, xt, st);
      }
    }
    function Ed(z, ie, ce, ne, fe, ze) {
      z.onBeforeRender(A, ie, ce, ne, fe, ze),
        z.modelViewMatrix.multiplyMatrices(
          ce.matrixWorldInverse,
          z.matrixWorld
        ),
        z.normalMatrix.getNormalMatrix(z.modelViewMatrix),
        fe.onBeforeRender(A, ie, ce, ne, z, ze),
        fe.transparent === !0 && fe.side === Li && fe.forceSinglePass === !1
          ? ((fe.side = Tr),
            (fe.needsUpdate = !0),
            A.renderBufferDirect(ce, ie, ne, fe, z, ze),
            (fe.side = Fs),
            (fe.needsUpdate = !0),
            A.renderBufferDirect(ce, ie, ne, fe, z, ze),
            (fe.side = Li))
          : A.renderBufferDirect(ce, ie, ne, fe, z, ze),
        z.onAfterRender(A, ie, ce, ne, fe, ze);
    }
    function ds(z, ie, ce) {
      ie.isScene !== !0 && (ie = lt);
      const ne = Oe.get(z),
        fe = x.state.lights,
        ze = x.state.shadowsArray,
        $e = fe.state.version,
        nt = ue.getParameters(z, fe.state, ze, ie, ce),
        it = ue.getProgramCacheKey(nt);
      let xt = ne.programs;
      (ne.environment = z.isMeshStandardMaterial ? ie.environment : null),
        (ne.fog = ie.fog),
        (ne.envMap = (z.isMeshStandardMaterial ? yt : Qe).get(
          z.envMap || ne.environment
        )),
        xt === void 0 &&
          (z.addEventListener("dispose", De),
          (xt = new Map()),
          (ne.programs = xt));
      let st = xt.get(it);
      if (st !== void 0) {
        if (ne.currentProgram === st && ne.lightsStateVersion === $e)
          return wd(z, nt), st;
      } else
        (nt.uniforms = ue.getUniforms(z)),
          z.onBuild(ce, nt, A),
          z.onBeforeCompile(nt, A),
          (st = ue.acquireProgram(nt, it)),
          xt.set(it, st),
          (ne.uniforms = nt.uniforms);
      const ot = ne.uniforms;
      ((!z.isShaderMaterial && !z.isRawShaderMaterial) || z.clipping === !0) &&
        (ot.clippingPlanes = Je.uniform),
        wd(z, nt),
        (ne.needsLights = q0(z)),
        (ne.lightsStateVersion = $e),
        ne.needsLights &&
          ((ot.ambientLightColor.value = fe.state.ambient),
          (ot.lightProbe.value = fe.state.probe),
          (ot.directionalLights.value = fe.state.directional),
          (ot.directionalLightShadows.value = fe.state.directionalShadow),
          (ot.spotLights.value = fe.state.spot),
          (ot.spotLightShadows.value = fe.state.spotShadow),
          (ot.rectAreaLights.value = fe.state.rectArea),
          (ot.ltc_1.value = fe.state.rectAreaLTC1),
          (ot.ltc_2.value = fe.state.rectAreaLTC2),
          (ot.pointLights.value = fe.state.point),
          (ot.pointLightShadows.value = fe.state.pointShadow),
          (ot.hemisphereLights.value = fe.state.hemi),
          (ot.directionalShadowMap.value = fe.state.directionalShadowMap),
          (ot.directionalShadowMatrix.value = fe.state.directionalShadowMatrix),
          (ot.spotShadowMap.value = fe.state.spotShadowMap),
          (ot.spotLightMatrix.value = fe.state.spotLightMatrix),
          (ot.spotLightMap.value = fe.state.spotLightMap),
          (ot.pointShadowMap.value = fe.state.pointShadowMap),
          (ot.pointShadowMatrix.value = fe.state.pointShadowMatrix));
      const jt = st.getUniforms(),
        Kt = Qm.seqWithValue(jt.seq, ot);
      return (ne.currentProgram = st), (ne.uniformsList = Kt), st;
    }
    function wd(z, ie) {
      const ce = Oe.get(z);
      (ce.outputColorSpace = ie.outputColorSpace),
        (ce.instancing = ie.instancing),
        (ce.skinning = ie.skinning),
        (ce.morphTargets = ie.morphTargets),
        (ce.morphNormals = ie.morphNormals),
        (ce.morphColors = ie.morphColors),
        (ce.morphTargetsCount = ie.morphTargetsCount),
        (ce.numClippingPlanes = ie.numClippingPlanes),
        (ce.numIntersection = ie.numClipIntersection),
        (ce.vertexAlphas = ie.vertexAlphas),
        (ce.vertexTangents = ie.vertexTangents),
        (ce.toneMapping = ie.toneMapping);
    }
    function Y0(z, ie, ce, ne, fe) {
      ie.isScene !== !0 && (ie = lt), Ue.resetTextureUnits();
      const ze = ie.fog,
        $e = ne.isMeshStandardMaterial ? ie.environment : null,
        nt =
          P === null
            ? A.outputColorSpace
            : P.isXRRenderTarget === !0
            ? P.texture.colorSpace
            : as,
        it = (ne.isMeshStandardMaterial ? yt : Qe).get(ne.envMap || $e),
        xt =
          ne.vertexColors === !0 &&
          !!ce.attributes.color &&
          ce.attributes.color.itemSize === 4,
        st = !!ce.attributes.tangent && (!!ne.normalMap || ne.anisotropy > 0),
        ot = !!ce.morphAttributes.position,
        jt = !!ce.morphAttributes.normal,
        Kt = !!ce.morphAttributes.color,
        Yr = ne.toneMapped ? A.toneMapping : is,
        Qr =
          ce.morphAttributes.position ||
          ce.morphAttributes.normal ||
          ce.morphAttributes.color,
        kt = Qr !== void 0 ? Qr.length : 0,
        ut = Oe.get(ne),
        Ft = x.state.lights;
      if (ae === !0 && (ye === !0 || z !== T)) {
        const ir = z === T && ne.id === L;
        Je.setState(ne, z, ir);
      }
      let at = !1;
      ne.version === ut.__version
        ? ((ut.needsLights && ut.lightsStateVersion !== Ft.state.version) ||
            ut.outputColorSpace !== nt ||
            (fe.isInstancedMesh && ut.instancing === !1) ||
            (!fe.isInstancedMesh && ut.instancing === !0) ||
            (fe.isSkinnedMesh && ut.skinning === !1) ||
            (!fe.isSkinnedMesh && ut.skinning === !0) ||
            ut.envMap !== it ||
            (ne.fog === !0 && ut.fog !== ze) ||
            (ut.numClippingPlanes !== void 0 &&
              (ut.numClippingPlanes !== Je.numPlanes ||
                ut.numIntersection !== Je.numIntersection)) ||
            ut.vertexAlphas !== xt ||
            ut.vertexTangents !== st ||
            ut.morphTargets !== ot ||
            ut.morphNormals !== jt ||
            ut.morphColors !== Kt ||
            ut.toneMapping !== Yr ||
            (Ae.isWebGL2 === !0 && ut.morphTargetsCount !== kt)) &&
          (at = !0)
        : ((at = !0), (ut.__version = ne.version));
      let rr = ut.currentProgram;
      at === !0 && (rr = ds(ne, ie, fe));
      let Dn = !1,
        wn = !1,
        Vi = !1;
      const cn = rr.getUniforms(),
        fn = ut.uniforms;
      if (
        (ve.useProgram(rr.program) && ((Dn = !0), (wn = !0), (Vi = !0)),
        ne.id !== L && ((L = ne.id), (wn = !0)),
        Dn || T !== z)
      ) {
        if (
          (cn.setValue(K, "projectionMatrix", z.projectionMatrix),
          Ae.logarithmicDepthBuffer &&
            cn.setValue(
              K,
              "logDepthBufFC",
              2 / (Math.log(z.far + 1) / Math.LN2)
            ),
          T !== z && ((T = z), (wn = !0), (Vi = !0)),
          ne.isShaderMaterial ||
            ne.isMeshPhongMaterial ||
            ne.isMeshToonMaterial ||
            ne.isMeshStandardMaterial ||
            ne.envMap)
        ) {
          const ir = cn.map.cameraPosition;
          ir !== void 0 &&
            ir.setValue(K, At.setFromMatrixPosition(z.matrixWorld));
        }
        (ne.isMeshPhongMaterial ||
          ne.isMeshToonMaterial ||
          ne.isMeshLambertMaterial ||
          ne.isMeshBasicMaterial ||
          ne.isMeshStandardMaterial ||
          ne.isShaderMaterial) &&
          cn.setValue(K, "isOrthographic", z.isOrthographicCamera === !0),
          (ne.isMeshPhongMaterial ||
            ne.isMeshToonMaterial ||
            ne.isMeshLambertMaterial ||
            ne.isMeshBasicMaterial ||
            ne.isMeshStandardMaterial ||
            ne.isShaderMaterial ||
            ne.isShadowMaterial ||
            fe.isSkinnedMesh) &&
            cn.setValue(K, "viewMatrix", z.matrixWorldInverse);
      }
      if (fe.isSkinnedMesh) {
        cn.setOptional(K, fe, "bindMatrix"),
          cn.setOptional(K, fe, "bindMatrixInverse");
        const ir = fe.skeleton;
        ir &&
          (Ae.floatVertexTextures
            ? (ir.boneTexture === null && ir.computeBoneTexture(),
              cn.setValue(K, "boneTexture", ir.boneTexture, Ue),
              cn.setValue(K, "boneTextureSize", ir.boneTextureSize))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      const wo = ce.morphAttributes;
      if (
        ((wo.position !== void 0 ||
          wo.normal !== void 0 ||
          (wo.color !== void 0 && Ae.isWebGL2 === !0)) &&
          qe.update(fe, ce, rr),
        (wn || ut.receiveShadow !== fe.receiveShadow) &&
          ((ut.receiveShadow = fe.receiveShadow),
          cn.setValue(K, "receiveShadow", fe.receiveShadow)),
        ne.isMeshGouraudMaterial &&
          ne.envMap !== null &&
          ((fn.envMap.value = it),
          (fn.flipEnvMap.value =
            it.isCubeTexture && it.isRenderTargetTexture === !1 ? -1 : 1)),
        wn &&
          (cn.setValue(K, "toneMappingExposure", A.toneMappingExposure),
          ut.needsLights && Q0(fn, Vi),
          ze && ne.fog === !0 && Me.refreshFogUniforms(fn, ze),
          Me.refreshMaterialUniforms(fn, ne, Q, Z, we),
          Qm.upload(K, ut.uniformsList, fn, Ue)),
        ne.isShaderMaterial &&
          ne.uniformsNeedUpdate === !0 &&
          (Qm.upload(K, ut.uniformsList, fn, Ue), (ne.uniformsNeedUpdate = !1)),
        ne.isSpriteMaterial && cn.setValue(K, "center", fe.center),
        cn.setValue(K, "modelViewMatrix", fe.modelViewMatrix),
        cn.setValue(K, "normalMatrix", fe.normalMatrix),
        cn.setValue(K, "modelMatrix", fe.matrixWorld),
        ne.isShaderMaterial || ne.isRawShaderMaterial)
      ) {
        const ir = ne.uniformsGroups;
        for (let jl = 0, Xl = ir.length; jl < Xl; jl++)
          if (Ae.isWebGL2) {
            const Jc = ir[jl];
            mt.update(Jc, rr), mt.bind(Jc, rr);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return rr;
    }
    function Q0(z, ie) {
      (z.ambientLightColor.needsUpdate = ie),
        (z.lightProbe.needsUpdate = ie),
        (z.directionalLights.needsUpdate = ie),
        (z.directionalLightShadows.needsUpdate = ie),
        (z.pointLights.needsUpdate = ie),
        (z.pointLightShadows.needsUpdate = ie),
        (z.spotLights.needsUpdate = ie),
        (z.spotLightShadows.needsUpdate = ie),
        (z.rectAreaLights.needsUpdate = ie),
        (z.hemisphereLights.needsUpdate = ie);
    }
    function q0(z) {
      return (
        z.isMeshLambertMaterial ||
        z.isMeshToonMaterial ||
        z.isMeshPhongMaterial ||
        z.isMeshStandardMaterial ||
        z.isShadowMaterial ||
        (z.isShaderMaterial && z.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return C;
    }),
      (this.getActiveMipmapLevel = function () {
        return R;
      }),
      (this.getRenderTarget = function () {
        return P;
      }),
      (this.setRenderTargetTextures = function (z, ie, ce) {
        (Oe.get(z.texture).__webglTexture = ie),
          (Oe.get(z.depthTexture).__webglTexture = ce);
        const ne = Oe.get(z);
        (ne.__hasExternalTextures = !0),
          ne.__hasExternalTextures &&
            ((ne.__autoAllocateDepthBuffer = ce === void 0),
            ne.__autoAllocateDepthBuffer ||
              (pe.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (ne.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (z, ie) {
        const ce = Oe.get(z);
        (ce.__webglFramebuffer = ie),
          (ce.__useDefaultFramebuffer = ie === void 0);
      }),
      (this.setRenderTarget = function (z, ie = 0, ce = 0) {
        (P = z), (C = ie), (R = ce);
        let ne = !0,
          fe = null,
          ze = !1,
          $e = !1;
        if (z) {
          const it = Oe.get(z);
          it.__useDefaultFramebuffer !== void 0
            ? (ve.bindFramebuffer(K.FRAMEBUFFER, null), (ne = !1))
            : it.__webglFramebuffer === void 0
            ? Ue.setupRenderTarget(z)
            : it.__hasExternalTextures &&
              Ue.rebindTextures(
                z,
                Oe.get(z.texture).__webglTexture,
                Oe.get(z.depthTexture).__webglTexture
              );
          const xt = z.texture;
          (xt.isData3DTexture ||
            xt.isDataArrayTexture ||
            xt.isCompressedArrayTexture) &&
            ($e = !0);
          const st = Oe.get(z).__webglFramebuffer;
          z.isWebGLCubeRenderTarget
            ? ((fe = st[ie]), (ze = !0))
            : Ae.isWebGL2 && z.samples > 0 && Ue.useMultisampledRTT(z) === !1
            ? (fe = Oe.get(z).__webglMultisampledFramebuffer)
            : (fe = st),
            B.copy(z.viewport),
            D.copy(z.scissor),
            (I = z.scissorTest);
        } else
          B.copy(G).multiplyScalar(Q).floor(),
            D.copy(X).multiplyScalar(Q).floor(),
            (I = Y);
        if (
          (ve.bindFramebuffer(K.FRAMEBUFFER, fe) &&
            Ae.drawBuffers &&
            ne &&
            ve.drawBuffers(z, fe),
          ve.viewport(B),
          ve.scissor(D),
          ve.setScissorTest(I),
          ze)
        ) {
          const it = Oe.get(z.texture);
          K.framebufferTexture2D(
            K.FRAMEBUFFER,
            K.COLOR_ATTACHMENT0,
            K.TEXTURE_CUBE_MAP_POSITIVE_X + ie,
            it.__webglTexture,
            ce
          );
        } else if ($e) {
          const it = Oe.get(z.texture),
            xt = ie || 0;
          K.framebufferTextureLayer(
            K.FRAMEBUFFER,
            K.COLOR_ATTACHMENT0,
            it.__webglTexture,
            ce || 0,
            xt
          );
        }
        L = -1;
      }),
      (this.readRenderTargetPixels = function (z, ie, ce, ne, fe, ze, $e) {
        if (!(z && z.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let nt = Oe.get(z).__webglFramebuffer;
        if ((z.isWebGLCubeRenderTarget && $e !== void 0 && (nt = nt[$e]), nt)) {
          ve.bindFramebuffer(K.FRAMEBUFFER, nt);
          try {
            const it = z.texture,
              xt = it.format,
              st = it.type;
            if (
              xt !== Nr &&
              Ve.convert(xt) !==
                K.getParameter(K.IMPLEMENTATION_COLOR_READ_FORMAT)
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            const ot =
              st === Ac &&
              (pe.has("EXT_color_buffer_half_float") ||
                (Ae.isWebGL2 && pe.has("EXT_color_buffer_float")));
            if (
              st !== Bs &&
              Ve.convert(st) !==
                K.getParameter(K.IMPLEMENTATION_COLOR_READ_TYPE) &&
              !(
                st === Cs &&
                (Ae.isWebGL2 ||
                  pe.has("OES_texture_float") ||
                  pe.has("WEBGL_color_buffer_float"))
              ) &&
              !ot
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            ie >= 0 &&
              ie <= z.width - ne &&
              ce >= 0 &&
              ce <= z.height - fe &&
              K.readPixels(ie, ce, ne, fe, Ve.convert(xt), Ve.convert(st), ze);
          } finally {
            const it = P !== null ? Oe.get(P).__webglFramebuffer : null;
            ve.bindFramebuffer(K.FRAMEBUFFER, it);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (z, ie, ce = 0) {
        const ne = Math.pow(2, -ce),
          fe = Math.floor(ie.image.width * ne),
          ze = Math.floor(ie.image.height * ne);
        Ue.setTexture2D(ie, 0),
          K.copyTexSubImage2D(K.TEXTURE_2D, ce, 0, 0, z.x, z.y, fe, ze),
          ve.unbindTexture();
      }),
      (this.copyTextureToTexture = function (z, ie, ce, ne = 0) {
        const fe = ie.image.width,
          ze = ie.image.height,
          $e = Ve.convert(ce.format),
          nt = Ve.convert(ce.type);
        Ue.setTexture2D(ce, 0),
          K.pixelStorei(K.UNPACK_FLIP_Y_WEBGL, ce.flipY),
          K.pixelStorei(K.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ce.premultiplyAlpha),
          K.pixelStorei(K.UNPACK_ALIGNMENT, ce.unpackAlignment),
          ie.isDataTexture
            ? K.texSubImage2D(
                K.TEXTURE_2D,
                ne,
                z.x,
                z.y,
                fe,
                ze,
                $e,
                nt,
                ie.image.data
              )
            : ie.isCompressedTexture
            ? K.compressedTexSubImage2D(
                K.TEXTURE_2D,
                ne,
                z.x,
                z.y,
                ie.mipmaps[0].width,
                ie.mipmaps[0].height,
                $e,
                ie.mipmaps[0].data
              )
            : K.texSubImage2D(K.TEXTURE_2D, ne, z.x, z.y, $e, nt, ie.image),
          ne === 0 && ce.generateMipmaps && K.generateMipmap(K.TEXTURE_2D),
          ve.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (z, ie, ce, ne, fe = 0) {
        if (A.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        const ze = z.max.x - z.min.x + 1,
          $e = z.max.y - z.min.y + 1,
          nt = z.max.z - z.min.z + 1,
          it = Ve.convert(ne.format),
          xt = Ve.convert(ne.type);
        let st;
        if (ne.isData3DTexture) Ue.setTexture3D(ne, 0), (st = K.TEXTURE_3D);
        else if (ne.isDataArrayTexture)
          Ue.setTexture2DArray(ne, 0), (st = K.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        K.pixelStorei(K.UNPACK_FLIP_Y_WEBGL, ne.flipY),
          K.pixelStorei(K.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ne.premultiplyAlpha),
          K.pixelStorei(K.UNPACK_ALIGNMENT, ne.unpackAlignment);
        const ot = K.getParameter(K.UNPACK_ROW_LENGTH),
          jt = K.getParameter(K.UNPACK_IMAGE_HEIGHT),
          Kt = K.getParameter(K.UNPACK_SKIP_PIXELS),
          Yr = K.getParameter(K.UNPACK_SKIP_ROWS),
          Qr = K.getParameter(K.UNPACK_SKIP_IMAGES),
          kt = ce.isCompressedTexture ? ce.mipmaps[0] : ce.image;
        K.pixelStorei(K.UNPACK_ROW_LENGTH, kt.width),
          K.pixelStorei(K.UNPACK_IMAGE_HEIGHT, kt.height),
          K.pixelStorei(K.UNPACK_SKIP_PIXELS, z.min.x),
          K.pixelStorei(K.UNPACK_SKIP_ROWS, z.min.y),
          K.pixelStorei(K.UNPACK_SKIP_IMAGES, z.min.z),
          ce.isDataTexture || ce.isData3DTexture
            ? K.texSubImage3D(
                st,
                fe,
                ie.x,
                ie.y,
                ie.z,
                ze,
                $e,
                nt,
                it,
                xt,
                kt.data
              )
            : ce.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              K.compressedTexSubImage3D(
                st,
                fe,
                ie.x,
                ie.y,
                ie.z,
                ze,
                $e,
                nt,
                it,
                kt.data
              ))
            : K.texSubImage3D(st, fe, ie.x, ie.y, ie.z, ze, $e, nt, it, xt, kt),
          K.pixelStorei(K.UNPACK_ROW_LENGTH, ot),
          K.pixelStorei(K.UNPACK_IMAGE_HEIGHT, jt),
          K.pixelStorei(K.UNPACK_SKIP_PIXELS, Kt),
          K.pixelStorei(K.UNPACK_SKIP_ROWS, Yr),
          K.pixelStorei(K.UNPACK_SKIP_IMAGES, Qr),
          fe === 0 && ne.generateMipmaps && K.generateMipmap(st),
          ve.unbindTexture();
      }),
      (this.initTexture = function (z) {
        z.isCubeTexture
          ? Ue.setTextureCube(z, 0)
          : z.isData3DTexture
          ? Ue.setTexture3D(z, 0)
          : z.isDataArrayTexture || z.isCompressedArrayTexture
          ? Ue.setTexture2DArray(z, 0)
          : Ue.setTexture2D(z, 0),
          ve.unbindTexture();
      }),
      (this.resetState = function () {
        (C = 0), (R = 0), (P = null), ve.reset(), We.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return Ts;
  }
  get physicallyCorrectLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
      ),
      !this.useLegacyLights
    );
  }
  set physicallyCorrectLights(e) {
    console.warn(
      "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
    ),
      (this.useLegacyLights = !e);
  }
  get outputEncoding() {
    return (
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
      ),
      this.outputColorSpace === ht ? fa : s1
    );
  }
  set outputEncoding(e) {
    console.warn(
      "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
    ),
      (this.outputColorSpace = e === fa ? ht : as);
  }
}
class W2 extends m1 {}
W2.prototype.isWebGL1Renderer = !0;
class w0 {
  constructor(e, t = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new Be(e)),
      (this.density = t);
  }
  clone() {
    return new w0(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class C0 {
  constructor(e, t = 1, r = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new Be(e)),
      (this.near = t),
      (this.far = r);
  }
  clone() {
    return new C0(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class Ig extends bt {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      t
    );
  }
}
class fd {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = Dh),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = ui());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, r) {
    (e *= this.stride), (r *= t.stride);
    for (let i = 0, s = this.stride; i < s; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ui()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      r = new this.constructor(t, this.stride);
    return r.setUsage(this.usage), r;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ui()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const Mr = new U();
class Sa {
  constructor(e, t, r, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = r),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.data.count; t < r; t++)
      Mr.fromBufferAttribute(this, t),
        Mr.applyMatrix4(e),
        this.setXYZ(t, Mr.x, Mr.y, Mr.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Mr.fromBufferAttribute(this, t),
        Mr.applyNormalMatrix(e),
        this.setXYZ(t, Mr.x, Mr.y, Mr.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Mr.fromBufferAttribute(this, t),
        Mr.transformDirection(e),
        this.setXYZ(t, Mr.x, Mr.y, Mr.z);
    return this;
  }
  setX(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = ai(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = ai(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = ai(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = ai(t, this.array)), t;
  }
  setXY(e, t, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = vt(t, this.array)), (r = vt(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = vt(t, this.array)),
        (r = vt(r, this.array)),
        (i = vt(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, r, i, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = vt(t, this.array)),
        (r = vt(r, this.array)),
        (i = vt(i, this.array)),
        (s = vt(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s]);
      }
      return new Dt(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Sa(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class g1 extends In {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new Be(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let Mu;
const Tf = new U(),
  Eu = new U(),
  wu = new U(),
  Cu = new ge(),
  bf = new ge(),
  j2 = new rt(),
  tm = new U(),
  Rf = new U(),
  nm = new U(),
  $C = new ge(),
  ty = new ge(),
  eT = new ge();
class X2 extends bt {
  constructor(e) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), Mu === void 0)
    ) {
      Mu = new dt();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        r = new fd(t, 5);
      Mu.setIndex([0, 1, 2, 0, 2, 3]),
        Mu.setAttribute("position", new Sa(r, 3, 0, !1)),
        Mu.setAttribute("uv", new Sa(r, 2, 3, !1));
    }
    (this.geometry = Mu),
      (this.material = e !== void 0 ? e : new g1()),
      (this.center = new ge(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      Eu.setFromMatrixScale(this.matrixWorld),
      j2.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      wu.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        Eu.multiplyScalar(-wu.z);
    const r = this.material.rotation;
    let i, s;
    r !== 0 && ((s = Math.cos(r)), (i = Math.sin(r)));
    const o = this.center;
    rm(tm.set(-0.5, -0.5, 0), wu, o, Eu, i, s),
      rm(Rf.set(0.5, -0.5, 0), wu, o, Eu, i, s),
      rm(nm.set(0.5, 0.5, 0), wu, o, Eu, i, s),
      $C.set(0, 0),
      ty.set(1, 0),
      eT.set(1, 1);
    let a = e.ray.intersectTriangle(tm, Rf, nm, !1, Tf);
    if (
      a === null &&
      (rm(Rf.set(-0.5, 0.5, 0), wu, o, Eu, i, s),
      ty.set(0, 1),
      (a = e.ray.intersectTriangle(tm, nm, Rf, !1, Tf)),
      a === null)
    )
      return;
    const l = e.ray.origin.distanceTo(Tf);
    l < e.near ||
      l > e.far ||
      t.push({
        distance: l,
        point: Tf.clone(),
        uv: Fr.getInterpolation(Tf, tm, Rf, nm, $C, ty, eT, new ge()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function rm(n, e, t, r, i, s) {
  Cu.subVectors(n, t).addScalar(0.5).multiply(r),
    i !== void 0
      ? ((bf.x = s * Cu.x - i * Cu.y), (bf.y = i * Cu.x + s * Cu.y))
      : bf.copy(Cu),
    n.copy(e),
    (n.x += bf.x),
    (n.y += bf.y),
    n.applyMatrix4(j2);
}
const im = new U(),
  tT = new U();
class J2 extends bt {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let r = 0, i = t.length; r < i; r++) {
      const s = t[r];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, t = 0, r = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let s;
    for (s = 0; s < i.length && !(t < i[s].distance); s++);
    return (
      i.splice(s, 0, { distance: t, hysteresis: r, object: e }),
      this.add(e),
      this
    );
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let r, i;
      for (r = 1, i = t.length; r < i; r++) {
        let s = t[r].distance;
        if ((t[r].object.visible && (s -= s * t[r].hysteresis), e < s)) break;
      }
      return t[r - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      im.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(im);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      im.setFromMatrixPosition(e.matrixWorld),
        tT.setFromMatrixPosition(this.matrixWorld);
      const r = im.distanceTo(tT) / e.zoom;
      t[0].object.visible = !0;
      let i, s;
      for (i = 1, s = t.length; i < s; i++) {
        let o = t[i].distance;
        if ((t[i].object.visible && (o -= o * t[i].hysteresis), r >= o))
          (t[i - 1].object.visible = !1), (t[i].object.visible = !0);
        else break;
      }
      for (this._currentLevel = i - 1; i < s; i++) t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []);
    const r = this.levels;
    for (let i = 0, s = r.length; i < s; i++) {
      const o = r[i];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis,
      });
    }
    return t;
  }
}
const nT = new U(),
  rT = new Nt(),
  iT = new Nt(),
  C9 = new U(),
  sT = new rt(),
  Tu = new U(),
  ny = new Gi(),
  oT = new rt(),
  ry = new Vc();
class _1 extends kn {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new rt()),
      (this.bindMatrixInverse = new rt()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new us()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      Tu.fromBufferAttribute(t, r),
        this.applyBoneTransform(r, Tu),
        this.boundingBox.expandByPoint(Tu);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Gi()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      Tu.fromBufferAttribute(t, r),
        this.applyBoneTransform(r, Tu),
        this.boundingSphere.expandByPoint(Tu);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const r = this.material,
      i = this.matrixWorld;
    r !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      ny.copy(this.boundingSphere),
      ny.applyMatrix4(i),
      e.ray.intersectsSphere(ny) !== !1 &&
        (oT.copy(i).invert(),
        ry.copy(e.ray).applyMatrix4(oT),
        !(
          this.boundingBox !== null && ry.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, ry)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Nt(),
      t = this.geometry.attributes.skinWeight;
    for (let r = 0, i = t.count; r < i; r++) {
      e.fromBufferAttribute(t, r);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(r, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === "attached"
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === "detached"
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const r = this.skeleton,
      i = this.geometry;
    rT.fromBufferAttribute(i.attributes.skinIndex, e),
      iT.fromBufferAttribute(i.attributes.skinWeight, e),
      nT.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = iT.getComponent(s);
      if (o !== 0) {
        const a = rT.getComponent(s);
        sT.multiplyMatrices(r.bones[a].matrixWorld, r.boneInverses[a]),
          t.addScaledVector(C9.copy(nT).applyMatrix4(sT), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return (
      console.warn(
        "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
      ),
      this.applyBoneTransform(e, t)
    );
  }
}
class T0 extends bt {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class ac extends en {
  constructor(e = null, t = 1, r = 1, i, s, o, a, l, u = mn, h = mn, d, p) {
    super(null, o, a, l, u, h, i, s, d, p),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: r }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const aT = new rt(),
  T9 = new rt();
class hd {
  constructor(e = [], t = []) {
    (this.uuid = ui()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let r = 0, i = this.bones.length; r < i; r++)
        this.boneInverses.push(new rt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = new rt();
      this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(r);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && r.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r &&
        (r.parent && r.parent.isBone
          ? (r.matrix.copy(r.parent.matrixWorld).invert(),
            r.matrix.multiply(r.matrixWorld))
          : r.matrix.copy(r.matrixWorld),
        r.matrix.decompose(r.position, r.quaternion, r.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      r = this.boneMatrices,
      i = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : T9;
      aT.multiplyMatrices(a, t[s]), aT.toArray(r, s * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new hd(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = b2(e)), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const r = new ac(t, e, e, Nr, Cs);
    return (
      (r.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = r),
      (this.boneTextureSize = e),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, r = this.bones.length; t < r; t++) {
      const i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let r = 0, i = e.bones.length; r < i; r++) {
      const s = e.bones[r];
      let o = t[s];
      o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (o = new T0())),
        this.bones.push(o),
        this.boneInverses.push(new rt().fromArray(e.boneInverses[r]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      r = this.boneInverses;
    for (let i = 0, s = t.length; i < s; i++) {
      const o = t[i];
      e.bones.push(o.uuid);
      const a = r[i];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class Cc extends Dt {
  constructor(e, t, r, i = 1) {
    super(e, t, r),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const bu = new rt(),
  lT = new rt(),
  sm = [],
  uT = new us(),
  b9 = new rt(),
  Pf = new kn(),
  Bf = new Gi();
class v1 extends kn {
  constructor(e, t, r) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new Cc(new Float32Array(r * 16), 16)),
      (this.instanceColor = null),
      (this.count = r),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < r; i++) this.setMatrixAt(i, b9);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new us()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, bu),
        uT.copy(e.boundingBox).applyMatrix4(bu),
        this.boundingBox.union(uT);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Gi()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, bu),
        Bf.copy(e.boundingSphere).applyMatrix4(bu),
        this.boundingSphere.union(Bf);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const r = this.matrixWorld,
      i = this.count;
    if (
      ((Pf.geometry = this.geometry),
      (Pf.material = this.material),
      Pf.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Bf.copy(this.boundingSphere),
        Bf.applyMatrix4(r),
        e.ray.intersectsSphere(Bf) !== !1))
    )
      for (let s = 0; s < i; s++) {
        this.getMatrixAt(s, bu),
          lT.multiplyMatrices(r, bu),
          (Pf.matrixWorld = lT),
          Pf.raycast(e, sm);
        for (let o = 0, a = sm.length; o < a; o++) {
          const l = sm[o];
          (l.instanceId = s), (l.object = this), t.push(l);
        }
        sm.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new Cc(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class yr extends In {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Be(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const cT = new U(),
  fT = new U(),
  hT = new rt(),
  iy = new Vc(),
  om = new Gi();
class vo extends bt {
  constructor(e = new dt(), t = new yr()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        r = [0];
      for (let i = 1, s = t.count; i < s; i++)
        cT.fromBufferAttribute(t, i - 1),
          fT.fromBufferAttribute(t, i),
          (r[i] = r[i - 1]),
          (r[i] += cT.distanceTo(fT));
      e.setAttribute("lineDistance", new Xe(r, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.matrixWorld,
      s = e.params.Line.threshold,
      o = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      om.copy(r.boundingSphere),
      om.applyMatrix4(i),
      (om.radius += s),
      e.ray.intersectsSphere(om) === !1)
    )
      return;
    hT.copy(i).invert(), iy.copy(e.ray).applyMatrix4(hT);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      u = new U(),
      h = new U(),
      d = new U(),
      p = new U(),
      m = this.isLineSegments ? 2 : 1,
      _ = r.index,
      x = r.attributes.position;
    if (_ !== null) {
      const g = Math.max(0, o.start),
        S = Math.min(_.count, o.start + o.count);
      for (let A = g, E = S - 1; A < E; A += m) {
        const C = _.getX(A),
          R = _.getX(A + 1);
        if (
          (u.fromBufferAttribute(x, C),
          h.fromBufferAttribute(x, R),
          iy.distanceSqToSegment(u, h, p, d) > l)
        )
          continue;
        p.applyMatrix4(this.matrixWorld);
        const L = e.ray.origin.distanceTo(p);
        L < e.near ||
          L > e.far ||
          t.push({
            distance: L,
            point: d.clone().applyMatrix4(this.matrixWorld),
            index: A,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const g = Math.max(0, o.start),
        S = Math.min(x.count, o.start + o.count);
      for (let A = g, E = S - 1; A < E; A += m) {
        if (
          (u.fromBufferAttribute(x, A),
          h.fromBufferAttribute(x, A + 1),
          iy.distanceSqToSegment(u, h, p, d) > l)
        )
          continue;
        p.applyMatrix4(this.matrixWorld);
        const R = e.ray.origin.distanceTo(p);
        R < e.near ||
          R > e.far ||
          t.push({
            distance: R,
            point: d.clone().applyMatrix4(this.matrixWorld),
            index: A,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = i.length; s < o; s++) {
          const a = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
const dT = new U(),
  pT = new U();
class cs extends vo {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        r = [];
      for (let i = 0, s = t.count; i < s; i += 2)
        dT.fromBufferAttribute(t, i),
          pT.fromBufferAttribute(t, i + 1),
          (r[i] = i === 0 ? 0 : r[i - 1]),
          (r[i + 1] = r[i] + dT.distanceTo(pT));
      e.setAttribute("lineDistance", new Xe(r, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class y1 extends vo {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class b0 extends In {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Be(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const mT = new rt(),
  yS = new Vc(),
  am = new Gi(),
  lm = new U();
class x1 extends bt {
  constructor(e = new dt(), t = new b0()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.matrixWorld,
      s = e.params.Points.threshold,
      o = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      am.copy(r.boundingSphere),
      am.applyMatrix4(i),
      (am.radius += s),
      e.ray.intersectsSphere(am) === !1)
    )
      return;
    mT.copy(i).invert(), yS.copy(e.ray).applyMatrix4(mT);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      u = r.index,
      d = r.attributes.position;
    if (u !== null) {
      const p = Math.max(0, o.start),
        m = Math.min(u.count, o.start + o.count);
      for (let _ = p, y = m; _ < y; _++) {
        const x = u.getX(_);
        lm.fromBufferAttribute(d, x), gT(lm, x, l, i, e, t, this);
      }
    } else {
      const p = Math.max(0, o.start),
        m = Math.min(d.count, o.start + o.count);
      for (let _ = p, y = m; _ < y; _++)
        lm.fromBufferAttribute(d, _), gT(lm, _, l, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = i.length; s < o; s++) {
          const a = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
function gT(n, e, t, r, i, s, o) {
  const a = yS.distanceSqToPoint(n);
  if (a < t) {
    const l = new U();
    yS.closestPointToPoint(n, l), l.applyMatrix4(r);
    const u = i.ray.origin.distanceTo(l);
    if (u < i.near || u > i.far) return;
    s.push({
      distance: u,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      object: o,
    });
  }
}
class R9 extends en {
  constructor(e, t, r, i, s, o, a, l, u) {
    super(e, t, r, i, s, o, a, l, u),
      (this.isVideoTexture = !0),
      (this.minFilter = o !== void 0 ? o : sn),
      (this.magFilter = s !== void 0 ? s : sn),
      (this.generateMipmaps = !1);
    const h = this;
    function d() {
      (h.needsUpdate = !0), e.requestVideoFrameCallback(d);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class P9 extends en {
  constructor(e, t) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = mn),
      (this.minFilter = mn),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class S1 extends en {
  constructor(e, t, r, i, s, o, a, l, u, h, d, p) {
    super(null, o, a, l, u, h, i, s, d, p),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: r }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class B9 extends S1 {
  constructor(e, t, r, i, s, o) {
    super(e, t, r, s, o),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = i),
      (this.wrapR = er);
  }
}
class L9 extends en {
  constructor(e, t, r, i, s, o, a, l, u) {
    super(e, t, r, i, s, o, a, l, u),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class fs {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPointAt(r / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r,
      i = this.getPoint(0),
      s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      (r = this.getPoint(o / e)), (s += r.distanceTo(i)), t.push(s), (i = r);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const r = this.getLengths();
    let i = 0;
    const s = r.length;
    let o;
    t ? (o = t) : (o = e * r[s - 1]);
    let a = 0,
      l = s - 1,
      u;
    for (; a <= l; )
      if (((i = Math.floor(a + (l - a) / 2)), (u = r[i] - o), u < 0)) a = i + 1;
      else if (u > 0) l = i - 1;
      else {
        l = i;
        break;
      }
    if (((i = l), r[i] === o)) return i / (s - 1);
    const h = r[i],
      p = r[i + 1] - h,
      m = (o - h) / p;
    return (i + m) / (s - 1);
  }
  getTangent(e, t) {
    let i = e - 1e-4,
      s = e + 1e-4;
    i < 0 && (i = 0), s > 1 && (s = 1);
    const o = this.getPoint(i),
      a = this.getPoint(s),
      l = t || (o.isVector2 ? new ge() : new U());
    return l.copy(a).sub(o).normalize(), l;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t) {
    const r = new U(),
      i = [],
      s = [],
      o = [],
      a = new U(),
      l = new rt();
    for (let m = 0; m <= e; m++) {
      const _ = m / e;
      i[m] = this.getTangentAt(_, new U());
    }
    (s[0] = new U()), (o[0] = new U());
    let u = Number.MAX_VALUE;
    const h = Math.abs(i[0].x),
      d = Math.abs(i[0].y),
      p = Math.abs(i[0].z);
    h <= u && ((u = h), r.set(1, 0, 0)),
      d <= u && ((u = d), r.set(0, 1, 0)),
      p <= u && r.set(0, 0, 1),
      a.crossVectors(i[0], r).normalize(),
      s[0].crossVectors(i[0], a),
      o[0].crossVectors(i[0], s[0]);
    for (let m = 1; m <= e; m++) {
      if (
        ((s[m] = s[m - 1].clone()),
        (o[m] = o[m - 1].clone()),
        a.crossVectors(i[m - 1], i[m]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        const _ = Math.acos(gn(i[m - 1].dot(i[m]), -1, 1));
        s[m].applyMatrix4(l.makeRotationAxis(a, _));
      }
      o[m].crossVectors(i[m], s[m]);
    }
    if (t === !0) {
      let m = Math.acos(gn(s[0].dot(s[e]), -1, 1));
      (m /= e), i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m);
      for (let _ = 1; _ <= e; _++)
        s[_].applyMatrix4(l.makeRotationAxis(i[_], m * _)),
          o[_].crossVectors(i[_], s[_]);
    }
    return { tangents: i, normals: s, binormals: o };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class R0 extends fs {
  constructor(
    e = 0,
    t = 0,
    r = 1,
    i = 1,
    s = 0,
    o = Math.PI * 2,
    a = !1,
    l = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = r),
      (this.yRadius = i),
      (this.aStartAngle = s),
      (this.aEndAngle = o),
      (this.aClockwise = a),
      (this.aRotation = l);
  }
  getPoint(e, t) {
    const r = t || new ge(),
      i = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += i;
    for (; s > i; ) s -= i;
    s < Number.EPSILON && (o ? (s = 0) : (s = i)),
      this.aClockwise === !0 && !o && (s === i ? (s = -i) : (s = s - i));
    const a = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(a),
      u = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation),
        d = Math.sin(this.aRotation),
        p = l - this.aX,
        m = u - this.aY;
      (l = p * h - m * d + this.aX), (u = p * d + m * h + this.aY);
    }
    return r.set(l, u);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class K2 extends R0 {
  constructor(e, t, r, i, s, o) {
    super(e, t, r, r, i, s, o),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function A1() {
  let n = 0,
    e = 0,
    t = 0,
    r = 0;
  function i(s, o, a, l) {
    (n = s),
      (e = a),
      (t = -3 * s + 3 * o - 2 * a - l),
      (r = 2 * s - 2 * o + a + l);
  }
  return {
    initCatmullRom: function (s, o, a, l, u) {
      i(o, a, u * (a - s), u * (l - o));
    },
    initNonuniformCatmullRom: function (s, o, a, l, u, h, d) {
      let p = (o - s) / u - (a - s) / (u + h) + (a - o) / h,
        m = (a - o) / h - (l - o) / (h + d) + (l - a) / d;
      (p *= h), (m *= h), i(o, a, p, m);
    },
    calc: function (s) {
      const o = s * s,
        a = o * s;
      return n + e * s + t * o + r * a;
    },
  };
}
const um = new U(),
  sy = new A1(),
  oy = new A1(),
  ay = new A1();
class Y2 extends fs {
  constructor(e = [], t = !1, r = "centripetal", i = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = r),
      (this.tension = i);
  }
  getPoint(e, t = new U()) {
    const r = t,
      i = this.points,
      s = i.length,
      o = (s - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o),
      l = o - a;
    this.closed
      ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s)
      : l === 0 && a === s - 1 && ((a = s - 2), (l = 1));
    let u, h;
    this.closed || a > 0
      ? (u = i[(a - 1) % s])
      : (um.subVectors(i[0], i[1]).add(i[0]), (u = um));
    const d = i[a % s],
      p = i[(a + 1) % s];
    if (
      (this.closed || a + 2 < s
        ? (h = i[(a + 2) % s])
        : (um.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), (h = um)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const m = this.curveType === "chordal" ? 0.5 : 0.25;
      let _ = Math.pow(u.distanceToSquared(d), m),
        y = Math.pow(d.distanceToSquared(p), m),
        x = Math.pow(p.distanceToSquared(h), m);
      y < 1e-4 && (y = 1),
        _ < 1e-4 && (_ = y),
        x < 1e-4 && (x = y),
        sy.initNonuniformCatmullRom(u.x, d.x, p.x, h.x, _, y, x),
        oy.initNonuniformCatmullRom(u.y, d.y, p.y, h.y, _, y, x),
        ay.initNonuniformCatmullRom(u.z, d.z, p.z, h.z, _, y, x);
    } else
      this.curveType === "catmullrom" &&
        (sy.initCatmullRom(u.x, d.x, p.x, h.x, this.tension),
        oy.initCatmullRom(u.y, d.y, p.y, h.y, this.tension),
        ay.initCatmullRom(u.z, d.z, p.z, h.z, this.tension));
    return r.set(sy.calc(l), oy.calc(l), ay.calc(l)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new U().fromArray(i));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function _T(n, e, t, r, i) {
  const s = (r - e) * 0.5,
    o = (i - t) * 0.5,
    a = n * n,
    l = n * a;
  return (
    (2 * t - 2 * r + s + o) * l + (-3 * t + 3 * r - 2 * s - o) * a + s * n + t
  );
}
function I9(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function D9(n, e) {
  return 2 * (1 - n) * n * e;
}
function F9(n, e) {
  return n * n * e;
}
function sh(n, e, t, r) {
  return I9(n, e) + D9(n, t) + F9(n, r);
}
function N9(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function O9(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function U9(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function k9(n, e) {
  return n * n * n * e;
}
function oh(n, e, t, r, i) {
  return N9(n, e) + O9(n, t) + U9(n, r) + k9(n, i);
}
class M1 extends fs {
  constructor(e = new ge(), t = new ge(), r = new ge(), i = new ge()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, t = new ge()) {
    const r = t,
      i = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return r.set(oh(e, i.x, s.x, o.x, a.x), oh(e, i.y, s.y, o.y, a.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class Q2 extends fs {
  constructor(e = new U(), t = new U(), r = new U(), i = new U()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, t = new U()) {
    const r = t,
      i = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return (
      r.set(
        oh(e, i.x, s.x, o.x, a.x),
        oh(e, i.y, s.y, o.y, a.y),
        oh(e, i.z, s.z, o.z, a.z)
      ),
      r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class P0 extends fs {
  constructor(e = new ge(), t = new ge()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new ge()) {
    const r = t;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new ge()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class q2 extends fs {
  constructor(e = new U(), t = new U()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new U()) {
    const r = t;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new U()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class E1 extends fs {
  constructor(e = new ge(), t = new ge(), r = new ge()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r);
  }
  getPoint(e, t = new ge()) {
    const r = t,
      i = this.v0,
      s = this.v1,
      o = this.v2;
    return r.set(sh(e, i.x, s.x, o.x), sh(e, i.y, s.y, o.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class w1 extends fs {
  constructor(e = new U(), t = new U(), r = new U()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r);
  }
  getPoint(e, t = new U()) {
    const r = t,
      i = this.v0,
      s = this.v1,
      o = this.v2;
    return (
      r.set(sh(e, i.x, s.x, o.x), sh(e, i.y, s.y, o.y), sh(e, i.z, s.z, o.z)), r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class C1 extends fs {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new ge()) {
    const r = t,
      i = this.points,
      s = (i.length - 1) * e,
      o = Math.floor(s),
      a = s - o,
      l = i[o === 0 ? o : o - 1],
      u = i[o],
      h = i[o > i.length - 2 ? i.length - 1 : o + 1],
      d = i[o > i.length - 3 ? i.length - 1 : o + 2];
    return r.set(_T(a, l.x, u.x, h.x, d.x), _T(a, l.y, u.y, h.y, d.y)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new ge().fromArray(i));
    }
    return this;
  }
}
var T1 = Object.freeze({
  __proto__: null,
  ArcCurve: K2,
  CatmullRomCurve3: Y2,
  CubicBezierCurve: M1,
  CubicBezierCurve3: Q2,
  EllipseCurve: R0,
  LineCurve: P0,
  LineCurve3: q2,
  QuadraticBezierCurve: E1,
  QuadraticBezierCurve3: w1,
  SplineCurve: C1,
});
class Z2 extends fs {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new P0(t, e));
  }
  getPoint(e, t) {
    const r = e * this.getLength(),
      i = this.getCurveLengths();
    let s = 0;
    for (; s < i.length; ) {
      if (i[s] >= r) {
        const o = i[s] - r,
          a = this.curves[s],
          l = a.getLength(),
          u = l === 0 ? 0 : 1 - o / l;
        return a.getPointAt(u, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, i = this.curves.length; r < i; r++)
      (t += this.curves[r].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let i = 0, s = this.curves; i < s.length; i++) {
      const o = s[i],
        a = o.isEllipseCurve
          ? e * 2
          : o.isLineCurve || o.isLineCurve3
          ? 1
          : o.isSplineCurve
          ? e * o.points.length
          : e,
        l = o.getPoints(a);
      for (let u = 0; u < l.length; u++) {
        const h = l[u];
        (r && r.equals(h)) || (t.push(h), (r = h));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(new T1[i.type]().fromJSON(i));
    }
    return this;
  }
}
class Oh extends Z2 {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new ge()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new P0(this.currentPoint.clone(), new ge(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    const s = new E1(this.currentPoint.clone(), new ge(e, t), new ge(r, i));
    return this.curves.push(s), this.currentPoint.set(r, i), this;
  }
  bezierCurveTo(e, t, r, i, s, o) {
    const a = new M1(
      this.currentPoint.clone(),
      new ge(e, t),
      new ge(r, i),
      new ge(s, o)
    );
    return this.curves.push(a), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      r = new C1(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, i, s, o) {
    const a = this.currentPoint.x,
      l = this.currentPoint.y;
    return this.absarc(e + a, t + l, r, i, s, o), this;
  }
  absarc(e, t, r, i, s, o) {
    return this.absellipse(e, t, r, r, i, s, o), this;
  }
  ellipse(e, t, r, i, s, o, a, l) {
    const u = this.currentPoint.x,
      h = this.currentPoint.y;
    return this.absellipse(e + u, t + h, r, i, s, o, a, l), this;
  }
  absellipse(e, t, r, i, s, o, a, l) {
    const u = new R0(e, t, r, i, s, o, a, l);
    if (this.curves.length > 0) {
      const d = u.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(u);
    const h = u.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class dd extends dt {
  constructor(
    e = [new ge(0, -0.5), new ge(0.5, 0), new ge(0, 0.5)],
    t = 12,
    r = 0,
    i = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: r, phiLength: i }),
      (t = Math.floor(t)),
      (i = gn(i, 0, Math.PI * 2));
    const s = [],
      o = [],
      a = [],
      l = [],
      u = [],
      h = 1 / t,
      d = new U(),
      p = new ge(),
      m = new U(),
      _ = new U(),
      y = new U();
    let x = 0,
      g = 0;
    for (let S = 0; S <= e.length - 1; S++)
      switch (S) {
        case 0:
          (x = e[S + 1].x - e[S].x),
            (g = e[S + 1].y - e[S].y),
            (m.x = g * 1),
            (m.y = -x),
            (m.z = g * 0),
            y.copy(m),
            m.normalize(),
            l.push(m.x, m.y, m.z);
          break;
        case e.length - 1:
          l.push(y.x, y.y, y.z);
          break;
        default:
          (x = e[S + 1].x - e[S].x),
            (g = e[S + 1].y - e[S].y),
            (m.x = g * 1),
            (m.y = -x),
            (m.z = g * 0),
            _.copy(m),
            (m.x += y.x),
            (m.y += y.y),
            (m.z += y.z),
            m.normalize(),
            l.push(m.x, m.y, m.z),
            y.copy(_);
      }
    for (let S = 0; S <= t; S++) {
      const A = r + S * h * i,
        E = Math.sin(A),
        C = Math.cos(A);
      for (let R = 0; R <= e.length - 1; R++) {
        (d.x = e[R].x * E),
          (d.y = e[R].y),
          (d.z = e[R].x * C),
          o.push(d.x, d.y, d.z),
          (p.x = S / t),
          (p.y = R / (e.length - 1)),
          a.push(p.x, p.y);
        const P = l[3 * R + 0] * E,
          L = l[3 * R + 1],
          T = l[3 * R + 0] * C;
        u.push(P, L, T);
      }
    }
    for (let S = 0; S < t; S++)
      for (let A = 0; A < e.length - 1; A++) {
        const E = A + S * e.length,
          C = E,
          R = E + e.length,
          P = E + e.length + 1,
          L = E + 1;
        s.push(C, R, L), s.push(P, L, R);
      }
    this.setIndex(s),
      this.setAttribute("position", new Xe(o, 3)),
      this.setAttribute("uv", new Xe(a, 2)),
      this.setAttribute("normal", new Xe(u, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new dd(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class B0 extends dd {
  constructor(e = 1, t = 1, r = 4, i = 8) {
    const s = new Oh();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
      s.absarc(0, t / 2, e, 0, Math.PI * 0.5),
      super(s.getPoints(r), i),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        capSegments: r,
        radialSegments: i,
      });
  }
  static fromJSON(e) {
    return new B0(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class L0 extends dt {
  constructor(e = 1, t = 32, r = 0, i = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: r,
        thetaLength: i,
      }),
      (t = Math.max(3, t));
    const s = [],
      o = [],
      a = [],
      l = [],
      u = new U(),
      h = new ge();
    o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
    for (let d = 0, p = 3; d <= t; d++, p += 3) {
      const m = r + (d / t) * i;
      (u.x = e * Math.cos(m)),
        (u.y = e * Math.sin(m)),
        o.push(u.x, u.y, u.z),
        a.push(0, 0, 1),
        (h.x = (o[p] / e + 1) / 2),
        (h.y = (o[p + 1] / e + 1) / 2),
        l.push(h.x, h.y);
    }
    for (let d = 1; d <= t; d++) s.push(d, d + 1, 0);
    this.setIndex(s),
      this.setAttribute("position", new Xe(o, 3)),
      this.setAttribute("normal", new Xe(a, 3)),
      this.setAttribute("uv", new Xe(l, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new L0(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class jc extends dt {
  constructor(
    e = 1,
    t = 1,
    r = 1,
    i = 32,
    s = 1,
    o = !1,
    a = 0,
    l = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: r,
        radialSegments: i,
        heightSegments: s,
        openEnded: o,
        thetaStart: a,
        thetaLength: l,
      });
    const u = this;
    (i = Math.floor(i)), (s = Math.floor(s));
    const h = [],
      d = [],
      p = [],
      m = [];
    let _ = 0;
    const y = [],
      x = r / 2;
    let g = 0;
    S(),
      o === !1 && (e > 0 && A(!0), t > 0 && A(!1)),
      this.setIndex(h),
      this.setAttribute("position", new Xe(d, 3)),
      this.setAttribute("normal", new Xe(p, 3)),
      this.setAttribute("uv", new Xe(m, 2));
    function S() {
      const E = new U(),
        C = new U();
      let R = 0;
      const P = (t - e) / r;
      for (let L = 0; L <= s; L++) {
        const T = [],
          B = L / s,
          D = B * (t - e) + e;
        for (let I = 0; I <= i; I++) {
          const F = I / i,
            k = F * l + a,
            j = Math.sin(k),
            Z = Math.cos(k);
          (C.x = D * j),
            (C.y = -B * r + x),
            (C.z = D * Z),
            d.push(C.x, C.y, C.z),
            E.set(j, P, Z).normalize(),
            p.push(E.x, E.y, E.z),
            m.push(F, 1 - B),
            T.push(_++);
        }
        y.push(T);
      }
      for (let L = 0; L < i; L++)
        for (let T = 0; T < s; T++) {
          const B = y[T][L],
            D = y[T + 1][L],
            I = y[T + 1][L + 1],
            F = y[T][L + 1];
          h.push(B, D, F), h.push(D, I, F), (R += 6);
        }
      u.addGroup(g, R, 0), (g += R);
    }
    function A(E) {
      const C = _,
        R = new ge(),
        P = new U();
      let L = 0;
      const T = E === !0 ? e : t,
        B = E === !0 ? 1 : -1;
      for (let I = 1; I <= i; I++)
        d.push(0, x * B, 0), p.push(0, B, 0), m.push(0.5, 0.5), _++;
      const D = _;
      for (let I = 0; I <= i; I++) {
        const k = (I / i) * l + a,
          j = Math.cos(k),
          Z = Math.sin(k);
        (P.x = T * Z),
          (P.y = x * B),
          (P.z = T * j),
          d.push(P.x, P.y, P.z),
          p.push(0, B, 0),
          (R.x = j * 0.5 + 0.5),
          (R.y = Z * 0.5 * B + 0.5),
          m.push(R.x, R.y),
          _++;
      }
      for (let I = 0; I < i; I++) {
        const F = C + I,
          k = D + I;
        E === !0 ? h.push(k, k + 1, F) : h.push(k + 1, k, F), (L += 3);
      }
      u.addGroup(g, L, E === !0 ? 1 : 2), (g += L);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new jc(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class pd extends jc {
  constructor(e = 1, t = 1, r = 32, i = 1, s = !1, o = 0, a = Math.PI * 2) {
    super(0, e, t, r, i, s, o, a),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: r,
        heightSegments: i,
        openEnded: s,
        thetaStart: o,
        thetaLength: a,
      });
  }
  static fromJSON(e) {
    return new pd(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Pa extends dt {
  constructor(e = [], t = [], r = 1, i = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: r, detail: i });
    const s = [],
      o = [];
    a(i),
      u(r),
      h(),
      this.setAttribute("position", new Xe(s, 3)),
      this.setAttribute("normal", new Xe(s.slice(), 3)),
      this.setAttribute("uv", new Xe(o, 2)),
      i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(S) {
      const A = new U(),
        E = new U(),
        C = new U();
      for (let R = 0; R < t.length; R += 3)
        m(t[R + 0], A), m(t[R + 1], E), m(t[R + 2], C), l(A, E, C, S);
    }
    function l(S, A, E, C) {
      const R = C + 1,
        P = [];
      for (let L = 0; L <= R; L++) {
        P[L] = [];
        const T = S.clone().lerp(E, L / R),
          B = A.clone().lerp(E, L / R),
          D = R - L;
        for (let I = 0; I <= D; I++)
          I === 0 && L === R
            ? (P[L][I] = T)
            : (P[L][I] = T.clone().lerp(B, I / D));
      }
      for (let L = 0; L < R; L++)
        for (let T = 0; T < 2 * (R - L) - 1; T++) {
          const B = Math.floor(T / 2);
          T % 2 === 0
            ? (p(P[L][B + 1]), p(P[L + 1][B]), p(P[L][B]))
            : (p(P[L][B + 1]), p(P[L + 1][B + 1]), p(P[L + 1][B]));
        }
    }
    function u(S) {
      const A = new U();
      for (let E = 0; E < s.length; E += 3)
        (A.x = s[E + 0]),
          (A.y = s[E + 1]),
          (A.z = s[E + 2]),
          A.normalize().multiplyScalar(S),
          (s[E + 0] = A.x),
          (s[E + 1] = A.y),
          (s[E + 2] = A.z);
    }
    function h() {
      const S = new U();
      for (let A = 0; A < s.length; A += 3) {
        (S.x = s[A + 0]), (S.y = s[A + 1]), (S.z = s[A + 2]);
        const E = x(S) / 2 / Math.PI + 0.5,
          C = g(S) / Math.PI + 0.5;
        o.push(E, 1 - C);
      }
      _(), d();
    }
    function d() {
      for (let S = 0; S < o.length; S += 6) {
        const A = o[S + 0],
          E = o[S + 2],
          C = o[S + 4],
          R = Math.max(A, E, C),
          P = Math.min(A, E, C);
        R > 0.9 &&
          P < 0.1 &&
          (A < 0.2 && (o[S + 0] += 1),
          E < 0.2 && (o[S + 2] += 1),
          C < 0.2 && (o[S + 4] += 1));
      }
    }
    function p(S) {
      s.push(S.x, S.y, S.z);
    }
    function m(S, A) {
      const E = S * 3;
      (A.x = e[E + 0]), (A.y = e[E + 1]), (A.z = e[E + 2]);
    }
    function _() {
      const S = new U(),
        A = new U(),
        E = new U(),
        C = new U(),
        R = new ge(),
        P = new ge(),
        L = new ge();
      for (let T = 0, B = 0; T < s.length; T += 9, B += 6) {
        S.set(s[T + 0], s[T + 1], s[T + 2]),
          A.set(s[T + 3], s[T + 4], s[T + 5]),
          E.set(s[T + 6], s[T + 7], s[T + 8]),
          R.set(o[B + 0], o[B + 1]),
          P.set(o[B + 2], o[B + 3]),
          L.set(o[B + 4], o[B + 5]),
          C.copy(S).add(A).add(E).divideScalar(3);
        const D = x(C);
        y(R, B + 0, S, D), y(P, B + 2, A, D), y(L, B + 4, E, D);
      }
    }
    function y(S, A, E, C) {
      C < 0 && S.x === 1 && (o[A] = S.x - 1),
        E.x === 0 && E.z === 0 && (o[A] = C / 2 / Math.PI + 0.5);
    }
    function x(S) {
      return Math.atan2(S.z, -S.x);
    }
    function g(S) {
      return Math.atan2(-S.y, Math.sqrt(S.x * S.x + S.z * S.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Pa(e.vertices, e.indices, e.radius, e.details);
  }
}
class I0 extends Pa {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = 1 / r,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        0,
        -r,
        0,
        -i,
        r,
        0,
        -i,
        -r,
        0,
        i,
        r,
        0,
        i,
      ],
      o = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(s, o, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new I0(e.radius, e.detail);
  }
}
const cm = new U(),
  fm = new U(),
  ly = new U(),
  hm = new Fr();
class $2 extends dt {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const i = Math.pow(10, 4),
        s = Math.cos(xl * t),
        o = e.getIndex(),
        a = e.getAttribute("position"),
        l = o ? o.count : a.count,
        u = [0, 0, 0],
        h = ["a", "b", "c"],
        d = new Array(3),
        p = {},
        m = [];
      for (let _ = 0; _ < l; _ += 3) {
        o
          ? ((u[0] = o.getX(_)), (u[1] = o.getX(_ + 1)), (u[2] = o.getX(_ + 2)))
          : ((u[0] = _), (u[1] = _ + 1), (u[2] = _ + 2));
        const { a: y, b: x, c: g } = hm;
        if (
          (y.fromBufferAttribute(a, u[0]),
          x.fromBufferAttribute(a, u[1]),
          g.fromBufferAttribute(a, u[2]),
          hm.getNormal(ly),
          (d[0] = `${Math.round(y.x * i)},${Math.round(y.y * i)},${Math.round(
            y.z * i
          )}`),
          (d[1] = `${Math.round(x.x * i)},${Math.round(x.y * i)},${Math.round(
            x.z * i
          )}`),
          (d[2] = `${Math.round(g.x * i)},${Math.round(g.y * i)},${Math.round(
            g.z * i
          )}`),
          !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0]))
        )
          for (let S = 0; S < 3; S++) {
            const A = (S + 1) % 3,
              E = d[S],
              C = d[A],
              R = hm[h[S]],
              P = hm[h[A]],
              L = `${E}_${C}`,
              T = `${C}_${E}`;
            T in p && p[T]
              ? (ly.dot(p[T].normal) <= s &&
                  (m.push(R.x, R.y, R.z), m.push(P.x, P.y, P.z)),
                (p[T] = null))
              : L in p ||
                (p[L] = { index0: u[S], index1: u[A], normal: ly.clone() });
          }
      }
      for (const _ in p)
        if (p[_]) {
          const { index0: y, index1: x } = p[_];
          cm.fromBufferAttribute(a, y),
            fm.fromBufferAttribute(a, x),
            m.push(cm.x, cm.y, cm.z),
            m.push(fm.x, fm.y, fm.z);
        }
      this.setAttribute("position", new Xe(m, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class Al extends Oh {
  constructor(e) {
    super(e), (this.uuid = ui()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, i = this.holes.length; r < i; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(new Oh().fromJSON(i));
    }
    return this;
  }
}
const z9 = {
  triangulate: function (n, e, t = 2) {
    const r = e && e.length,
      i = r ? e[0] * t : n.length;
    let s = eL(n, 0, i, t, !0);
    const o = [];
    if (!s || s.next === s.prev) return o;
    let a, l, u, h, d, p, m;
    if ((r && (s = j9(n, e, s, t)), n.length > 80 * t)) {
      (a = u = n[0]), (l = h = n[1]);
      for (let _ = t; _ < i; _ += t)
        (d = n[_]),
          (p = n[_ + 1]),
          d < a && (a = d),
          p < l && (l = p),
          d > u && (u = d),
          p > h && (h = p);
      (m = Math.max(u - a, h - l)), (m = m !== 0 ? 32767 / m : 0);
    }
    return Uh(s, o, t, a, l, m, 0), o;
  },
};
function eL(n, e, t, r, i) {
  let s, o;
  if (i === n8(n, e, t, r) > 0)
    for (s = e; s < t; s += r) o = vT(s, n[s], n[s + 1], o);
  else for (s = t - r; s >= e; s -= r) o = vT(s, n[s], n[s + 1], o);
  return o && D0(o, o.next) && (zh(o), (o = o.next)), o;
}
function Dl(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n,
    r;
  do
    if (
      ((r = !1), !t.steiner && (D0(t, t.next) || on(t.prev, t, t.next) === 0))
    ) {
      if ((zh(t), (t = e = t.prev), t === t.next)) break;
      r = !0;
    } else t = t.next;
  while (r || t !== e);
  return e;
}
function Uh(n, e, t, r, i, s, o) {
  if (!n) return;
  !o && s && Q9(n, r, i, s);
  let a = n,
    l,
    u;
  for (; n.prev !== n.next; ) {
    if (((l = n.prev), (u = n.next), s ? G9(n, r, i, s) : H9(n))) {
      e.push((l.i / t) | 0),
        e.push((n.i / t) | 0),
        e.push((u.i / t) | 0),
        zh(n),
        (n = u.next),
        (a = u.next);
      continue;
    }
    if (((n = u), n === a)) {
      o
        ? o === 1
          ? ((n = V9(Dl(n), e, t)), Uh(n, e, t, r, i, s, 2))
          : o === 2 && W9(n, e, t, r, i, s)
        : Uh(Dl(n), e, t, r, i, s, 1);
      break;
    }
  }
}
function H9(n) {
  const e = n.prev,
    t = n,
    r = n.next;
  if (on(e, t, r) >= 0) return !1;
  const i = e.x,
    s = t.x,
    o = r.x,
    a = e.y,
    l = t.y,
    u = r.y,
    h = i < s ? (i < o ? i : o) : s < o ? s : o,
    d = a < l ? (a < u ? a : u) : l < u ? l : u,
    p = i > s ? (i > o ? i : o) : s > o ? s : o,
    m = a > l ? (a > u ? a : u) : l > u ? l : u;
  let _ = r.next;
  for (; _ !== e; ) {
    if (
      _.x >= h &&
      _.x <= p &&
      _.y >= d &&
      _.y <= m &&
      Yu(i, a, s, l, o, u, _.x, _.y) &&
      on(_.prev, _, _.next) >= 0
    )
      return !1;
    _ = _.next;
  }
  return !0;
}
function G9(n, e, t, r) {
  const i = n.prev,
    s = n,
    o = n.next;
  if (on(i, s, o) >= 0) return !1;
  const a = i.x,
    l = s.x,
    u = o.x,
    h = i.y,
    d = s.y,
    p = o.y,
    m = a < l ? (a < u ? a : u) : l < u ? l : u,
    _ = h < d ? (h < p ? h : p) : d < p ? d : p,
    y = a > l ? (a > u ? a : u) : l > u ? l : u,
    x = h > d ? (h > p ? h : p) : d > p ? d : p,
    g = xS(m, _, e, t, r),
    S = xS(y, x, e, t, r);
  let A = n.prevZ,
    E = n.nextZ;
  for (; A && A.z >= g && E && E.z <= S; ) {
    if (
      (A.x >= m &&
        A.x <= y &&
        A.y >= _ &&
        A.y <= x &&
        A !== i &&
        A !== o &&
        Yu(a, h, l, d, u, p, A.x, A.y) &&
        on(A.prev, A, A.next) >= 0) ||
      ((A = A.prevZ),
      E.x >= m &&
        E.x <= y &&
        E.y >= _ &&
        E.y <= x &&
        E !== i &&
        E !== o &&
        Yu(a, h, l, d, u, p, E.x, E.y) &&
        on(E.prev, E, E.next) >= 0)
    )
      return !1;
    E = E.nextZ;
  }
  for (; A && A.z >= g; ) {
    if (
      A.x >= m &&
      A.x <= y &&
      A.y >= _ &&
      A.y <= x &&
      A !== i &&
      A !== o &&
      Yu(a, h, l, d, u, p, A.x, A.y) &&
      on(A.prev, A, A.next) >= 0
    )
      return !1;
    A = A.prevZ;
  }
  for (; E && E.z <= S; ) {
    if (
      E.x >= m &&
      E.x <= y &&
      E.y >= _ &&
      E.y <= x &&
      E !== i &&
      E !== o &&
      Yu(a, h, l, d, u, p, E.x, E.y) &&
      on(E.prev, E, E.next) >= 0
    )
      return !1;
    E = E.nextZ;
  }
  return !0;
}
function V9(n, e, t) {
  let r = n;
  do {
    const i = r.prev,
      s = r.next.next;
    !D0(i, s) &&
      tL(i, r, r.next, s) &&
      kh(i, s) &&
      kh(s, i) &&
      (e.push((i.i / t) | 0),
      e.push((r.i / t) | 0),
      e.push((s.i / t) | 0),
      zh(r),
      zh(r.next),
      (r = n = s)),
      (r = r.next);
  } while (r !== n);
  return Dl(r);
}
function W9(n, e, t, r, i, s) {
  let o = n;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && $9(o, a)) {
        let l = nL(o, a);
        (o = Dl(o, o.next)),
          (l = Dl(l, l.next)),
          Uh(o, e, t, r, i, s, 0),
          Uh(l, e, t, r, i, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== n);
}
function j9(n, e, t, r) {
  const i = [];
  let s, o, a, l, u;
  for (s = 0, o = e.length; s < o; s++)
    (a = e[s] * r),
      (l = s < o - 1 ? e[s + 1] * r : n.length),
      (u = eL(n, a, l, r, !1)),
      u === u.next && (u.steiner = !0),
      i.push(Z9(u));
  for (i.sort(X9), s = 0; s < i.length; s++) t = J9(i[s], t);
  return t;
}
function X9(n, e) {
  return n.x - e.x;
}
function J9(n, e) {
  const t = K9(n, e);
  if (!t) return e;
  const r = nL(t, n);
  return Dl(r, r.next), Dl(t, t.next);
}
function K9(n, e) {
  let t = e,
    r = -1 / 0,
    i;
  const s = n.x,
    o = n.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const p = t.x + ((o - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        p <= s &&
        p > r &&
        ((r = p), (i = t.x < t.next.x ? t : t.next), p === s)
      )
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i) return null;
  const a = i,
    l = i.x,
    u = i.y;
  let h = 1 / 0,
    d;
  t = i;
  do
    s >= t.x &&
      t.x >= l &&
      s !== t.x &&
      Yu(o < u ? s : r, o, l, u, o < u ? r : s, o, t.x, t.y) &&
      ((d = Math.abs(o - t.y) / (s - t.x)),
      kh(t, n) &&
        (d < h || (d === h && (t.x > i.x || (t.x === i.x && Y9(i, t))))) &&
        ((i = t), (h = d))),
      (t = t.next);
  while (t !== a);
  return i;
}
function Y9(n, e) {
  return on(n.prev, n, e.prev) < 0 && on(e.next, n, n.next) < 0;
}
function Q9(n, e, t, r) {
  let i = n;
  do
    i.z === 0 && (i.z = xS(i.x, i.y, e, t, r)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next);
  while (i !== n);
  (i.prevZ.nextZ = null), (i.prevZ = null), q9(i);
}
function q9(n) {
  let e,
    t,
    r,
    i,
    s,
    o,
    a,
    l,
    u = 1;
  do {
    for (t = n, n = null, s = null, o = 0; t; ) {
      for (o++, r = t, a = 0, e = 0; e < u && (a++, (r = r.nextZ), !!r); e++);
      for (l = u; a > 0 || (l > 0 && r); )
        a !== 0 && (l === 0 || !r || t.z <= r.z)
          ? ((i = t), (t = t.nextZ), a--)
          : ((i = r), (r = r.nextZ), l--),
          s ? (s.nextZ = i) : (n = i),
          (i.prevZ = s),
          (s = i);
      t = r;
    }
    (s.nextZ = null), (u *= 2);
  } while (o > 1);
  return n;
}
function xS(n, e, t, r, i) {
  return (
    (n = ((n - t) * i) | 0),
    (e = ((e - r) * i) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  );
}
function Z9(n) {
  let e = n,
    t = n;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== n);
  return t;
}
function Yu(n, e, t, r, i, s, o, a) {
  return (
    (i - o) * (e - a) >= (n - o) * (s - a) &&
    (n - o) * (r - a) >= (t - o) * (e - a) &&
    (t - o) * (s - a) >= (i - o) * (r - a)
  );
}
function $9(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !e8(n, e) &&
    ((kh(n, e) &&
      kh(e, n) &&
      t8(n, e) &&
      (on(n.prev, n, e.prev) || on(n, e.prev, e))) ||
      (D0(n, e) && on(n.prev, n, n.next) > 0 && on(e.prev, e, e.next) > 0))
  );
}
function on(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function D0(n, e) {
  return n.x === e.x && n.y === e.y;
}
function tL(n, e, t, r) {
  const i = pm(on(n, e, t)),
    s = pm(on(n, e, r)),
    o = pm(on(t, r, n)),
    a = pm(on(t, r, e));
  return !!(
    (i !== s && o !== a) ||
    (i === 0 && dm(n, t, e)) ||
    (s === 0 && dm(n, r, e)) ||
    (o === 0 && dm(t, n, r)) ||
    (a === 0 && dm(t, e, r))
  );
}
function dm(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  );
}
function pm(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function e8(n, e) {
  let t = n;
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      tL(t, t.next, n, e)
    )
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function kh(n, e) {
  return on(n.prev, n, n.next) < 0
    ? on(n, e, n.next) >= 0 && on(n, n.prev, e) >= 0
    : on(n, e, n.prev) < 0 || on(n, n.next, e) < 0;
}
function t8(n, e) {
  let t = n,
    r = !1;
  const i = (n.x + e.x) / 2,
    s = (n.y + e.y) / 2;
  do
    t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      i < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (r = !r),
      (t = t.next);
  while (t !== n);
  return r;
}
function nL(n, e) {
  const t = new SS(n.i, n.x, n.y),
    r = new SS(e.i, e.x, e.y),
    i = n.next,
    s = e.prev;
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = i),
    (i.prev = t),
    (r.next = t),
    (t.prev = r),
    (s.next = r),
    (r.prev = s),
    r
  );
}
function vT(n, e, t, r) {
  const i = new SS(n, e, t);
  return (
    r
      ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  );
}
function zh(n) {
  (n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function SS(n, e, t) {
  (this.i = n),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function n8(n, e, t, r) {
  let i = 0;
  for (let s = e, o = t - r; s < t; s += r)
    (i += (n[o] - n[s]) * (n[s + 1] + n[o + 1])), (o = s);
  return i;
}
class Ls {
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let i = t - 1, s = 0; s < t; i = s++)
      r += e[i].x * e[s].y - e[s].x * e[i].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return Ls.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [],
      i = [],
      s = [];
    yT(e), xT(r, e);
    let o = e.length;
    t.forEach(yT);
    for (let l = 0; l < t.length; l++)
      i.push(o), (o += t[l].length), xT(r, t[l]);
    const a = z9.triangulate(r, i);
    for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
    return s;
  }
}
function yT(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function xT(n, e) {
  for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
}
class F0 extends dt {
  constructor(
    e = new Al([
      new ge(0.5, 0.5),
      new ge(-0.5, 0.5),
      new ge(-0.5, -0.5),
      new ge(0.5, -0.5),
    ]),
    t = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const r = this,
      i = [],
      s = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a];
      o(u);
    }
    this.setAttribute("position", new Xe(i, 3)),
      this.setAttribute("uv", new Xe(s, 2)),
      this.computeVertexNormals();
    function o(a) {
      const l = [],
        u = t.curveSegments !== void 0 ? t.curveSegments : 12,
        h = t.steps !== void 0 ? t.steps : 1,
        d = t.depth !== void 0 ? t.depth : 1;
      let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        m = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        _ = t.bevelSize !== void 0 ? t.bevelSize : m - 0.1,
        y = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        x = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const g = t.extrudePath,
        S = t.UVGenerator !== void 0 ? t.UVGenerator : r8;
      let A,
        E = !1,
        C,
        R,
        P,
        L;
      g &&
        ((A = g.getSpacedPoints(h)),
        (E = !0),
        (p = !1),
        (C = g.computeFrenetFrames(h, !1)),
        (R = new U()),
        (P = new U()),
        (L = new U())),
        p || ((x = 0), (m = 0), (_ = 0), (y = 0));
      const T = a.extractPoints(u);
      let B = T.shape;
      const D = T.holes;
      if (!Ls.isClockWise(B)) {
        B = B.reverse();
        for (let K = 0, _e = D.length; K < _e; K++) {
          const pe = D[K];
          Ls.isClockWise(pe) && (D[K] = pe.reverse());
        }
      }
      const F = Ls.triangulateShape(B, D),
        k = B;
      for (let K = 0, _e = D.length; K < _e; K++) {
        const pe = D[K];
        B = B.concat(pe);
      }
      function j(K, _e, pe) {
        return (
          _e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          K.clone().addScaledVector(_e, pe)
        );
      }
      const Z = B.length,
        Q = F.length;
      function N(K, _e, pe) {
        let Ae, ve, Ge;
        const Oe = K.x - _e.x,
          Ue = K.y - _e.y,
          Qe = pe.x - K.x,
          yt = pe.y - K.y,
          Vt = Oe * Oe + Ue * Ue,
          V = Oe * yt - Ue * Qe;
        if (Math.abs(V) > Number.EPSILON) {
          const O = Math.sqrt(Vt),
            ue = Math.sqrt(Qe * Qe + yt * yt),
            Me = _e.x - Ue / O,
            xe = _e.y + Oe / O,
            Re = pe.x - yt / ue,
            Je = pe.y + Qe / ue,
            Pe = ((Re - Me) * yt - (Je - xe) * Qe) / (Oe * yt - Ue * Qe);
          (Ae = Me + Oe * Pe - K.x), (ve = xe + Ue * Pe - K.y);
          const he = Ae * Ae + ve * ve;
          if (he <= 2) return new ge(Ae, ve);
          Ge = Math.sqrt(he / 2);
        } else {
          let O = !1;
          Oe > Number.EPSILON
            ? Qe > Number.EPSILON && (O = !0)
            : Oe < -Number.EPSILON
            ? Qe < -Number.EPSILON && (O = !0)
            : Math.sign(Ue) === Math.sign(yt) && (O = !0),
            O
              ? ((Ae = -Ue), (ve = Oe), (Ge = Math.sqrt(Vt)))
              : ((Ae = Oe), (ve = Ue), (Ge = Math.sqrt(Vt / 2)));
        }
        return new ge(Ae / Ge, ve / Ge);
      }
      const W = [];
      for (
        let K = 0, _e = k.length, pe = _e - 1, Ae = K + 1;
        K < _e;
        K++, pe++, Ae++
      )
        pe === _e && (pe = 0),
          Ae === _e && (Ae = 0),
          (W[K] = N(k[K], k[pe], k[Ae]));
      const G = [];
      let X,
        Y = W.concat();
      for (let K = 0, _e = D.length; K < _e; K++) {
        const pe = D[K];
        X = [];
        for (
          let Ae = 0, ve = pe.length, Ge = ve - 1, Oe = Ae + 1;
          Ae < ve;
          Ae++, Ge++, Oe++
        )
          Ge === ve && (Ge = 0),
            Oe === ve && (Oe = 0),
            (X[Ae] = N(pe[Ae], pe[Ge], pe[Oe]));
        G.push(X), (Y = Y.concat(X));
      }
      for (let K = 0; K < x; K++) {
        const _e = K / x,
          pe = m * Math.cos((_e * Math.PI) / 2),
          Ae = _ * Math.sin((_e * Math.PI) / 2) + y;
        for (let ve = 0, Ge = k.length; ve < Ge; ve++) {
          const Oe = j(k[ve], W[ve], Ae);
          Ne(Oe.x, Oe.y, -pe);
        }
        for (let ve = 0, Ge = D.length; ve < Ge; ve++) {
          const Oe = D[ve];
          X = G[ve];
          for (let Ue = 0, Qe = Oe.length; Ue < Qe; Ue++) {
            const yt = j(Oe[Ue], X[Ue], Ae);
            Ne(yt.x, yt.y, -pe);
          }
        }
      }
      const de = _ + y;
      for (let K = 0; K < Z; K++) {
        const _e = p ? j(B[K], Y[K], de) : B[K];
        E
          ? (P.copy(C.normals[0]).multiplyScalar(_e.x),
            R.copy(C.binormals[0]).multiplyScalar(_e.y),
            L.copy(A[0]).add(P).add(R),
            Ne(L.x, L.y, L.z))
          : Ne(_e.x, _e.y, 0);
      }
      for (let K = 1; K <= h; K++)
        for (let _e = 0; _e < Z; _e++) {
          const pe = p ? j(B[_e], Y[_e], de) : B[_e];
          E
            ? (P.copy(C.normals[K]).multiplyScalar(pe.x),
              R.copy(C.binormals[K]).multiplyScalar(pe.y),
              L.copy(A[K]).add(P).add(R),
              Ne(L.x, L.y, L.z))
            : Ne(pe.x, pe.y, (d / h) * K);
        }
      for (let K = x - 1; K >= 0; K--) {
        const _e = K / x,
          pe = m * Math.cos((_e * Math.PI) / 2),
          Ae = _ * Math.sin((_e * Math.PI) / 2) + y;
        for (let ve = 0, Ge = k.length; ve < Ge; ve++) {
          const Oe = j(k[ve], W[ve], Ae);
          Ne(Oe.x, Oe.y, d + pe);
        }
        for (let ve = 0, Ge = D.length; ve < Ge; ve++) {
          const Oe = D[ve];
          X = G[ve];
          for (let Ue = 0, Qe = Oe.length; Ue < Qe; Ue++) {
            const yt = j(Oe[Ue], X[Ue], Ae);
            E
              ? Ne(yt.x, yt.y + A[h - 1].y, A[h - 1].x + pe)
              : Ne(yt.x, yt.y, d + pe);
          }
        }
      }
      ae(), ye();
      function ae() {
        const K = i.length / 3;
        if (p) {
          let _e = 0,
            pe = Z * _e;
          for (let Ae = 0; Ae < Q; Ae++) {
            const ve = F[Ae];
            je(ve[2] + pe, ve[1] + pe, ve[0] + pe);
          }
          (_e = h + x * 2), (pe = Z * _e);
          for (let Ae = 0; Ae < Q; Ae++) {
            const ve = F[Ae];
            je(ve[0] + pe, ve[1] + pe, ve[2] + pe);
          }
        } else {
          for (let _e = 0; _e < Q; _e++) {
            const pe = F[_e];
            je(pe[2], pe[1], pe[0]);
          }
          for (let _e = 0; _e < Q; _e++) {
            const pe = F[_e];
            je(pe[0] + Z * h, pe[1] + Z * h, pe[2] + Z * h);
          }
        }
        r.addGroup(K, i.length / 3 - K, 0);
      }
      function ye() {
        const K = i.length / 3;
        let _e = 0;
        we(k, _e), (_e += k.length);
        for (let pe = 0, Ae = D.length; pe < Ae; pe++) {
          const ve = D[pe];
          we(ve, _e), (_e += ve.length);
        }
        r.addGroup(K, i.length / 3 - K, 1);
      }
      function we(K, _e) {
        let pe = K.length;
        for (; --pe >= 0; ) {
          const Ae = pe;
          let ve = pe - 1;
          ve < 0 && (ve = K.length - 1);
          for (let Ge = 0, Oe = h + x * 2; Ge < Oe; Ge++) {
            const Ue = Z * Ge,
              Qe = Z * (Ge + 1),
              yt = _e + Ae + Ue,
              Vt = _e + ve + Ue,
              V = _e + ve + Qe,
              O = _e + Ae + Qe;
            At(yt, Vt, V, O);
          }
        }
      }
      function Ne(K, _e, pe) {
        l.push(K), l.push(_e), l.push(pe);
      }
      function je(K, _e, pe) {
        lt(K), lt(_e), lt(pe);
        const Ae = i.length / 3,
          ve = S.generateTopUV(r, i, Ae - 3, Ae - 2, Ae - 1);
        Ce(ve[0]), Ce(ve[1]), Ce(ve[2]);
      }
      function At(K, _e, pe, Ae) {
        lt(K), lt(_e), lt(Ae), lt(_e), lt(pe), lt(Ae);
        const ve = i.length / 3,
          Ge = S.generateSideWallUV(r, i, ve - 6, ve - 3, ve - 2, ve - 1);
        Ce(Ge[0]), Ce(Ge[1]), Ce(Ge[3]), Ce(Ge[1]), Ce(Ge[2]), Ce(Ge[3]);
      }
      function lt(K) {
        i.push(l[K * 3 + 0]), i.push(l[K * 3 + 1]), i.push(l[K * 3 + 2]);
      }
      function Ce(K) {
        s.push(K.x), s.push(K.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      r = this.parameters.options;
    return i8(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = t[e.shapes[s]];
      r.push(a);
    }
    const i = e.options.extrudePath;
    return (
      i !== void 0 && (e.options.extrudePath = new T1[i.type]().fromJSON(i)),
      new F0(r, e.options)
    );
  }
}
const r8 = {
  generateTopUV: function (n, e, t, r, i) {
    const s = e[t * 3],
      o = e[t * 3 + 1],
      a = e[r * 3],
      l = e[r * 3 + 1],
      u = e[i * 3],
      h = e[i * 3 + 1];
    return [new ge(s, o), new ge(a, l), new ge(u, h)];
  },
  generateSideWallUV: function (n, e, t, r, i, s) {
    const o = e[t * 3],
      a = e[t * 3 + 1],
      l = e[t * 3 + 2],
      u = e[r * 3],
      h = e[r * 3 + 1],
      d = e[r * 3 + 2],
      p = e[i * 3],
      m = e[i * 3 + 1],
      _ = e[i * 3 + 2],
      y = e[s * 3],
      x = e[s * 3 + 1],
      g = e[s * 3 + 2];
    return Math.abs(a - h) < Math.abs(o - u)
      ? [new ge(o, 1 - l), new ge(u, 1 - d), new ge(p, 1 - _), new ge(y, 1 - g)]
      : [
          new ge(a, 1 - l),
          new ge(h, 1 - d),
          new ge(m, 1 - _),
          new ge(x, 1 - g),
        ];
  },
};
function i8(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let r = 0, i = n.length; r < i; r++) {
      const s = n[r];
      t.shapes.push(s.uuid);
    }
  else t.shapes.push(n.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class N0 extends Pa {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = [
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        0,
        0,
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        r,
        0,
        -1,
        r,
        0,
        1,
        -r,
        0,
        -1,
        -r,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(i, s, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new N0(e.radius, e.detail);
  }
}
class md extends Pa {
  constructor(e = 1, t = 0) {
    const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      i = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(r, i, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new md(e.radius, e.detail);
  }
}
class O0 extends dt {
  constructor(e = 0.5, t = 1, r = 32, i = 1, s = 0, o = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: r,
        phiSegments: i,
        thetaStart: s,
        thetaLength: o,
      }),
      (r = Math.max(3, r)),
      (i = Math.max(1, i));
    const a = [],
      l = [],
      u = [],
      h = [];
    let d = e;
    const p = (t - e) / i,
      m = new U(),
      _ = new ge();
    for (let y = 0; y <= i; y++) {
      for (let x = 0; x <= r; x++) {
        const g = s + (x / r) * o;
        (m.x = d * Math.cos(g)),
          (m.y = d * Math.sin(g)),
          l.push(m.x, m.y, m.z),
          u.push(0, 0, 1),
          (_.x = (m.x / t + 1) / 2),
          (_.y = (m.y / t + 1) / 2),
          h.push(_.x, _.y);
      }
      d += p;
    }
    for (let y = 0; y < i; y++) {
      const x = y * (r + 1);
      for (let g = 0; g < r; g++) {
        const S = g + x,
          A = S,
          E = S + r + 1,
          C = S + r + 2,
          R = S + 1;
        a.push(A, E, R), a.push(E, C, R);
      }
    }
    this.setIndex(a),
      this.setAttribute("position", new Xe(l, 3)),
      this.setAttribute("normal", new Xe(u, 3)),
      this.setAttribute("uv", new Xe(h, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new O0(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class U0 extends dt {
  constructor(
    e = new Al([new ge(0, 0.5), new ge(-0.5, -0.5), new ge(0.5, -0.5)]),
    t = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    const r = [],
      i = [],
      s = [],
      o = [];
    let a = 0,
      l = 0;
    if (Array.isArray(e) === !1) u(e);
    else
      for (let h = 0; h < e.length; h++)
        u(e[h]), this.addGroup(a, l, h), (a += l), (l = 0);
    this.setIndex(r),
      this.setAttribute("position", new Xe(i, 3)),
      this.setAttribute("normal", new Xe(s, 3)),
      this.setAttribute("uv", new Xe(o, 2));
    function u(h) {
      const d = i.length / 3,
        p = h.extractPoints(t);
      let m = p.shape;
      const _ = p.holes;
      Ls.isClockWise(m) === !1 && (m = m.reverse());
      for (let x = 0, g = _.length; x < g; x++) {
        const S = _[x];
        Ls.isClockWise(S) === !0 && (_[x] = S.reverse());
      }
      const y = Ls.triangulateShape(m, _);
      for (let x = 0, g = _.length; x < g; x++) {
        const S = _[x];
        m = m.concat(S);
      }
      for (let x = 0, g = m.length; x < g; x++) {
        const S = m[x];
        i.push(S.x, S.y, 0), s.push(0, 0, 1), o.push(S.x, S.y);
      }
      for (let x = 0, g = y.length; x < g; x++) {
        const S = y[x],
          A = S[0] + d,
          E = S[1] + d,
          C = S[2] + d;
        r.push(A, E, C), (l += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return s8(t, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let i = 0, s = e.shapes.length; i < s; i++) {
      const o = t[e.shapes[i]];
      r.push(o);
    }
    return new U0(r, e.curveSegments);
  }
}
function s8(n, e) {
  if (((e.shapes = []), Array.isArray(n)))
    for (let t = 0, r = n.length; t < r; t++) {
      const i = n[t];
      e.shapes.push(i.uuid);
    }
  else e.shapes.push(n.uuid);
  return e;
}
class gd extends dt {
  constructor(
    e = 1,
    t = 32,
    r = 16,
    i = 0,
    s = Math.PI * 2,
    o = 0,
    a = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: r,
        phiStart: i,
        phiLength: s,
        thetaStart: o,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (r = Math.max(2, Math.floor(r)));
    const l = Math.min(o + a, Math.PI);
    let u = 0;
    const h = [],
      d = new U(),
      p = new U(),
      m = [],
      _ = [],
      y = [],
      x = [];
    for (let g = 0; g <= r; g++) {
      const S = [],
        A = g / r;
      let E = 0;
      g === 0 && o === 0
        ? (E = 0.5 / t)
        : g === r && l === Math.PI && (E = -0.5 / t);
      for (let C = 0; C <= t; C++) {
        const R = C / t;
        (d.x = -e * Math.cos(i + R * s) * Math.sin(o + A * a)),
          (d.y = e * Math.cos(o + A * a)),
          (d.z = e * Math.sin(i + R * s) * Math.sin(o + A * a)),
          _.push(d.x, d.y, d.z),
          p.copy(d).normalize(),
          y.push(p.x, p.y, p.z),
          x.push(R + E, 1 - A),
          S.push(u++);
      }
      h.push(S);
    }
    for (let g = 0; g < r; g++)
      for (let S = 0; S < t; S++) {
        const A = h[g][S + 1],
          E = h[g][S],
          C = h[g + 1][S],
          R = h[g + 1][S + 1];
        (g !== 0 || o > 0) && m.push(A, E, R),
          (g !== r - 1 || l < Math.PI) && m.push(E, C, R);
      }
    this.setIndex(m),
      this.setAttribute("position", new Xe(_, 3)),
      this.setAttribute("normal", new Xe(y, 3)),
      this.setAttribute("uv", new Xe(x, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new gd(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class k0 extends Pa {
  constructor(e = 1, t = 0) {
    const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(r, i, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new k0(e.radius, e.detail);
  }
}
class z0 extends dt {
  constructor(e = 1, t = 0.4, r = 12, i = 48, s = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: r,
        tubularSegments: i,
        arc: s,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const o = [],
      a = [],
      l = [],
      u = [],
      h = new U(),
      d = new U(),
      p = new U();
    for (let m = 0; m <= r; m++)
      for (let _ = 0; _ <= i; _++) {
        const y = (_ / i) * s,
          x = (m / r) * Math.PI * 2;
        (d.x = (e + t * Math.cos(x)) * Math.cos(y)),
          (d.y = (e + t * Math.cos(x)) * Math.sin(y)),
          (d.z = t * Math.sin(x)),
          a.push(d.x, d.y, d.z),
          (h.x = e * Math.cos(y)),
          (h.y = e * Math.sin(y)),
          p.subVectors(d, h).normalize(),
          l.push(p.x, p.y, p.z),
          u.push(_ / i),
          u.push(m / r);
      }
    for (let m = 1; m <= r; m++)
      for (let _ = 1; _ <= i; _++) {
        const y = (i + 1) * m + _ - 1,
          x = (i + 1) * (m - 1) + _ - 1,
          g = (i + 1) * (m - 1) + _,
          S = (i + 1) * m + _;
        o.push(y, x, S), o.push(x, g, S);
      }
    this.setIndex(o),
      this.setAttribute("position", new Xe(a, 3)),
      this.setAttribute("normal", new Xe(l, 3)),
      this.setAttribute("uv", new Xe(u, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new z0(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class H0 extends dt {
  constructor(e = 1, t = 0.4, r = 64, i = 8, s = 2, o = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: r,
        radialSegments: i,
        p: s,
        q: o,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const a = [],
      l = [],
      u = [],
      h = [],
      d = new U(),
      p = new U(),
      m = new U(),
      _ = new U(),
      y = new U(),
      x = new U(),
      g = new U();
    for (let A = 0; A <= r; ++A) {
      const E = (A / r) * s * Math.PI * 2;
      S(E, s, o, e, m),
        S(E + 0.01, s, o, e, _),
        x.subVectors(_, m),
        g.addVectors(_, m),
        y.crossVectors(x, g),
        g.crossVectors(y, x),
        y.normalize(),
        g.normalize();
      for (let C = 0; C <= i; ++C) {
        const R = (C / i) * Math.PI * 2,
          P = -t * Math.cos(R),
          L = t * Math.sin(R);
        (d.x = m.x + (P * g.x + L * y.x)),
          (d.y = m.y + (P * g.y + L * y.y)),
          (d.z = m.z + (P * g.z + L * y.z)),
          l.push(d.x, d.y, d.z),
          p.subVectors(d, m).normalize(),
          u.push(p.x, p.y, p.z),
          h.push(A / r),
          h.push(C / i);
      }
    }
    for (let A = 1; A <= r; A++)
      for (let E = 1; E <= i; E++) {
        const C = (i + 1) * (A - 1) + (E - 1),
          R = (i + 1) * A + (E - 1),
          P = (i + 1) * A + E,
          L = (i + 1) * (A - 1) + E;
        a.push(C, R, L), a.push(R, P, L);
      }
    this.setIndex(a),
      this.setAttribute("position", new Xe(l, 3)),
      this.setAttribute("normal", new Xe(u, 3)),
      this.setAttribute("uv", new Xe(h, 2));
    function S(A, E, C, R, P) {
      const L = Math.cos(A),
        T = Math.sin(A),
        B = (C / E) * A,
        D = Math.cos(B);
      (P.x = R * (2 + D) * 0.5 * L),
        (P.y = R * (2 + D) * T * 0.5),
        (P.z = R * Math.sin(B) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new H0(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class G0 extends dt {
  constructor(
    e = new w1(new U(-1, -1, 0), new U(-1, 1, 0), new U(1, 1, 0)),
    t = 64,
    r = 1,
    i = 8,
    s = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: r,
        radialSegments: i,
        closed: s,
      });
    const o = e.computeFrenetFrames(t, s);
    (this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals);
    const a = new U(),
      l = new U(),
      u = new ge();
    let h = new U();
    const d = [],
      p = [],
      m = [],
      _ = [];
    y(),
      this.setIndex(_),
      this.setAttribute("position", new Xe(d, 3)),
      this.setAttribute("normal", new Xe(p, 3)),
      this.setAttribute("uv", new Xe(m, 2));
    function y() {
      for (let A = 0; A < t; A++) x(A);
      x(s === !1 ? t : 0), S(), g();
    }
    function x(A) {
      h = e.getPointAt(A / t, h);
      const E = o.normals[A],
        C = o.binormals[A];
      for (let R = 0; R <= i; R++) {
        const P = (R / i) * Math.PI * 2,
          L = Math.sin(P),
          T = -Math.cos(P);
        (l.x = T * E.x + L * C.x),
          (l.y = T * E.y + L * C.y),
          (l.z = T * E.z + L * C.z),
          l.normalize(),
          p.push(l.x, l.y, l.z),
          (a.x = h.x + r * l.x),
          (a.y = h.y + r * l.y),
          (a.z = h.z + r * l.z),
          d.push(a.x, a.y, a.z);
      }
    }
    function g() {
      for (let A = 1; A <= t; A++)
        for (let E = 1; E <= i; E++) {
          const C = (i + 1) * (A - 1) + (E - 1),
            R = (i + 1) * A + (E - 1),
            P = (i + 1) * A + E,
            L = (i + 1) * (A - 1) + E;
          _.push(C, R, L), _.push(R, P, L);
        }
    }
    function S() {
      for (let A = 0; A <= t; A++)
        for (let E = 0; E <= i; E++)
          (u.x = A / t), (u.y = E / i), m.push(u.x, u.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new G0(
      new T1[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class rL extends dt {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        r = new Set(),
        i = new U(),
        s = new U();
      if (e.index !== null) {
        const o = e.attributes.position,
          a = e.index;
        let l = e.groups;
        l.length === 0 &&
          (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let u = 0, h = l.length; u < h; ++u) {
          const d = l[u],
            p = d.start,
            m = d.count;
          for (let _ = p, y = p + m; _ < y; _ += 3)
            for (let x = 0; x < 3; x++) {
              const g = a.getX(_ + x),
                S = a.getX(_ + ((x + 1) % 3));
              i.fromBufferAttribute(o, g),
                s.fromBufferAttribute(o, S),
                ST(i, s, r) === !0 &&
                  (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let a = 0, l = o.count / 3; a < l; a++)
          for (let u = 0; u < 3; u++) {
            const h = 3 * a + u,
              d = 3 * a + ((u + 1) % 3);
            i.fromBufferAttribute(o, h),
              s.fromBufferAttribute(o, d),
              ST(i, s, r) === !0 &&
                (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new Xe(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function ST(n, e, t) {
  const r = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    i = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(r) === !0 || t.has(i) === !0 ? !1 : (t.add(r), t.add(i), !0);
}
var AT = Object.freeze({
  __proto__: null,
  BoxGeometry: zl,
  CapsuleGeometry: B0,
  CircleGeometry: L0,
  ConeGeometry: pd,
  CylinderGeometry: jc,
  DodecahedronGeometry: I0,
  EdgesGeometry: $2,
  ExtrudeGeometry: F0,
  IcosahedronGeometry: N0,
  LatheGeometry: dd,
  OctahedronGeometry: md,
  PlaneGeometry: cd,
  PolyhedronGeometry: Pa,
  RingGeometry: O0,
  ShapeGeometry: U0,
  SphereGeometry: gd,
  TetrahedronGeometry: k0,
  TorusGeometry: z0,
  TorusKnotGeometry: H0,
  TubeGeometry: G0,
  WireframeGeometry: rL,
});
class iL extends In {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new Be(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class sL extends Os {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class da extends In {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new Be(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Be(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ba),
      (this.normalScale = new ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class zs extends da {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new ge(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return gn((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Be(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Be(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Be(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class oL extends In {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new Be(16777215)),
      (this.specular = new Be(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Be(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ba),
      (this.normalScale = new ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = od),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class aL extends In {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new Be(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Be(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ba),
      (this.normalScale = new ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class lL extends In {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ba),
      (this.normalScale = new ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class uL extends In {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new Be(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Be(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ba),
      (this.normalScale = new ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = od),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class cL extends In {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new Be(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ba),
      (this.normalScale = new ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class fL extends yr {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function Ri(n, e, t) {
  return b1(n)
    ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length))
    : n.slice(e, t);
}
function pl(n, e, t) {
  return !n || (!t && n.constructor === e)
    ? n
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(n)
    : Array.prototype.slice.call(n);
}
function b1(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function hL(n) {
  function e(i, s) {
    return n[i] - n[s];
  }
  const t = n.length,
    r = new Array(t);
  for (let i = 0; i !== t; ++i) r[i] = i;
  return r.sort(e), r;
}
function AS(n, e, t) {
  const r = n.length,
    i = new n.constructor(r);
  for (let s = 0, o = 0; o !== r; ++s) {
    const a = t[s] * e;
    for (let l = 0; l !== e; ++l) i[o++] = n[a + l];
  }
  return i;
}
function R1(n, e, t, r) {
  let i = 1,
    s = n[0];
  for (; s !== void 0 && s[r] === void 0; ) s = n[i++];
  if (s === void 0) return;
  let o = s[r];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        (o = s[r]),
          o !== void 0 && (e.push(s.time), t.push.apply(t, o)),
          (s = n[i++]);
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        (o = s[r]),
          o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
          (s = n[i++]);
      while (s !== void 0);
    else
      do (o = s[r]), o !== void 0 && (e.push(s.time), t.push(o)), (s = n[i++]);
      while (s !== void 0);
}
function o8(n, e, t, r, i = 30) {
  const s = n.clone();
  s.name = e;
  const o = [];
  for (let l = 0; l < s.tracks.length; ++l) {
    const u = s.tracks[l],
      h = u.getValueSize(),
      d = [],
      p = [];
    for (let m = 0; m < u.times.length; ++m) {
      const _ = u.times[m] * i;
      if (!(_ < t || _ >= r)) {
        d.push(u.times[m]);
        for (let y = 0; y < h; ++y) p.push(u.values[m * h + y]);
      }
    }
    d.length !== 0 &&
      ((u.times = pl(d, u.times.constructor)),
      (u.values = pl(p, u.values.constructor)),
      o.push(u));
  }
  s.tracks = o;
  let a = 1 / 0;
  for (let l = 0; l < s.tracks.length; ++l)
    a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
  for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
  return s.resetDuration(), s;
}
function a8(n, e = 0, t = n, r = 30) {
  r <= 0 && (r = 30);
  const i = t.tracks.length,
    s = e / r;
  for (let o = 0; o < i; ++o) {
    const a = t.tracks[o],
      l = a.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const u = n.tracks.find(function (g) {
      return g.name === a.name && g.ValueTypeName === l;
    });
    if (u === void 0) continue;
    let h = 0;
    const d = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (h = d / 3);
    let p = 0;
    const m = u.getValueSize();
    u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (p = m / 3);
    const _ = a.times.length - 1;
    let y;
    if (s <= a.times[0]) {
      const g = h,
        S = d - h;
      y = Ri(a.values, g, S);
    } else if (s >= a.times[_]) {
      const g = _ * d + h,
        S = g + d - h;
      y = Ri(a.values, g, S);
    } else {
      const g = a.createInterpolant(),
        S = h,
        A = d - h;
      g.evaluate(s), (y = Ri(g.resultBuffer, S, A));
    }
    l === "quaternion" &&
      new mr().fromArray(y).normalize().conjugate().toArray(y);
    const x = u.times.length;
    for (let g = 0; g < x; ++g) {
      const S = g * m + p;
      if (l === "quaternion")
        mr.multiplyQuaternionsFlat(u.values, S, y, 0, u.values, S);
      else {
        const A = m - p * 2;
        for (let E = 0; E < A; ++E) u.values[S + E] -= y[E];
      }
    }
  }
  return (n.blendMode = r1), n;
}
const l8 = {
  arraySlice: Ri,
  convertArray: pl,
  isTypedArray: b1,
  getKeyframeOrder: hL,
  sortedArray: AS,
  flattenJSON: R1,
  subclip: o8,
  makeClipAdditive: a8,
};
class Xc {
  constructor(e, t, r, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new t.constructor(r)),
      (this.sampleValues = t),
      (this.valueSize = r),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let r = this._cachedIndex,
      i = t[r],
      s = t[r - 1];
    e: {
      t: {
        let o;
        n: {
          r: if (!(e < i)) {
            for (let a = r + 2; ; ) {
              if (i === void 0) {
                if (e < s) break r;
                return (
                  (r = t.length),
                  (this._cachedIndex = r),
                  this.copySampleValue_(r - 1)
                );
              }
              if (r === a) break;
              if (((s = i), (i = t[++r]), e < i)) break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= s)) {
            const a = t[1];
            e < a && ((r = 2), (s = a));
            for (let l = r - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (r === l) break;
              if (((i = s), (s = t[--r - 1]), e >= s)) break t;
            }
            (o = r), (r = 0);
            break n;
          }
          break e;
        }
        for (; r < o; ) {
          const a = (r + o) >>> 1;
          e < t[a] ? (o = a) : (r = a + 1);
        }
        if (((i = t[r]), (s = t[r - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (
            (r = t.length),
            (this._cachedIndex = r),
            this.copySampleValue_(r - 1)
          );
      }
      (this._cachedIndex = r), this.intervalChanged_(r, s, i);
    }
    return this.interpolate_(r, s, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      r = this.sampleValues,
      i = this.valueSize,
      s = e * i;
    for (let o = 0; o !== i; ++o) t[o] = r[s + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class dL extends Xc {
  constructor(e, t, r, i) {
    super(e, t, r, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: fl, endingEnd: fl });
  }
  intervalChanged_(e, t, r) {
    const i = this.parameterPositions;
    let s = e - 2,
      o = e + 1,
      a = i[s],
      l = i[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case hl:
          (s = e), (a = 2 * t - r);
          break;
        case Ih:
          (s = i.length - 2), (a = t + i[s] - i[s + 1]);
          break;
        default:
          (s = e), (a = r);
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case hl:
          (o = e), (l = 2 * r - t);
          break;
        case Ih:
          (o = 1), (l = r + i[1] - i[0]);
          break;
        default:
          (o = e - 1), (l = t);
      }
    const u = (r - t) * 0.5,
      h = this.valueSize;
    (this._weightPrev = u / (t - a)),
      (this._weightNext = u / (l - r)),
      (this._offsetPrev = s * h),
      (this._offsetNext = o * h);
  }
  interpolate_(e, t, r, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      u = l - a,
      h = this._offsetPrev,
      d = this._offsetNext,
      p = this._weightPrev,
      m = this._weightNext,
      _ = (r - t) / (i - t),
      y = _ * _,
      x = y * _,
      g = -p * x + 2 * p * y - p * _,
      S = (1 + p) * x + (-1.5 - 2 * p) * y + (-0.5 + p) * _ + 1,
      A = (-1 - m) * x + (1.5 + m) * y + 0.5 * _,
      E = m * x - m * y;
    for (let C = 0; C !== a; ++C)
      s[C] = g * o[h + C] + S * o[u + C] + A * o[l + C] + E * o[d + C];
    return s;
  }
}
class P1 extends Xc {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      u = l - a,
      h = (r - t) / (i - t),
      d = 1 - h;
    for (let p = 0; p !== a; ++p) s[p] = o[u + p] * d + o[l + p] * h;
    return s;
  }
}
class pL extends Xc {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class hs {
  constructor(e, t, r, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = pl(t, this.TimeBufferType)),
      (this.values = pl(r, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let r;
    if (t.toJSON !== this.toJSON) r = t.toJSON(e);
    else {
      r = {
        name: e.name,
        times: pl(e.times, Array),
        values: pl(e.values, Array),
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (r.interpolation = i);
    }
    return (r.type = e.ValueTypeName), r;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new pL(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new P1(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new dL(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Mc:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Il:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Km:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const r =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(r);
      return console.warn("THREE.KeyframeTrack:", r), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Mc;
      case this.InterpolantFactoryMethodLinear:
        return Il;
      case this.InterpolantFactoryMethodSmooth:
        return Km;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r) t[r] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r) t[r] *= e;
    }
    return this;
  }
  trim(e, t) {
    const r = this.times,
      i = r.length;
    let s = 0,
      o = i - 1;
    for (; s !== i && r[s] < e; ) ++s;
    for (; o !== -1 && r[o] > t; ) --o;
    if ((++o, s !== 0 || o !== i)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1));
      const a = this.getValueSize();
      (this.times = Ri(r, s, o)), (this.values = Ri(this.values, s * a, o * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const r = this.times,
      i = this.values,
      s = r.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let o = null;
    for (let a = 0; a !== s; a++) {
      const l = r[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          l
        ),
          (e = !1);
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
          (e = !1);
        break;
      }
      o = l;
    }
    if (i !== void 0 && b1(i))
      for (let a = 0, l = i.length; a !== l; ++a) {
        const u = i[a];
        if (isNaN(u)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            u
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = Ri(this.times),
      t = Ri(this.values),
      r = this.getValueSize(),
      i = this.getInterpolation() === Km,
      s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let l = !1;
      const u = e[a],
        h = e[a + 1];
      if (u !== h && (a !== 1 || u !== e[0]))
        if (i) l = !0;
        else {
          const d = a * r,
            p = d - r,
            m = d + r;
          for (let _ = 0; _ !== r; ++_) {
            const y = t[d + _];
            if (y !== t[p + _] || y !== t[m + _]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const d = a * r,
            p = o * r;
          for (let m = 0; m !== r; ++m) t[p + m] = t[d + m];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * r, l = o * r, u = 0; u !== r; ++u) t[l + u] = t[a + u];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = Ri(e, 0, o)), (this.values = Ri(t, 0, o * r)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = Ri(this.times, 0),
      t = Ri(this.values, 0),
      r = this.constructor,
      i = new r(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
hs.prototype.TimeBufferType = Float32Array;
hs.prototype.ValueBufferType = Float32Array;
hs.prototype.DefaultInterpolation = Il;
class Hl extends hs {}
Hl.prototype.ValueTypeName = "bool";
Hl.prototype.ValueBufferType = Array;
Hl.prototype.DefaultInterpolation = Mc;
Hl.prototype.InterpolantFactoryMethodLinear = void 0;
Hl.prototype.InterpolantFactoryMethodSmooth = void 0;
class B1 extends hs {}
B1.prototype.ValueTypeName = "color";
class Tc extends hs {}
Tc.prototype.ValueTypeName = "number";
class mL extends Xc {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = (r - t) / (i - t);
    let u = e * a;
    for (let h = u + a; u !== h; u += 4) mr.slerpFlat(s, 0, o, u - a, o, u, l);
    return s;
  }
}
class Aa extends hs {
  InterpolantFactoryMethodLinear(e) {
    return new mL(this.times, this.values, this.getValueSize(), e);
  }
}
Aa.prototype.ValueTypeName = "quaternion";
Aa.prototype.DefaultInterpolation = Il;
Aa.prototype.InterpolantFactoryMethodSmooth = void 0;
class Gl extends hs {}
Gl.prototype.ValueTypeName = "string";
Gl.prototype.ValueBufferType = Array;
Gl.prototype.DefaultInterpolation = Mc;
Gl.prototype.InterpolantFactoryMethodLinear = void 0;
Gl.prototype.InterpolantFactoryMethodSmooth = void 0;
class bc extends hs {}
bc.prototype.ValueTypeName = "vector";
class Rc {
  constructor(e, t = -1, r, i = S0) {
    (this.name = e),
      (this.tracks = r),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = ui()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      r = e.tracks,
      i = 1 / (e.fps || 1);
    for (let o = 0, a = r.length; o !== a; ++o) t.push(c8(r[o]).scale(i));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const t = [],
      r = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, o = r.length; s !== o; ++s) t.push(hs.toJSON(r[s]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, r, i) {
    const s = t.length,
      o = [];
    for (let a = 0; a < s; a++) {
      let l = [],
        u = [];
      l.push((a + s - 1) % s, a, (a + 1) % s), u.push(0, 1, 0);
      const h = hL(l);
      (l = AS(l, 1, h)),
        (u = AS(u, 1, h)),
        !i && l[0] === 0 && (l.push(s), u.push(u[0])),
        o.push(
          new Tc(".morphTargetInfluences[" + t[a].name + "]", l, u).scale(1 / r)
        );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let r = e;
    if (!Array.isArray(e)) {
      const i = e;
      r = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < r.length; i++) if (r[i].name === t) return r[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, r) {
    const i = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a],
        h = u.name.match(s);
      if (h && h.length > 1) {
        const d = h[1];
        let p = i[d];
        p || (i[d] = p = []), p.push(u);
      }
    }
    const o = [];
    for (const a in i)
      o.push(this.CreateFromMorphTargetSequence(a, i[a], t, r));
    return o;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const r = function (d, p, m, _, y) {
        if (m.length !== 0) {
          const x = [],
            g = [];
          R1(m, x, g, _), x.length !== 0 && y.push(new d(p, x, g));
        }
      },
      i = [],
      s = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode;
    let l = e.length || -1;
    const u = e.hierarchy || [];
    for (let d = 0; d < u.length; d++) {
      const p = u[d].keys;
      if (!(!p || p.length === 0))
        if (p[0].morphTargets) {
          const m = {};
          let _;
          for (_ = 0; _ < p.length; _++)
            if (p[_].morphTargets)
              for (let y = 0; y < p[_].morphTargets.length; y++)
                m[p[_].morphTargets[y]] = -1;
          for (const y in m) {
            const x = [],
              g = [];
            for (let S = 0; S !== p[_].morphTargets.length; ++S) {
              const A = p[_];
              x.push(A.time), g.push(A.morphTarget === y ? 1 : 0);
            }
            i.push(new Tc(".morphTargetInfluence[" + y + "]", x, g));
          }
          l = m.length * o;
        } else {
          const m = ".bones[" + t[d].name + "]";
          r(bc, m + ".position", p, "pos", i),
            r(Aa, m + ".quaternion", p, "rot", i),
            r(bc, m + ".scale", p, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(s, l, i, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let r = 0, i = e.length; r !== i; ++r) {
      const s = this.tracks[r];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function u8(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Tc;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return bc;
    case "color":
      return B1;
    case "quaternion":
      return Aa;
    case "bool":
    case "boolean":
      return Hl;
    case "string":
      return Gl;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function c8(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = u8(n.type);
  if (n.times === void 0) {
    const t = [],
      r = [];
    R1(n.keys, t, r, "value"), (n.times = t), (n.values = r);
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const Fl = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class L1 {
  constructor(e, t, r) {
    const i = this;
    let s = !1,
      o = 0,
      a = 0,
      l;
    const u = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = r),
      (this.itemStart = function (h) {
        a++, s === !1 && i.onStart !== void 0 && i.onStart(h, o, a), (s = !0);
      }),
      (this.itemEnd = function (h) {
        o++,
          i.onProgress !== void 0 && i.onProgress(h, o, a),
          o === a && ((s = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (h) {
        i.onError !== void 0 && i.onError(h);
      }),
      (this.resolveURL = function (h) {
        return l ? l(h) : h;
      }),
      (this.setURLModifier = function (h) {
        return (l = h), this;
      }),
      (this.addHandler = function (h, d) {
        return u.push(h, d), this;
      }),
      (this.removeHandler = function (h) {
        const d = u.indexOf(h);
        return d !== -1 && u.splice(d, 2), this;
      }),
      (this.getHandler = function (h) {
        for (let d = 0, p = u.length; d < p; d += 2) {
          const m = u[d],
            _ = u[d + 1];
          if ((m.global && (m.lastIndex = 0), m.test(h))) return _;
        }
        return null;
      });
  }
}
const gL = new L1();
class xr {
  constructor(e) {
    (this.manager = e !== void 0 ? e : gL),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const r = this;
    return new Promise(function (i, s) {
      r.load(e, i, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
xr.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const $s = {};
class f8 extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class hi extends xr {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = Fl.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if ($s[e] !== void 0) {
      $s[e].push({ onLoad: t, onProgress: r, onError: i });
      return;
    }
    ($s[e] = []), $s[e].push({ onLoad: t, onProgress: r, onError: i });
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      l = this.responseType;
    fetch(o)
      .then((u) => {
        if (u.status === 200 || u.status === 0) {
          if (
            (u.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              u.body === void 0 ||
              u.body.getReader === void 0)
          )
            return u;
          const h = $s[e],
            d = u.body.getReader(),
            p = u.headers.get("Content-Length") || u.headers.get("X-File-Size"),
            m = p ? parseInt(p) : 0,
            _ = m !== 0;
          let y = 0;
          const x = new ReadableStream({
            start(g) {
              S();
              function S() {
                d.read().then(({ done: A, value: E }) => {
                  if (A) g.close();
                  else {
                    y += E.byteLength;
                    const C = new ProgressEvent("progress", {
                      lengthComputable: _,
                      loaded: y,
                      total: m,
                    });
                    for (let R = 0, P = h.length; R < P; R++) {
                      const L = h[R];
                      L.onProgress && L.onProgress(C);
                    }
                    g.enqueue(E), S();
                  }
                });
              }
            },
          });
          return new Response(x);
        } else
          throw new f8(
            `fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`,
            u
          );
      })
      .then((u) => {
        switch (l) {
          case "arraybuffer":
            return u.arrayBuffer();
          case "blob":
            return u.blob();
          case "document":
            return u.text().then((h) => new DOMParser().parseFromString(h, a));
          case "json":
            return u.json();
          default:
            if (a === void 0) return u.text();
            {
              const d = /charset="?([^;"\s]*)"?/i.exec(a),
                p = d && d[1] ? d[1].toLowerCase() : void 0,
                m = new TextDecoder(p);
              return u.arrayBuffer().then((_) => m.decode(_));
            }
        }
      })
      .then((u) => {
        Fl.add(e, u);
        const h = $s[e];
        delete $s[e];
        for (let d = 0, p = h.length; d < p; d++) {
          const m = h[d];
          m.onLoad && m.onLoad(u);
        }
      })
      .catch((u) => {
        const h = $s[e];
        if (h === void 0) throw (this.manager.itemError(e), u);
        delete $s[e];
        for (let d = 0, p = h.length; d < p; d++) {
          const m = h[d];
          m.onError && m.onError(u);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class h8 extends xr {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = new hi(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            i ? i(l) : console.error(l), s.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const i = Rc.parse(e[r]);
      t.push(i);
    }
    return t;
  }
}
class d8 extends xr {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = [],
      a = new S1(),
      l = new hi(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(s.withCredentials);
    let u = 0;
    function h(d) {
      l.load(
        e[d],
        function (p) {
          const m = s.parse(p, !0);
          (o[d] = {
            width: m.width,
            height: m.height,
            format: m.format,
            mipmaps: m.mipmaps,
          }),
            (u += 1),
            u === 6 &&
              (m.mipmapCount === 1 && (a.minFilter = sn),
              (a.image = o),
              (a.format = m.format),
              (a.needsUpdate = !0),
              t && t(a));
        },
        r,
        i
      );
    }
    if (Array.isArray(e)) for (let d = 0, p = e.length; d < p; ++d) h(d);
    else
      l.load(
        e,
        function (d) {
          const p = s.parse(d, !0);
          if (p.isCubemap) {
            const m = p.mipmaps.length / p.mipmapCount;
            for (let _ = 0; _ < m; _++) {
              o[_] = { mipmaps: [] };
              for (let y = 0; y < p.mipmapCount; y++)
                o[_].mipmaps.push(p.mipmaps[_ * p.mipmapCount + y]),
                  (o[_].format = p.format),
                  (o[_].width = p.width),
                  (o[_].height = p.height);
            }
            a.image = o;
          } else
            (a.image.width = p.width),
              (a.image.height = p.height),
              (a.mipmaps = p.mipmaps);
          p.mipmapCount === 1 && (a.minFilter = sn),
            (a.format = p.format),
            (a.needsUpdate = !0),
            t && t(a);
        },
        r,
        i
      );
    return a;
  }
}
class Hh extends xr {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = Fl.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = Nh("img");
    function l() {
      h(), Fl.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function u(d) {
      h(), i && i(d), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function h() {
      a.removeEventListener("load", l, !1),
        a.removeEventListener("error", u, !1);
    }
    return (
      a.addEventListener("load", l, !1),
      a.addEventListener("error", u, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class p8 extends xr {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = new ud();
    s.colorSpace = ht;
    const o = new Hh(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function l(u) {
      o.load(
        e[u],
        function (h) {
          (s.images[u] = h), a++, a === 6 && ((s.needsUpdate = !0), t && t(s));
        },
        void 0,
        i
      );
    }
    for (let u = 0; u < e.length; ++u) l(u);
    return s;
  }
}
class m8 extends xr {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = new ac(),
      a = new hi(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (l) {
          const u = s.parse(l);
          u &&
            (u.image !== void 0
              ? (o.image = u.image)
              : u.data !== void 0 &&
                ((o.image.width = u.width),
                (o.image.height = u.height),
                (o.image.data = u.data)),
            (o.wrapS = u.wrapS !== void 0 ? u.wrapS : er),
            (o.wrapT = u.wrapT !== void 0 ? u.wrapT : er),
            (o.magFilter = u.magFilter !== void 0 ? u.magFilter : sn),
            (o.minFilter = u.minFilter !== void 0 ? u.minFilter : sn),
            (o.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1),
            u.colorSpace !== void 0
              ? (o.colorSpace = u.colorSpace)
              : u.encoding !== void 0 && (o.encoding = u.encoding),
            u.flipY !== void 0 && (o.flipY = u.flipY),
            u.format !== void 0 && (o.format = u.format),
            u.type !== void 0 && (o.type = u.type),
            u.mipmaps !== void 0 &&
              ((o.mipmaps = u.mipmaps), (o.minFilter = Ns)),
            u.mipmapCount === 1 && (o.minFilter = sn),
            u.generateMipmaps !== void 0 &&
              (o.generateMipmaps = u.generateMipmaps),
            (o.needsUpdate = !0),
            t && t(o, u));
        },
        r,
        i
      ),
      o
    );
  }
}
class _L extends xr {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = new en(),
      o = new Hh(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          (s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s);
        },
        r,
        i
      ),
      s
    );
  }
}
class Ba extends bt {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Be(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
class vL extends Ba {
  constructor(e, t, r) {
    super(e, r),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(bt.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new Be(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const uy = new rt(),
  MT = new U(),
  ET = new U();
class I1 {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new ge(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new rt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new M0()),
      (this._frameExtents = new ge(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Nt(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      r = this.matrix;
    MT.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(MT),
      ET.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(ET),
      t.updateMatrixWorld(),
      uy.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(uy),
      r.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      r.multiply(uy);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class g8 extends I1 {
  constructor() {
    super(new Mn(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      r = Ec * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far;
    (r !== t.fov || i !== t.aspect || s !== t.far) &&
      ((t.fov = r), (t.aspect = i), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class D1 extends Ba {
  constructor(e, t, r = 0, i = Math.PI / 3, s = 0, o = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(bt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new bt()),
      (this.distance = r),
      (this.angle = i),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new g8());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const wT = new rt(),
  Lf = new U(),
  cy = new U();
class _8 extends I1 {
  constructor() {
    super(new Mn(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new ge(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Nt(2, 1, 1, 1),
        new Nt(0, 1, 1, 1),
        new Nt(3, 1, 1, 1),
        new Nt(1, 1, 1, 1),
        new Nt(3, 0, 1, 1),
        new Nt(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new U(1, 0, 0),
        new U(-1, 0, 0),
        new U(0, 0, 1),
        new U(0, 0, -1),
        new U(0, 1, 0),
        new U(0, -1, 0),
      ]),
      (this._cubeUps = [
        new U(0, 1, 0),
        new U(0, 1, 0),
        new U(0, 1, 0),
        new U(0, 1, 0),
        new U(0, 0, 1),
        new U(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const r = this.camera,
      i = this.matrix,
      s = e.distance || r.far;
    s !== r.far && ((r.far = s), r.updateProjectionMatrix()),
      Lf.setFromMatrixPosition(e.matrixWorld),
      r.position.copy(Lf),
      cy.copy(r.position),
      cy.add(this._cubeDirections[t]),
      r.up.copy(this._cubeUps[t]),
      r.lookAt(cy),
      r.updateMatrixWorld(),
      i.makeTranslation(-Lf.x, -Lf.y, -Lf.z),
      wT.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(wT);
  }
}
class F1 extends Ba {
  constructor(e, t, r = 0, i = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = r),
      (this.decay = i),
      (this.shadow = new _8());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class v8 extends I1 {
  constructor() {
    super(new Ra(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class N1 extends Ba {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(bt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new bt()),
      (this.shadow = new v8());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class yL extends Ba {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class xL extends Ba {
  constructor(e, t, r = 10, i = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = r),
      (this.height = i);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
class SL {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new U());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const r = e.x,
      i = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.282095),
      t.addScaledVector(o[1], 0.488603 * i),
      t.addScaledVector(o[2], 0.488603 * s),
      t.addScaledVector(o[3], 0.488603 * r),
      t.addScaledVector(o[4], 1.092548 * (r * i)),
      t.addScaledVector(o[5], 1.092548 * (i * s)),
      t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)),
      t.addScaledVector(o[7], 1.092548 * (r * s)),
      t.addScaledVector(o[8], 0.546274 * (r * r - i * i)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const r = e.x,
      i = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.886227),
      t.addScaledVector(o[1], 2 * 0.511664 * i),
      t.addScaledVector(o[2], 2 * 0.511664 * s),
      t.addScaledVector(o[3], 2 * 0.511664 * r),
      t.addScaledVector(o[4], 2 * 0.429043 * r * i),
      t.addScaledVector(o[5], 2 * 0.429043 * i * s),
      t.addScaledVector(o[6], 0.743125 * s * s - 0.247708),
      t.addScaledVector(o[7], 2 * 0.429043 * r * s),
      t.addScaledVector(o[8], 0.429043 * (r * r - i * i)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let r = 0; r < 9; r++) this.coefficients[r].lerp(e.coefficients[r], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].toArray(e, t + i * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const r = e.x,
      i = e.y,
      s = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * i),
      (t[2] = 0.488603 * s),
      (t[3] = 0.488603 * r),
      (t[4] = 1.092548 * r * i),
      (t[5] = 1.092548 * i * s),
      (t[6] = 0.315392 * (3 * s * s - 1)),
      (t[7] = 1.092548 * r * s),
      (t[8] = 0.546274 * (r * r - i * i));
  }
}
class V0 extends Ba {
  constructor(e = new SL(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
class W0 extends xr {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, t, r, i) {
    const s = this,
      o = new hi(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            i ? i(l) : console.error(l), s.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = this.textures;
    function r(s) {
      return (
        t[s] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", s),
        t[s]
      );
    }
    const i = W0.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (i.uuid = e.uuid),
      e.name !== void 0 && (i.name = e.name),
      e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
      e.roughness !== void 0 && (i.roughness = e.roughness),
      e.metalness !== void 0 && (i.metalness = e.metalness),
      e.sheen !== void 0 && (i.sheen = e.sheen),
      e.sheenColor !== void 0 && (i.sheenColor = new Be().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        i.emissive !== void 0 &&
        i.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        i.specular !== void 0 &&
        i.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (i.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        i.specularColor !== void 0 &&
        i.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (i.shininess = e.shininess),
      e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = e.clearcoatRoughness),
      e.iridescence !== void 0 && (i.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (i.transmission = e.transmission),
      e.thickness !== void 0 && (i.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (i.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        i.attenuationColor !== void 0 &&
        i.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (i.fog = e.fog),
      e.flatShading !== void 0 && (i.flatShading = e.flatShading),
      e.blending !== void 0 && (i.blending = e.blending),
      e.combine !== void 0 && (i.combine = e.combine),
      e.side !== void 0 && (i.side = e.side),
      e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (i.opacity = e.opacity),
      e.transparent !== void 0 && (i.transparent = e.transparent),
      e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash),
      e.depthTest !== void 0 && (i.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
      e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
      e.stencilWriteMask !== void 0 &&
        (i.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
      e.wireframe !== void 0 && (i.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (i.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (i.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (i.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (i.rotation = e.rotation),
      e.linewidth !== 1 && (i.linewidth = e.linewidth),
      e.dashSize !== void 0 && (i.dashSize = e.dashSize),
      e.gapSize !== void 0 && (i.gapSize = e.gapSize),
      e.scale !== void 0 && (i.scale = e.scale),
      e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (i.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (i.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (i.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (i.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (i.visible = e.visible),
      e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
      e.userData !== void 0 && (i.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (i.vertexColors = e.vertexColors > 0)
          : (i.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const s in e.uniforms) {
        const o = e.uniforms[s];
        switch (((i.uniforms[s] = {}), o.type)) {
          case "t":
            i.uniforms[s].value = r(o.value);
            break;
          case "c":
            i.uniforms[s].value = new Be().setHex(o.value);
            break;
          case "v2":
            i.uniforms[s].value = new ge().fromArray(o.value);
            break;
          case "v3":
            i.uniforms[s].value = new U().fromArray(o.value);
            break;
          case "v4":
            i.uniforms[s].value = new Nt().fromArray(o.value);
            break;
          case "m3":
            i.uniforms[s].value = new _t().fromArray(o.value);
            break;
          case "m4":
            i.uniforms[s].value = new rt().fromArray(o.value);
            break;
          default:
            i.uniforms[s].value = o.value;
        }
      }
    if (
      (e.defines !== void 0 && (i.defines = e.defines),
      e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const s in e.extensions) i.extensions[s] = e.extensions[s];
    if (
      (e.lights !== void 0 && (i.lights = e.lights),
      e.clipping !== void 0 && (i.clipping = e.clipping),
      e.size !== void 0 && (i.size = e.size),
      e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (i.map = r(e.map)),
      e.matcap !== void 0 && (i.matcap = r(e.matcap)),
      e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)),
      e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)),
      e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)),
      e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]),
        (i.normalScale = new ge().fromArray(s));
    }
    return (
      e.displacementMap !== void 0 &&
        (i.displacementMap = r(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (i.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (i.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)),
      e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)),
      e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (i.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (i.specularIntensityMap = r(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (i.specularColorMap = r(e.specularColorMap)),
      e.envMap !== void 0 && (i.envMap = r(e.envMap)),
      e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (i.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)),
      e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)),
      e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (i.clearcoatNormalMap = r(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (i.clearcoatNormalScale = new ge().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (i.transmissionMap = r(e.transmissionMap)),
      e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (i.anisotropyMap = r(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (i.sheenRoughnessMap = r(e.sheenRoughnessMap)),
      i
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: iL,
      SpriteMaterial: g1,
      RawShaderMaterial: sL,
      ShaderMaterial: Os,
      PointsMaterial: b0,
      MeshPhysicalMaterial: zs,
      MeshStandardMaterial: da,
      MeshPhongMaterial: oL,
      MeshToonMaterial: aL,
      MeshNormalMaterial: lL,
      MeshLambertMaterial: uL,
      MeshDepthMaterial: d1,
      MeshDistanceMaterial: p1,
      MeshBasicMaterial: kr,
      MeshMatcapMaterial: cL,
      LineDashedMaterial: fL,
      LineBasicMaterial: yr,
      Material: In,
    };
    return new t[e]();
  }
}
class Is {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let t = "";
    for (let r = 0, i = e.length; r < i; r++) t += String.fromCharCode(e[r]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class AL extends dt {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class ML extends xr {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = new hi(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            i ? i(l) : console.error(l), s.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = {},
      r = {};
    function i(m, _) {
      if (t[_] !== void 0) return t[_];
      const x = m.interleavedBuffers[_],
        g = s(m, x.buffer),
        S = Ju(x.type, g),
        A = new fd(S, x.stride);
      return (A.uuid = x.uuid), (t[_] = A), A;
    }
    function s(m, _) {
      if (r[_] !== void 0) return r[_];
      const x = m.arrayBuffers[_],
        g = new Uint32Array(x).buffer;
      return (r[_] = g), g;
    }
    const o = e.isInstancedBufferGeometry ? new AL() : new dt(),
      a = e.data.index;
    if (a !== void 0) {
      const m = Ju(a.type, a.array);
      o.setIndex(new Dt(m, 1));
    }
    const l = e.data.attributes;
    for (const m in l) {
      const _ = l[m];
      let y;
      if (_.isInterleavedBufferAttribute) {
        const x = i(e.data, _.data);
        y = new Sa(x, _.itemSize, _.offset, _.normalized);
      } else {
        const x = Ju(_.type, _.array),
          g = _.isInstancedBufferAttribute ? Cc : Dt;
        y = new g(x, _.itemSize, _.normalized);
      }
      _.name !== void 0 && (y.name = _.name),
        _.usage !== void 0 && y.setUsage(_.usage),
        _.updateRange !== void 0 &&
          ((y.updateRange.offset = _.updateRange.offset),
          (y.updateRange.count = _.updateRange.count)),
        o.setAttribute(m, y);
    }
    const u = e.data.morphAttributes;
    if (u)
      for (const m in u) {
        const _ = u[m],
          y = [];
        for (let x = 0, g = _.length; x < g; x++) {
          const S = _[x];
          let A;
          if (S.isInterleavedBufferAttribute) {
            const E = i(e.data, S.data);
            A = new Sa(E, S.itemSize, S.offset, S.normalized);
          } else {
            const E = Ju(S.type, S.array);
            A = new Dt(E, S.itemSize, S.normalized);
          }
          S.name !== void 0 && (A.name = S.name), y.push(A);
        }
        o.morphAttributes[m] = y;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const d = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (d !== void 0)
      for (let m = 0, _ = d.length; m !== _; ++m) {
        const y = d[m];
        o.addGroup(y.start, y.count, y.materialIndex);
      }
    const p = e.data.boundingSphere;
    if (p !== void 0) {
      const m = new U();
      p.center !== void 0 && m.fromArray(p.center),
        (o.boundingSphere = new Gi(m, p.radius));
    }
    return (
      e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o
    );
  }
}
class y8 extends xr {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = this.path === "" ? Is.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const a = new hi(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (l) {
          let u = null;
          try {
            u = JSON.parse(l);
          } catch (d) {
            i !== void 0 && i(d),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                d.message
              );
            return;
          }
          const h = u.metadata;
          if (
            h === void 0 ||
            h.type === void 0 ||
            h.type.toLowerCase() === "geometry"
          ) {
            i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          s.parse(u, t);
        },
        r,
        i
      );
  }
  async loadAsync(e, t) {
    const r = this,
      i = this.path === "" ? Is.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const s = new hi(this.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials);
    const o = await s.loadAsync(e, t),
      a = JSON.parse(o),
      l = a.metadata;
    if (
      l === void 0 ||
      l.type === void 0 ||
      l.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await r.parseAsync(a);
  }
  parse(e, t) {
    const r = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, i),
      o = this.parseImages(e.images, function () {
        t !== void 0 && t(u);
      }),
      a = this.parseTextures(e.textures, o),
      l = this.parseMaterials(e.materials, a),
      u = this.parseObject(e.object, s, l, a, r),
      h = this.parseSkeletons(e.skeletons, u);
    if ((this.bindSkeletons(u, h), t !== void 0)) {
      let d = !1;
      for (const p in o)
        if (o[p].data instanceof HTMLImageElement) {
          d = !0;
          break;
        }
      d === !1 && t(u);
    }
    return u;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      i = this.parseGeometries(e.geometries, r),
      s = await this.parseImagesAsync(e.images),
      o = this.parseTextures(e.textures, s),
      a = this.parseMaterials(e.materials, o),
      l = this.parseObject(e.object, i, a, o, t),
      u = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, u), l;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0, i = e.length; r < i; r++) {
        const s = new Al().fromJSON(e[r]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const r = {},
      i = {};
    if (
      (t.traverse(function (s) {
        s.isBone && (i[s.uuid] = s);
      }),
      e !== void 0)
    )
      for (let s = 0, o = e.length; s < o; s++) {
        const a = new hd().fromJSON(e[s], i);
        r[a.uuid] = a;
      }
    return r;
  }
  parseGeometries(e, t) {
    const r = {};
    if (e !== void 0) {
      const i = new ML();
      for (let s = 0, o = e.length; s < o; s++) {
        let a;
        const l = e[s];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = i.parse(l);
            break;
          default:
            l.type in AT
              ? (a = AT[l.type].fromJSON(l, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${l.type}"`
                );
        }
        (a.uuid = l.uuid),
          l.name !== void 0 && (a.name = l.name),
          l.userData !== void 0 && (a.userData = l.userData),
          (r[l.uuid] = a);
      }
    }
    return r;
  }
  parseMaterials(e, t) {
    const r = {},
      i = {};
    if (e !== void 0) {
      const s = new W0();
      s.setTextures(t);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o];
        r[l.uuid] === void 0 && (r[l.uuid] = s.parse(l)),
          (i[l.uuid] = r[l.uuid]);
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0; r < e.length; r++) {
        const i = e[r],
          s = Rc.parse(i);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const r = this,
      i = {};
    let s;
    function o(l) {
      return (
        r.manager.itemStart(l),
        s.load(
          l,
          function () {
            r.manager.itemEnd(l);
          },
          void 0,
          function () {
            r.manager.itemError(l), r.manager.itemEnd(l);
          }
        )
      );
    }
    function a(l) {
      if (typeof l == "string") {
        const u = l,
          h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : r.resourcePath + u;
        return o(h);
      } else
        return l.data
          ? { data: Ju(l.type, l.data), width: l.width, height: l.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new L1(t);
      (s = new Hh(l)), s.setCrossOrigin(this.crossOrigin);
      for (let u = 0, h = e.length; u < h; u++) {
        const d = e[u],
          p = d.url;
        if (Array.isArray(p)) {
          const m = [];
          for (let _ = 0, y = p.length; _ < y; _++) {
            const x = p[_],
              g = a(x);
            g !== null &&
              (g instanceof HTMLImageElement
                ? m.push(g)
                : m.push(new ac(g.data, g.width, g.height)));
          }
          i[d.uuid] = new dl(m);
        } else {
          const m = a(d.url);
          i[d.uuid] = new dl(m);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this,
      r = {};
    let i;
    async function s(o) {
      if (typeof o == "string") {
        const a = o,
          l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await i.loadAsync(l);
      } else
        return o.data
          ? { data: Ju(o.type, o.data), width: o.width, height: o.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (i = new Hh(this.manager)), i.setCrossOrigin(this.crossOrigin);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o],
          u = l.url;
        if (Array.isArray(u)) {
          const h = [];
          for (let d = 0, p = u.length; d < p; d++) {
            const m = u[d],
              _ = await s(m);
            _ !== null &&
              (_ instanceof HTMLImageElement
                ? h.push(_)
                : h.push(new ac(_.data, _.width, _.height)));
          }
          r[l.uuid] = new dl(h);
        } else {
          const h = await s(l.url);
          r[l.uuid] = new dl(h);
        }
      }
    }
    return r;
  }
  parseTextures(e, t) {
    function r(s, o) {
      return typeof s == "number"
        ? s
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            s
          ),
          o[s]);
    }
    const i = {};
    if (e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s];
        a.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
          t[a.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const l = t[a.image],
          u = l.data;
        let h;
        Array.isArray(u)
          ? ((h = new ud()), u.length === 6 && (h.needsUpdate = !0))
          : (u && u.data ? (h = new ac()) : (h = new en()),
            u && (h.needsUpdate = !0)),
          (h.source = l),
          (h.uuid = a.uuid),
          a.name !== void 0 && (h.name = a.name),
          a.mapping !== void 0 && (h.mapping = r(a.mapping, x8)),
          a.channel !== void 0 && (h.channel = a.channel),
          a.offset !== void 0 && h.offset.fromArray(a.offset),
          a.repeat !== void 0 && h.repeat.fromArray(a.repeat),
          a.center !== void 0 && h.center.fromArray(a.center),
          a.rotation !== void 0 && (h.rotation = a.rotation),
          a.wrap !== void 0 &&
            ((h.wrapS = r(a.wrap[0], CT)), (h.wrapT = r(a.wrap[1], CT))),
          a.format !== void 0 && (h.format = a.format),
          a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat),
          a.type !== void 0 && (h.type = a.type),
          a.colorSpace !== void 0 && (h.colorSpace = a.colorSpace),
          a.encoding !== void 0 && (h.encoding = a.encoding),
          a.minFilter !== void 0 && (h.minFilter = r(a.minFilter, TT)),
          a.magFilter !== void 0 && (h.magFilter = r(a.magFilter, TT)),
          a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy),
          a.flipY !== void 0 && (h.flipY = a.flipY),
          a.generateMipmaps !== void 0 &&
            (h.generateMipmaps = a.generateMipmaps),
          a.premultiplyAlpha !== void 0 &&
            (h.premultiplyAlpha = a.premultiplyAlpha),
          a.unpackAlignment !== void 0 &&
            (h.unpackAlignment = a.unpackAlignment),
          a.compareFunction !== void 0 &&
            (h.compareFunction = a.compareFunction),
          a.userData !== void 0 && (h.userData = a.userData),
          (i[a.uuid] = h);
      }
    return i;
  }
  parseObject(e, t, r, i, s) {
    let o;
    function a(p) {
      return (
        t[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", p),
        t[p]
      );
    }
    function l(p) {
      if (p !== void 0) {
        if (Array.isArray(p)) {
          const m = [];
          for (let _ = 0, y = p.length; _ < y; _++) {
            const x = p[_];
            r[x] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", x),
              m.push(r[x]);
          }
          return m;
        }
        return (
          r[p] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", p),
          r[p]
        );
      }
    }
    function u(p) {
      return (
        i[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", p),
        i[p]
      );
    }
    let h, d;
    switch (e.type) {
      case "Scene":
        (o = new Ig()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (o.background = new Be(e.background))
              : (o.background = u(e.background))),
          e.environment !== void 0 && (o.environment = u(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (o.fog = new C0(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (o.fog = new w0(e.fog.color, e.fog.density))),
          e.backgroundBlurriness !== void 0 &&
            (o.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (o.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        (o = new Mn(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (o.focus = e.focus),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (o = new Ra(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new yL(e.color, e.intensity);
        break;
      case "DirectionalLight":
        o = new N1(e.color, e.intensity);
        break;
      case "PointLight":
        o = new F1(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new xL(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        o = new D1(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        );
        break;
      case "HemisphereLight":
        o = new vL(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new V0().fromJSON(e);
        break;
      case "SkinnedMesh":
        (h = a(e.geometry)),
          (d = l(e.material)),
          (o = new _1(h, d)),
          e.bindMode !== void 0 && (o.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        (h = a(e.geometry)), (d = l(e.material)), (o = new kn(h, d));
        break;
      case "InstancedMesh":
        (h = a(e.geometry)), (d = l(e.material));
        const p = e.count,
          m = e.instanceMatrix,
          _ = e.instanceColor;
        (o = new v1(h, d, p)),
          (o.instanceMatrix = new Cc(new Float32Array(m.array), 16)),
          _ !== void 0 &&
            (o.instanceColor = new Cc(new Float32Array(_.array), _.itemSize));
        break;
      case "LOD":
        o = new J2();
        break;
      case "Line":
        o = new vo(a(e.geometry), l(e.material));
        break;
      case "LineLoop":
        o = new y1(a(e.geometry), l(e.material));
        break;
      case "LineSegments":
        o = new cs(a(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new x1(a(e.geometry), l(e.material));
        break;
      case "Sprite":
        o = new X2(l(e.material));
        break;
      case "Group":
        o = new uo();
        break;
      case "Bone":
        o = new T0();
        break;
      default:
        o = new bt();
    }
    if (
      ((o.uuid = e.uuid),
      e.name !== void 0 && (o.name = e.name),
      e.matrix !== void 0
        ? (o.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (o.matrixAutoUpdate = e.matrixAutoUpdate),
          o.matrixAutoUpdate &&
            o.matrix.decompose(o.position, o.quaternion, o.scale))
        : (e.position !== void 0 && o.position.fromArray(e.position),
          e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && o.scale.fromArray(e.scale)),
      e.up !== void 0 && o.up.fromArray(e.up),
      e.castShadow !== void 0 && (o.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (o.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (o.visible = e.visible),
      e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
      e.userData !== void 0 && (o.userData = e.userData),
      e.layers !== void 0 && (o.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const p = e.children;
      for (let m = 0; m < p.length; m++)
        o.add(this.parseObject(p[m], t, r, i, s));
    }
    if (e.animations !== void 0) {
      const p = e.animations;
      for (let m = 0; m < p.length; m++) {
        const _ = p[m];
        o.animations.push(s[_]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const p = e.levels;
      for (let m = 0; m < p.length; m++) {
        const _ = p[m],
          y = o.getObjectByProperty("uuid", _.object);
        y !== void 0 && o.addLevel(y, _.distance, _.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (r) {
        if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
          const i = t[r.skeleton];
          i === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                r.skeleton
              )
            : r.bind(i, r.bindMatrix);
        }
      });
  }
}
const x8 = {
    UVMapping: v0,
    CubeReflectionMapping: va,
    CubeRefractionMapping: ya,
    EquirectangularReflectionMapping: Ph,
    EquirectangularRefractionMapping: Bh,
    CubeUVReflectionMapping: Gc,
  },
  CT = {
    RepeatWrapping: xa,
    ClampToEdgeWrapping: er,
    MirroredRepeatWrapping: Sc,
  },
  TT = {
    NearestFilter: mn,
    NearestMipmapNearestFilter: Lh,
    NearestMipmapLinearFilter: sc,
    LinearFilter: sn,
    LinearMipmapNearestFilter: y0,
    LinearMipmapLinearFilter: Ns,
  };
class EL extends xr {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = Fl.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = {};
    (a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader),
      fetch(e, a)
        .then(function (l) {
          return l.blob();
        })
        .then(function (l) {
          return createImageBitmap(
            l,
            Object.assign(s.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (l) {
          Fl.add(e, l), t && t(l), s.manager.itemEnd(e);
        })
        .catch(function (l) {
          i && i(l), s.manager.itemError(e), s.manager.itemEnd(e);
        }),
      s.manager.itemStart(e);
  }
}
let mm;
class O1 {
  static getContext() {
    return (
      mm === void 0 &&
        (mm = new (window.AudioContext || window.webkitAudioContext)()),
      mm
    );
  }
  static setContext(e) {
    mm = e;
  }
}
class S8 extends xr {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = new hi(this.manager);
    o.setResponseType("arraybuffer"),
      o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (l) {
          try {
            const u = l.slice(0);
            O1.getContext().decodeAudioData(
              u,
              function (d) {
                t(d);
              },
              a
            );
          } catch (u) {
            a(u);
          }
        },
        r,
        i
      );
    function a(l) {
      i ? i(l) : console.error(l), s.manager.itemError(e);
    }
  }
}
class A8 extends V0 {
  constructor(e, t, r = 1) {
    super(void 0, r), (this.isHemisphereLightProbe = !0);
    const i = new Be().set(e),
      s = new Be().set(t),
      o = new U(i.r, i.g, i.b),
      a = new U(s.r, s.g, s.b),
      l = Math.sqrt(Math.PI),
      u = l * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),
      this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(u);
  }
}
class M8 extends V0 {
  constructor(e, t = 1) {
    super(void 0, t), (this.isAmbientLightProbe = !0);
    const r = new Be().set(e);
    this.sh.coefficients[0]
      .set(r.r, r.g, r.b)
      .multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
const bT = new rt(),
  RT = new rt(),
  Xa = new rt();
class E8 {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new Mn()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new Mn()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      (t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        Xa.copy(e.projectionMatrix);
      const i = t.eyeSep / 2,
        s = (i * t.near) / t.focus,
        o = (t.near * Math.tan(xl * t.fov * 0.5)) / t.zoom;
      let a, l;
      (RT.elements[12] = -i),
        (bT.elements[12] = i),
        (a = -o * t.aspect + s),
        (l = o * t.aspect + s),
        (Xa.elements[0] = (2 * t.near) / (l - a)),
        (Xa.elements[8] = (l + a) / (l - a)),
        this.cameraL.projectionMatrix.copy(Xa),
        (a = -o * t.aspect - s),
        (l = o * t.aspect - s),
        (Xa.elements[0] = (2 * t.near) / (l - a)),
        (Xa.elements[8] = (l + a) / (l - a)),
        this.cameraR.projectionMatrix.copy(Xa);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(RT),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(bT);
  }
}
class U1 {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = PT()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = PT();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function PT() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Ja = new U(),
  BT = new mr(),
  w8 = new U(),
  Ka = new U();
class C8 extends bt {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = O1.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new U1());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener,
      r = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(Ja, BT, w8),
      Ka.set(0, 0, -1).applyQuaternion(BT),
      t.positionX)
    ) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Ja.x, i),
        t.positionY.linearRampToValueAtTime(Ja.y, i),
        t.positionZ.linearRampToValueAtTime(Ja.z, i),
        t.forwardX.linearRampToValueAtTime(Ka.x, i),
        t.forwardY.linearRampToValueAtTime(Ka.y, i),
        t.forwardZ.linearRampToValueAtTime(Ka.z, i),
        t.upX.linearRampToValueAtTime(r.x, i),
        t.upY.linearRampToValueAtTime(r.y, i),
        t.upZ.linearRampToValueAtTime(r.z, i);
    } else
      t.setPosition(Ja.x, Ja.y, Ja.z),
        t.setOrientation(Ka.x, Ka.y, Ka.z, r.x, r.y, r.z);
  }
}
class wL extends bt {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else this.source.disconnect(this.getOutput());
    return (this._connected = !1), this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    if (((this.detune = e), this.source.detune !== void 0))
      return (
        this.isPlaying === !0 &&
          this.source.detune.setTargetAtTime(
            this.detune,
            this.context.currentTime,
            0.01
          ),
        this
      );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
}
const Ya = new U(),
  LT = new mr(),
  T8 = new U(),
  Qa = new U();
class b8 extends wL {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, t, r) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = r),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(Ya, LT, T8), Qa.set(0, 0, 1).applyQuaternion(LT);
    const t = this.panner;
    if (t.positionX) {
      const r = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Ya.x, r),
        t.positionY.linearRampToValueAtTime(Ya.y, r),
        t.positionZ.linearRampToValueAtTime(Ya.z, r),
        t.orientationX.linearRampToValueAtTime(Qa.x, r),
        t.orientationY.linearRampToValueAtTime(Qa.y, r),
        t.orientationZ.linearRampToValueAtTime(Qa.z, r);
    } else t.setPosition(Ya.x, Ya.y, Ya.z), t.setOrientation(Qa.x, Qa.y, Qa.z);
  }
}
class R8 {
  constructor(e, t = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let r = 0; r < t.length; r++) e += t[r];
    return e / t.length;
  }
}
class CL {
  constructor(e, t, r) {
    (this.binding = e), (this.valueSize = r);
    let i, s, o;
    switch (t) {
      case "quaternion":
        (i = this._slerp),
          (s = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(r * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (i = this._select),
          (s = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(r * 5));
        break;
      default:
        (i = this._lerp),
          (s = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(r * 5));
    }
    (this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const r = this.buffer,
      i = this.valueSize,
      s = e * i + i;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== i; ++a) r[s + a] = r[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(r, s, 0, a, i);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      r = this.valueSize,
      i = r * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, i, 0, e, r),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      r = this.buffer,
      i = e * t + t,
      s = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      a = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const l = t * this._origIndex;
      this._mixBufferRegion(r, i, l, 1 - s, t);
    }
    o > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * t, 1, t);
    for (let l = t, u = t + t; l !== u; ++l)
      if (r[l] !== r[l + t]) {
        a.setValue(r, i);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      r = this.valueSize,
      i = r * this._origIndex;
    e.getValue(t, i);
    for (let s = r, o = i; s !== o; ++s) t[s] = t[i + (s % r)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let r = e; r < t; r++) this.buffer[r] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let r = 0; r < this.valueSize; r++)
      this.buffer[t + r] = this.buffer[e + r];
  }
  _select(e, t, r, i, s) {
    if (i >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[r + o];
  }
  _slerp(e, t, r, i) {
    mr.slerpFlat(e, t, e, t, e, r, i);
  }
  _slerpAdditive(e, t, r, i, s) {
    const o = this._workIndex * s;
    mr.multiplyQuaternionsFlat(e, o, e, t, e, r),
      mr.slerpFlat(e, t, e, t, e, o, i);
  }
  _lerp(e, t, r, i, s) {
    const o = 1 - i;
    for (let a = 0; a !== s; ++a) {
      const l = t + a;
      e[l] = e[l] * o + e[r + a] * i;
    }
  }
  _lerpAdditive(e, t, r, i, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o;
      e[a] = e[a] + e[r + o] * i;
    }
  }
}
const k1 = "\\[\\]\\.:\\/",
  P8 = new RegExp("[" + k1 + "]", "g"),
  z1 = "[^" + k1 + "]",
  B8 = "[^" + k1.replace("\\.", "") + "]",
  L8 = /((?:WC+[\/:])*)/.source.replace("WC", z1),
  I8 = /(WCOD+)?/.source.replace("WCOD", B8),
  D8 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", z1),
  F8 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", z1),
  N8 = new RegExp("^" + L8 + I8 + D8 + F8 + "$"),
  O8 = ["material", "materials", "bones", "map"];
class U8 {
  constructor(e, t, r) {
    const i = r || Tt.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  getValue(e, t) {
    this.bind();
    const r = this._targetGroup.nCachedObjects_,
      i = this._bindings[r];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const r = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, s = r.length; i !== s; ++i)
      r[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].unbind();
  }
}
class Tt {
  constructor(e, t, r) {
    (this.path = t),
      (this.parsedPath = r || Tt.parseTrackName(t)),
      (this.node = Tt.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, r) {
    return e && e.isAnimationObjectGroup
      ? new Tt.Composite(e, t, r)
      : new Tt(e, t, r);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(P8, "");
  }
  static parseTrackName(e) {
    const t = N8.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const r = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      i = r.nodeName && r.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const s = r.nodeName.substring(i + 1);
      O8.indexOf(s) !== -1 &&
        ((r.nodeName = r.nodeName.substring(0, i)), (r.objectName = s));
    }
    if (r.propertyName === null || r.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return r;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const r = e.skeleton.getBoneByName(t);
      if (r !== void 0) return r;
    }
    if (e.children) {
      const r = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o];
            if (a.name === t || a.uuid === t) return a;
            const l = r(a.children);
            if (l) return l;
          }
          return null;
        },
        i = r(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i) e[t++] = r[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      r = t.objectName,
      i = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = Tt.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.error(
        "THREE.PropertyBinding: Trying to update node for track: " +
          this.path +
          " but it wasn't found."
      );
      return;
    }
    if (r) {
      let u = t.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === u) {
              u = h;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[r] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[r];
      }
      if (u !== void 0) {
        if (e[u] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[u];
      }
    }
    const o = e[i];
    if (o === void 0) {
      const u = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          u +
          "." +
          i +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      (l = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s);
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
Tt.Composite = U8;
Tt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
Tt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
Tt.prototype.GetterByBindingType = [
  Tt.prototype._getValue_direct,
  Tt.prototype._getValue_array,
  Tt.prototype._getValue_arrayElement,
  Tt.prototype._getValue_toArray,
];
Tt.prototype.SetterByBindingTypeAndVersioning = [
  [
    Tt.prototype._setValue_direct,
    Tt.prototype._setValue_direct_setNeedsUpdate,
    Tt.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Tt.prototype._setValue_array,
    Tt.prototype._setValue_array_setNeedsUpdate,
    Tt.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Tt.prototype._setValue_arrayElement,
    Tt.prototype._setValue_arrayElement_setNeedsUpdate,
    Tt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Tt.prototype._setValue_fromArray,
    Tt.prototype._setValue_fromArray_setNeedsUpdate,
    Tt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class k8 {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = ui()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let r = 0, i = arguments.length; r !== i; ++r)
      e[arguments[r].uuid] = r;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._paths,
      i = this._parsedPaths,
      s = this._bindings,
      o = s.length;
    let a,
      l = e.length,
      u = this.nCachedObjects_;
    for (let h = 0, d = arguments.length; h !== d; ++h) {
      const p = arguments[h],
        m = p.uuid;
      let _ = t[m];
      if (_ === void 0) {
        (_ = l++), (t[m] = _), e.push(p);
        for (let y = 0, x = o; y !== x; ++y) s[y].push(new Tt(p, r[y], i[y]));
      } else if (_ < u) {
        a = e[_];
        const y = --u,
          x = e[y];
        (t[x.uuid] = _), (e[_] = x), (t[m] = y), (e[y] = p);
        for (let g = 0, S = o; g !== S; ++g) {
          const A = s[g],
            E = A[y];
          let C = A[_];
          (A[_] = E), C === void 0 && (C = new Tt(p, r[g], i[g])), (A[y] = C);
        }
      } else
        e[_] !== a &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = u;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let s = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const l = arguments[o],
        u = l.uuid,
        h = t[u];
      if (h !== void 0 && h >= s) {
        const d = s++,
          p = e[d];
        (t[p.uuid] = h), (e[h] = p), (t[u] = d), (e[d] = l);
        for (let m = 0, _ = i; m !== _; ++m) {
          const y = r[m],
            x = y[d],
            g = y[h];
          (y[h] = x), (y[d] = g);
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let s = this.nCachedObjects_,
      o = e.length;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const u = arguments[a],
        h = u.uuid,
        d = t[h];
      if (d !== void 0)
        if ((delete t[h], d < s)) {
          const p = --s,
            m = e[p],
            _ = --o,
            y = e[_];
          (t[m.uuid] = d), (e[d] = m), (t[y.uuid] = p), (e[p] = y), e.pop();
          for (let x = 0, g = i; x !== g; ++x) {
            const S = r[x],
              A = S[p],
              E = S[_];
            (S[d] = A), (S[p] = E), S.pop();
          }
        } else {
          const p = --o,
            m = e[p];
          p > 0 && (t[m.uuid] = d), (e[d] = m), e.pop();
          for (let _ = 0, y = i; _ !== y; ++_) {
            const x = r[_];
            (x[d] = x[p]), x.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, t) {
    const r = this._bindingsIndicesByPath;
    let i = r[e];
    const s = this._bindings;
    if (i !== void 0) return s[i];
    const o = this._paths,
      a = this._parsedPaths,
      l = this._objects,
      u = l.length,
      h = this.nCachedObjects_,
      d = new Array(u);
    (i = s.length), (r[e] = i), o.push(e), a.push(t), s.push(d);
    for (let p = h, m = l.length; p !== m; ++p) {
      const _ = l[p];
      d[p] = new Tt(_, e, t);
    }
    return d;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      r = t[e];
    if (r !== void 0) {
      const i = this._paths,
        s = this._parsedPaths,
        o = this._bindings,
        a = o.length - 1,
        l = o[a],
        u = e[a];
      (t[u] = r),
        (o[r] = l),
        o.pop(),
        (s[r] = s[a]),
        s.pop(),
        (i[r] = i[a]),
        i.pop();
    }
  }
}
class TL {
  constructor(e, t, r = null, i = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = r),
      (this.blendMode = i);
    const s = t.tracks,
      o = s.length,
      a = new Array(o),
      l = { endingStart: fl, endingEnd: fl };
    for (let u = 0; u !== o; ++u) {
      const h = s[u].createInterpolant(null);
      (a[u] = h), (h.settings = l);
    }
    (this._interpolantSettings = l),
      (this._interpolants = a),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = d2),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, r) {
    if ((e.fadeOut(t), this.fadeIn(t), r)) {
      const i = this._clip.duration,
        s = e._clip.duration,
        o = s / i,
        a = i / s;
      e.warp(1, o, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, r) {
    return e.crossFadeFrom(this, t, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, r) {
    const i = this._mixer,
      s = i.time,
      o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null &&
      ((a = i._lendControlInterpolant()), (this._timeScaleInterpolant = a));
    const l = a.parameterPositions,
      u = a.sampleValues;
    return (l[0] = s), (l[1] = s + r), (u[0] = e / o), (u[1] = t / o), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, r, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const l = (e - s) * r;
      l < 0 || r === 0 ? (t = 0) : ((this._startTime = null), (t = r * l));
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t),
      a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants,
        u = this._propertyBindings;
      switch (this.blendMode) {
        case r1:
          for (let h = 0, d = l.length; h !== d; ++h)
            l[h].evaluate(o), u[h].accumulateAdditive(a);
          break;
        case S0:
        default:
          for (let h = 0, d = l.length; h !== d; ++h)
            l[h].evaluate(o), u[h].accumulate(i, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (t *= i),
          e > r.parameterPositions[1] &&
            (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const r = this._timeScaleInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (t *= i),
          e > r.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      r = this.loop;
    let i = this.time + e,
      s = this._loopCount;
    const o = r === p2;
    if (e === 0) return s === -1 ? i : o && (s & 1) === 1 ? t - i : i;
    if (r === h2) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (i >= t) i = t;
        else if (i < 0) i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        i >= t || i < 0)
      ) {
        const a = Math.floor(i / t);
        (i -= t * a), (s += Math.abs(a));
        const l = this.repetitions - s;
        if (l <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = e > 0 ? t : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (l === 1) {
            const u = e < 0;
            this._setEndings(u, !u, o);
          } else this._setEndings(!1, !1, o);
          (this._loopCount = s),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a,
            });
        }
      } else this.time = i;
      if (o && (s & 1) === 1) return t - i;
    }
    return i;
  }
  _setEndings(e, t, r) {
    const i = this._interpolantSettings;
    r
      ? ((i.endingStart = hl), (i.endingEnd = hl))
      : (e
          ? (i.endingStart = this.zeroSlopeAtStart ? hl : fl)
          : (i.endingStart = Ih),
        t ? (i.endingEnd = this.zeroSlopeAtEnd ? hl : fl) : (i.endingEnd = Ih));
  }
  _scheduleFading(e, t, r) {
    const i = this._mixer,
      s = i.time;
    let o = this._weightInterpolant;
    o === null &&
      ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
    const a = o.parameterPositions,
      l = o.sampleValues;
    return (a[0] = s), (l[0] = t), (a[1] = s + e), (l[1] = r), this;
  }
}
const z8 = new Float32Array(1);
class H8 extends Mo {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const r = e._localRoot || this._root,
      i = e._clip.tracks,
      s = i.length,
      o = e._propertyBindings,
      a = e._interpolants,
      l = r.uuid,
      u = this._bindingsByRootAndName;
    let h = u[l];
    h === void 0 && ((h = {}), (u[l] = h));
    for (let d = 0; d !== s; ++d) {
      const p = i[d],
        m = p.name;
      let _ = h[m];
      if (_ !== void 0) ++_.referenceCount, (o[d] = _);
      else {
        if (((_ = o[d]), _ !== void 0)) {
          _._cacheIndex === null &&
            (++_.referenceCount, this._addInactiveBinding(_, l, m));
          continue;
        }
        const y = t && t._propertyBindings[d].binding.parsedPath;
        (_ = new CL(Tt.create(r, m, y), p.ValueTypeName, p.getValueSize())),
          ++_.referenceCount,
          this._addInactiveBinding(_, l, m),
          (o[d] = _);
      }
      a[d].resultBuffer = _.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const r = (e._localRoot || this._root).uuid,
          i = e._clip.uuid,
          s = this._actionsByClip[i];
        this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, i, r);
      }
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const s = t[r];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const s = t[r];
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, r) {
    const i = this._actions,
      s = this._actionsByClip;
    let o = s[t];
    if (o === void 0)
      (o = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = o);
    else {
      const a = o.knownActions;
      (e._byClipCacheIndex = a.length), a.push(e);
    }
    (e._cacheIndex = i.length), i.push(e), (o.actionByRoot[r] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      r = t[t.length - 1],
      i = e._cacheIndex;
    (r._cacheIndex = i), (t[i] = r), t.pop(), (e._cacheIndex = null);
    const s = e._clip.uuid,
      o = this._actionsByClip,
      a = o[s],
      l = a.knownActions,
      u = l[l.length - 1],
      h = e._byClipCacheIndex;
    (u._byClipCacheIndex = h),
      (l[h] = u),
      l.pop(),
      (e._byClipCacheIndex = null);
    const d = a.actionByRoot,
      p = (e._localRoot || this._root).uuid;
    delete d[p],
      l.length === 0 && delete o[s],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let r = 0, i = t.length; r !== i; ++r) {
      const s = t[r];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      r = e._cacheIndex,
      i = this._nActiveActions++,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = r), (t[r] = s);
  }
  _takeBackAction(e) {
    const t = this._actions,
      r = e._cacheIndex,
      i = --this._nActiveActions,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = r), (t[r] = s);
  }
  _addInactiveBinding(e, t, r) {
    const i = this._bindingsByRootAndName,
      s = this._bindings;
    let o = i[t];
    o === void 0 && ((o = {}), (i[t] = o)),
      (o[r] = e),
      (e._cacheIndex = s.length),
      s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      r = e.binding,
      i = r.rootNode.uuid,
      s = r.path,
      o = this._bindingsByRootAndName,
      a = o[i],
      l = t[t.length - 1],
      u = e._cacheIndex;
    (l._cacheIndex = u),
      (t[u] = l),
      t.pop(),
      delete a[s],
      Object.keys(a).length === 0 && delete o[i];
  }
  _lendBinding(e) {
    const t = this._bindings,
      r = e._cacheIndex,
      i = this._nActiveBindings++,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = r), (t[r] = s);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      r = e._cacheIndex,
      i = --this._nActiveBindings,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = r), (t[r] = s);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let r = e[t];
    return (
      r === void 0 &&
        ((r = new P1(new Float32Array(2), new Float32Array(2), 1, z8)),
        (r.__cacheIndex = t),
        (e[t] = r)),
      r
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      r = e.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      s = t[i];
    (e.__cacheIndex = i), (t[i] = e), (s.__cacheIndex = r), (t[r] = s);
  }
  clipAction(e, t, r) {
    const i = t || this._root,
      s = i.uuid;
    let o = typeof e == "string" ? Rc.findByName(i, e) : e;
    const a = o !== null ? o.uuid : e,
      l = this._actionsByClip[a];
    let u = null;
    if (
      (r === void 0 && (o !== null ? (r = o.blendMode) : (r = S0)),
      l !== void 0)
    ) {
      const d = l.actionByRoot[s];
      if (d !== void 0 && d.blendMode === r) return d;
      (u = l.knownActions[0]), o === null && (o = u._clip);
    }
    if (o === null) return null;
    const h = new TL(this, o, t, r);
    return this._bindAction(h, u), this._addInactiveAction(h, a, s), h;
  }
  existingAction(e, t) {
    const r = t || this._root,
      i = r.uuid,
      s = typeof e == "string" ? Rc.findByName(r, e) : e,
      o = s ? s.uuid : e,
      a = this._actionsByClip[o];
    return (a !== void 0 && a.actionByRoot[i]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let r = t - 1; r >= 0; --r) e[r].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      r = this._nActiveActions,
      i = (this.time += e),
      s = Math.sign(e),
      o = (this._accuIndex ^= 1);
    for (let u = 0; u !== r; ++u) t[u]._update(i, e, s, o);
    const a = this._bindings,
      l = this._nActiveBindings;
    for (let u = 0; u !== l; ++u) a[u].apply(o);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      r = e.uuid,
      i = this._actionsByClip,
      s = i[r];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const u = o[a];
        this._deactivateAction(u);
        const h = u._cacheIndex,
          d = t[t.length - 1];
        (u._cacheIndex = null),
          (u._byClipCacheIndex = null),
          (d._cacheIndex = h),
          (t[h] = d),
          t.pop(),
          this._removeInactiveBindingsForAction(u);
      }
      delete i[r];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      r = this._actionsByClip;
    for (const o in r) {
      const a = r[o].actionByRoot,
        l = a[t];
      l !== void 0 &&
        (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const i = this._bindingsByRootAndName,
      s = i[t];
    if (s !== void 0)
      for (const o in s) {
        const a = s[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  uncacheAction(e, t) {
    const r = this.existingAction(e, t);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
}
class H1 {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new H1(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let G8 = 0;
class V8 extends Mo {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: G8++ }),
      (this.name = ""),
      (this.usage = Dh),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let r = 0, i = t.length; r < i; r++) this.uniforms.push(t[r].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class W8 extends fd {
  constructor(e, t, r = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class j8 {
  constructor(e, t, r, i, s) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = r),
      (this.elementSize = i),
      (this.count = s),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
class bL {
  constructor(e, t, r = 0, i = 1 / 0) {
    (this.ray = new Vc(e, t)),
      (this.near = r),
      (this.far = i),
      (this.camera = null),
      (this.layers = new Sl()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, r = []) {
    return MS(e, this, r, t), r.sort(IT), r;
  }
  intersectObjects(e, t = !0, r = []) {
    for (let i = 0, s = e.length; i < s; i++) MS(e[i], this, r, t);
    return r.sort(IT), r;
  }
}
function IT(n, e) {
  return n.distance - e.distance;
}
function MS(n, e, t, r) {
  if ((n.layers.test(e.layers) && n.raycast(e, t), r === !0)) {
    const i = n.children;
    for (let s = 0, o = i.length; s < o; s++) MS(i[s], e, t, !0);
  }
}
class X8 {
  constructor(e = 1, t = 0, r = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = r), this;
  }
  set(e, t, r) {
    return (this.radius = e), (this.phi = t), (this.theta = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + r * r)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, r)),
          (this.phi = Math.acos(gn(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class J8 {
  constructor(e = 1, t = 0, r = 0) {
    return (this.radius = e), (this.theta = t), (this.y = r), this;
  }
  set(e, t, r) {
    return (this.radius = e), (this.theta = t), (this.y = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return (
      (this.radius = Math.sqrt(e * e + r * r)),
      (this.theta = Math.atan2(e, r)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const DT = new ge();
class K8 {
  constructor(e = new ge(1 / 0, 1 / 0), t = new ge(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = DT.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, DT).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const FT = new U(),
  gm = new U();
class Y8 {
  constructor(e = new U(), t = new U()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    FT.subVectors(e, this.start), gm.subVectors(this.end, this.start);
    const r = gm.dot(gm);
    let s = gm.dot(FT) / r;
    return t && (s = gn(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, r) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(r).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const NT = new U();
class Q8 extends bt {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper");
    const r = new dt(),
      i = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
      const u = (o / l) * Math.PI * 2,
        h = (a / l) * Math.PI * 2;
      i.push(Math.cos(u), Math.sin(u), 1, Math.cos(h), Math.sin(h), 1);
    }
    r.setAttribute("position", new Xe(i, 3));
    const s = new yr({ fog: !1, toneMapped: !1 });
    (this.cone = new cs(r, s)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      NT.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(NT),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const zo = new U(),
  _m = new rt(),
  fy = new rt();
class q8 extends cs {
  constructor(e) {
    const t = RL(e),
      r = new dt(),
      i = [],
      s = [],
      o = new Be(0, 0, 1),
      a = new Be(0, 1, 0);
    for (let u = 0; u < t.length; u++) {
      const h = t[u];
      h.parent &&
        h.parent.isBone &&
        (i.push(0, 0, 0),
        i.push(0, 0, 0),
        s.push(o.r, o.g, o.b),
        s.push(a.r, a.g, a.b));
    }
    r.setAttribute("position", new Xe(i, 3)),
      r.setAttribute("color", new Xe(s, 3));
    const l = new yr({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(r, l),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      r = this.geometry,
      i = r.getAttribute("position");
    fy.copy(this.root.matrixWorld).invert();
    for (let s = 0, o = 0; s < t.length; s++) {
      const a = t[s];
      a.parent &&
        a.parent.isBone &&
        (_m.multiplyMatrices(fy, a.matrixWorld),
        zo.setFromMatrixPosition(_m),
        i.setXYZ(o, zo.x, zo.y, zo.z),
        _m.multiplyMatrices(fy, a.parent.matrixWorld),
        zo.setFromMatrixPosition(_m),
        i.setXYZ(o + 1, zo.x, zo.y, zo.z),
        (o += 2));
    }
    (r.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function RL(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, RL(n.children[t]));
  return e;
}
class Z8 extends kn {
  constructor(e, t, r) {
    const i = new gd(t, 4, 2),
      s = new kr({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, s),
      (this.light = e),
      (this.color = r),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const $8 = new U(),
  OT = new Be(),
  UT = new Be();
class eV extends bt {
  constructor(e, t, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "HemisphereLightHelper");
    const i = new md(t);
    i.rotateY(Math.PI * 0.5),
      (this.material = new kr({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const s = i.getAttribute("position"),
      o = new Float32Array(s.count * 3);
    i.setAttribute("color", new Dt(o, 3)),
      this.add(new kn(i, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      OT.copy(this.light.color), UT.copy(this.light.groundColor);
      for (let r = 0, i = t.count; r < i; r++) {
        const s = r < i / 2 ? OT : UT;
        t.setXYZ(r, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt($8.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class tV extends cs {
  constructor(e = 10, t = 10, r = 4473924, i = 8947848) {
    (r = new Be(r)), (i = new Be(i));
    const s = t / 2,
      o = e / t,
      a = e / 2,
      l = [],
      u = [];
    for (let p = 0, m = 0, _ = -a; p <= t; p++, _ += o) {
      l.push(-a, 0, _, a, 0, _), l.push(_, 0, -a, _, 0, a);
      const y = p === s ? r : i;
      y.toArray(u, m),
        (m += 3),
        y.toArray(u, m),
        (m += 3),
        y.toArray(u, m),
        (m += 3),
        y.toArray(u, m),
        (m += 3);
    }
    const h = new dt();
    h.setAttribute("position", new Xe(l, 3)),
      h.setAttribute("color", new Xe(u, 3));
    const d = new yr({ vertexColors: !0, toneMapped: !1 });
    super(h, d), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class nV extends cs {
  constructor(e = 10, t = 16, r = 8, i = 64, s = 4473924, o = 8947848) {
    (s = new Be(s)), (o = new Be(o));
    const a = [],
      l = [];
    if (t > 1)
      for (let d = 0; d < t; d++) {
        const p = (d / t) * (Math.PI * 2),
          m = Math.sin(p) * e,
          _ = Math.cos(p) * e;
        a.push(0, 0, 0), a.push(m, 0, _);
        const y = d & 1 ? s : o;
        l.push(y.r, y.g, y.b), l.push(y.r, y.g, y.b);
      }
    for (let d = 0; d < r; d++) {
      const p = d & 1 ? s : o,
        m = e - (e / r) * d;
      for (let _ = 0; _ < i; _++) {
        let y = (_ / i) * (Math.PI * 2),
          x = Math.sin(y) * m,
          g = Math.cos(y) * m;
        a.push(x, 0, g),
          l.push(p.r, p.g, p.b),
          (y = ((_ + 1) / i) * (Math.PI * 2)),
          (x = Math.sin(y) * m),
          (g = Math.cos(y) * m),
          a.push(x, 0, g),
          l.push(p.r, p.g, p.b);
      }
    }
    const u = new dt();
    u.setAttribute("position", new Xe(a, 3)),
      u.setAttribute("color", new Xe(l, 3));
    const h = new yr({ vertexColors: !0, toneMapped: !1 });
    super(u, h), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const kT = new U(),
  vm = new U(),
  zT = new U();
class rV extends bt {
  constructor(e, t, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1);
    let i = new dt();
    i.setAttribute(
      "position",
      new Xe([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
    );
    const s = new yr({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new vo(i, s)),
      this.add(this.lightPlane),
      (i = new dt()),
      i.setAttribute("position", new Xe([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new vo(i, s)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      kT.setFromMatrixPosition(this.light.matrixWorld),
      vm.setFromMatrixPosition(this.light.target.matrixWorld),
      zT.subVectors(vm, kT),
      this.lightPlane.lookAt(vm),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(vm),
      (this.targetLine.scale.z = zT.length());
  }
}
const ym = new U(),
  dn = new ld();
class iV extends cs {
  constructor(e) {
    const t = new dt(),
      r = new yr({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      i = [],
      s = [],
      o = {};
    a("n1", "n2"),
      a("n2", "n4"),
      a("n4", "n3"),
      a("n3", "n1"),
      a("f1", "f2"),
      a("f2", "f4"),
      a("f4", "f3"),
      a("f3", "f1"),
      a("n1", "f1"),
      a("n2", "f2"),
      a("n3", "f3"),
      a("n4", "f4"),
      a("p", "n1"),
      a("p", "n2"),
      a("p", "n3"),
      a("p", "n4"),
      a("u1", "u2"),
      a("u2", "u3"),
      a("u3", "u1"),
      a("c", "t"),
      a("p", "c"),
      a("cn1", "cn2"),
      a("cn3", "cn4"),
      a("cf1", "cf2"),
      a("cf3", "cf4");
    function a(_, y) {
      l(_), l(y);
    }
    function l(_) {
      i.push(0, 0, 0),
        s.push(0, 0, 0),
        o[_] === void 0 && (o[_] = []),
        o[_].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new Xe(i, 3)),
      t.setAttribute("color", new Xe(s, 3)),
      super(t, r),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = o),
      this.update();
    const u = new Be(16755200),
      h = new Be(16711680),
      d = new Be(43775),
      p = new Be(16777215),
      m = new Be(3355443);
    this.setColors(u, h, d, p, m);
  }
  setColors(e, t, r, i, s) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b),
      a.setXYZ(1, e.r, e.g, e.b),
      a.setXYZ(2, e.r, e.g, e.b),
      a.setXYZ(3, e.r, e.g, e.b),
      a.setXYZ(4, e.r, e.g, e.b),
      a.setXYZ(5, e.r, e.g, e.b),
      a.setXYZ(6, e.r, e.g, e.b),
      a.setXYZ(7, e.r, e.g, e.b),
      a.setXYZ(8, e.r, e.g, e.b),
      a.setXYZ(9, e.r, e.g, e.b),
      a.setXYZ(10, e.r, e.g, e.b),
      a.setXYZ(11, e.r, e.g, e.b),
      a.setXYZ(12, e.r, e.g, e.b),
      a.setXYZ(13, e.r, e.g, e.b),
      a.setXYZ(14, e.r, e.g, e.b),
      a.setXYZ(15, e.r, e.g, e.b),
      a.setXYZ(16, e.r, e.g, e.b),
      a.setXYZ(17, e.r, e.g, e.b),
      a.setXYZ(18, e.r, e.g, e.b),
      a.setXYZ(19, e.r, e.g, e.b),
      a.setXYZ(20, e.r, e.g, e.b),
      a.setXYZ(21, e.r, e.g, e.b),
      a.setXYZ(22, e.r, e.g, e.b),
      a.setXYZ(23, e.r, e.g, e.b),
      a.setXYZ(24, t.r, t.g, t.b),
      a.setXYZ(25, t.r, t.g, t.b),
      a.setXYZ(26, t.r, t.g, t.b),
      a.setXYZ(27, t.r, t.g, t.b),
      a.setXYZ(28, t.r, t.g, t.b),
      a.setXYZ(29, t.r, t.g, t.b),
      a.setXYZ(30, t.r, t.g, t.b),
      a.setXYZ(31, t.r, t.g, t.b),
      a.setXYZ(32, r.r, r.g, r.b),
      a.setXYZ(33, r.r, r.g, r.b),
      a.setXYZ(34, r.r, r.g, r.b),
      a.setXYZ(35, r.r, r.g, r.b),
      a.setXYZ(36, r.r, r.g, r.b),
      a.setXYZ(37, r.r, r.g, r.b),
      a.setXYZ(38, i.r, i.g, i.b),
      a.setXYZ(39, i.r, i.g, i.b),
      a.setXYZ(40, s.r, s.g, s.b),
      a.setXYZ(41, s.r, s.g, s.b),
      a.setXYZ(42, s.r, s.g, s.b),
      a.setXYZ(43, s.r, s.g, s.b),
      a.setXYZ(44, s.r, s.g, s.b),
      a.setXYZ(45, s.r, s.g, s.b),
      a.setXYZ(46, s.r, s.g, s.b),
      a.setXYZ(47, s.r, s.g, s.b),
      a.setXYZ(48, s.r, s.g, s.b),
      a.setXYZ(49, s.r, s.g, s.b),
      (a.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      r = 1,
      i = 1;
    dn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      xn("c", t, e, dn, 0, 0, -1),
      xn("t", t, e, dn, 0, 0, 1),
      xn("n1", t, e, dn, -r, -i, -1),
      xn("n2", t, e, dn, r, -i, -1),
      xn("n3", t, e, dn, -r, i, -1),
      xn("n4", t, e, dn, r, i, -1),
      xn("f1", t, e, dn, -r, -i, 1),
      xn("f2", t, e, dn, r, -i, 1),
      xn("f3", t, e, dn, -r, i, 1),
      xn("f4", t, e, dn, r, i, 1),
      xn("u1", t, e, dn, r * 0.7, i * 1.1, -1),
      xn("u2", t, e, dn, -r * 0.7, i * 1.1, -1),
      xn("u3", t, e, dn, 0, i * 2, -1),
      xn("cf1", t, e, dn, -r, 0, 1),
      xn("cf2", t, e, dn, r, 0, 1),
      xn("cf3", t, e, dn, 0, -i, 1),
      xn("cf4", t, e, dn, 0, i, 1),
      xn("cn1", t, e, dn, -r, 0, -1),
      xn("cn2", t, e, dn, r, 0, -1),
      xn("cn3", t, e, dn, 0, -i, -1),
      xn("cn4", t, e, dn, 0, i, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function xn(n, e, t, r, i, s, o) {
  ym.set(i, s, o).unproject(r);
  const a = e[n];
  if (a !== void 0) {
    const l = t.getAttribute("position");
    for (let u = 0, h = a.length; u < h; u++) l.setXYZ(a[u], ym.x, ym.y, ym.z);
  }
}
const xm = new us();
class sV extends cs {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = new Float32Array(8 * 3),
      s = new dt();
    s.setIndex(new Dt(r, 1)),
      s.setAttribute("position", new Dt(i, 3)),
      super(s, new yr({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && xm.setFromObject(this.object),
      xm.isEmpty())
    )
      return;
    const t = xm.min,
      r = xm.max,
      i = this.geometry.attributes.position,
      s = i.array;
    (s[0] = r.x),
      (s[1] = r.y),
      (s[2] = r.z),
      (s[3] = t.x),
      (s[4] = r.y),
      (s[5] = r.z),
      (s[6] = t.x),
      (s[7] = t.y),
      (s[8] = r.z),
      (s[9] = r.x),
      (s[10] = t.y),
      (s[11] = r.z),
      (s[12] = r.x),
      (s[13] = r.y),
      (s[14] = t.z),
      (s[15] = t.x),
      (s[16] = r.y),
      (s[17] = t.z),
      (s[18] = t.x),
      (s[19] = t.y),
      (s[20] = t.z),
      (s[21] = r.x),
      (s[22] = t.y),
      (s[23] = t.z),
      (i.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class oV extends cs {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new dt();
    s.setIndex(new Dt(r, 1)),
      s.setAttribute("position", new Xe(i, 3)),
      super(s, new yr({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class aV extends vo {
  constructor(e, t = 1, r = 16776960) {
    const i = r,
      s = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      o = new dt();
    o.setAttribute("position", new Xe(s, 3)),
      o.computeBoundingSphere(),
      super(o, new yr({ color: i, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t);
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      l = new dt();
    l.setAttribute("position", new Xe(a, 3)),
      l.computeBoundingSphere(),
      this.add(
        new kn(
          l,
          new kr({
            color: i,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const HT = new U();
let Sm, hy;
class lV extends bt {
  constructor(
    e = new U(0, 0, 1),
    t = new U(0, 0, 0),
    r = 1,
    i = 16776960,
    s = r * 0.2,
    o = s * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      Sm === void 0 &&
        ((Sm = new dt()),
        Sm.setAttribute("position", new Xe([0, 0, 0, 0, 1, 0], 3)),
        (hy = new jc(0, 0.5, 1, 5, 1)),
        hy.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new vo(Sm, new yr({ color: i, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new kn(hy, new kr({ color: i, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(r, s, o);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      HT.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(HT, t);
    }
  }
  setLength(e, t = e * 0.2, r = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(r, t, r),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class uV extends cs {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      r = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      i = new dt();
    i.setAttribute("position", new Xe(t, 3)),
      i.setAttribute("color", new Xe(r, 3));
    const s = new yr({ vertexColors: !0, toneMapped: !1 });
    super(i, s), (this.type = "AxesHelper");
  }
  setColors(e, t, r) {
    const i = new Be(),
      s = this.geometry.attributes.color.array;
    return (
      i.set(e),
      i.toArray(s, 0),
      i.toArray(s, 3),
      i.set(t),
      i.toArray(s, 6),
      i.toArray(s, 9),
      i.set(r),
      i.toArray(s, 12),
      i.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class cV {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new Be()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new Oh()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    return this.currentPath.quadraticCurveTo(e, t, r, i), this;
  }
  bezierCurveTo(e, t, r, i, s, o) {
    return this.currentPath.bezierCurveTo(e, t, r, i, s, o), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(g) {
      const S = [];
      for (let A = 0, E = g.length; A < E; A++) {
        const C = g[A],
          R = new Al();
        (R.curves = C.curves), S.push(R);
      }
      return S;
    }
    function r(g, S) {
      const A = S.length;
      let E = !1;
      for (let C = A - 1, R = 0; R < A; C = R++) {
        let P = S[C],
          L = S[R],
          T = L.x - P.x,
          B = L.y - P.y;
        if (Math.abs(B) > Number.EPSILON) {
          if (
            (B < 0 && ((P = S[R]), (T = -T), (L = S[C]), (B = -B)),
            g.y < P.y || g.y > L.y)
          )
            continue;
          if (g.y === P.y) {
            if (g.x === P.x) return !0;
          } else {
            const D = B * (g.x - P.x) - T * (g.y - P.y);
            if (D === 0) return !0;
            if (D < 0) continue;
            E = !E;
          }
        } else {
          if (g.y !== P.y) continue;
          if ((L.x <= g.x && g.x <= P.x) || (P.x <= g.x && g.x <= L.x))
            return !0;
        }
      }
      return E;
    }
    const i = Ls.isClockWise,
      s = this.subPaths;
    if (s.length === 0) return [];
    let o, a, l;
    const u = [];
    if (s.length === 1)
      return (a = s[0]), (l = new Al()), (l.curves = a.curves), u.push(l), u;
    let h = !i(s[0].getPoints());
    h = e ? !h : h;
    const d = [],
      p = [];
    let m = [],
      _ = 0,
      y;
    (p[_] = void 0), (m[_] = []);
    for (let g = 0, S = s.length; g < S; g++)
      (a = s[g]),
        (y = a.getPoints()),
        (o = i(y)),
        (o = e ? !o : o),
        o
          ? (!h && p[_] && _++,
            (p[_] = { s: new Al(), p: y }),
            (p[_].s.curves = a.curves),
            h && _++,
            (m[_] = []))
          : m[_].push({ h: a, p: y[0] });
    if (!p[0]) return t(s);
    if (p.length > 1) {
      let g = !1,
        S = 0;
      for (let A = 0, E = p.length; A < E; A++) d[A] = [];
      for (let A = 0, E = p.length; A < E; A++) {
        const C = m[A];
        for (let R = 0; R < C.length; R++) {
          const P = C[R];
          let L = !0;
          for (let T = 0; T < p.length; T++)
            r(P.p, p[T].p) &&
              (A !== T && S++, L ? ((L = !1), d[T].push(P)) : (g = !0));
          L && d[A].push(P);
        }
      }
      S > 0 && g === !1 && (m = d);
    }
    let x;
    for (let g = 0, S = p.length; g < S; g++) {
      (l = p[g].s), u.push(l), (x = m[g]);
      for (let A = 0, E = x.length; A < E; A++) l.holes.push(x[A].h);
    }
    return u;
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: sd } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = sd));
const fV = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: QA,
      AddEquation: ol,
      AddOperation: ZB,
      AdditiveAnimationBlendMode: r1,
      AdditiveBlending: Hx,
      AlphaFormat: s2,
      AlwaysCompare: T2,
      AlwaysDepth: jB,
      AlwaysStencilFunc: y2,
      AmbientLight: yL,
      AmbientLightProbe: M8,
      AnimationAction: TL,
      AnimationClip: Rc,
      AnimationLoader: h8,
      AnimationMixer: H8,
      AnimationObjectGroup: k8,
      AnimationUtils: l8,
      ArcCurve: K2,
      ArrayCamera: G2,
      ArrowHelper: lV,
      Audio: wL,
      AudioAnalyser: R8,
      AudioContext: O1,
      AudioListener: C8,
      AudioLoader: S8,
      AxesHelper: uV,
      BackSide: Tr,
      BasicDepthPacking: g2,
      BasicShadowMap: BB,
      Bone: T0,
      BooleanKeyframeTrack: Hl,
      Box2: K8,
      Box3: us,
      Box3Helper: oV,
      BoxGeometry: zl,
      BoxHelper: sV,
      BufferAttribute: Dt,
      BufferGeometry: dt,
      BufferGeometryLoader: ML,
      ByteType: r2,
      Cache: Fl,
      Camera: ld,
      CameraHelper: iV,
      CanvasTexture: L9,
      CapsuleGeometry: B0,
      CatmullRomCurve3: Y2,
      CineonToneMapping: t2,
      CircleGeometry: L0,
      ClampToEdgeWrapping: er,
      Clock: U1,
      Color: Be,
      ColorKeyframeTrack: B1,
      ColorManagement: wi,
      CompressedArrayTexture: B9,
      CompressedTexture: S1,
      CompressedTextureLoader: d8,
      ConeGeometry: pd,
      CubeCamera: D2,
      CubeReflectionMapping: va,
      CubeRefractionMapping: ya,
      CubeTexture: ud,
      CubeTextureLoader: p8,
      CubeUVReflectionMapping: Gc,
      CubicBezierCurve: M1,
      CubicBezierCurve3: Q2,
      CubicInterpolant: dL,
      CullFaceBack: zx,
      CullFaceFront: PB,
      CullFaceFrontBack: Rk,
      CullFaceNone: RB,
      Curve: fs,
      CurvePath: Z2,
      CustomBlending: LB,
      CustomToneMapping: n2,
      CylinderGeometry: jc,
      Cylindrical: J8,
      Data3DTexture: u1,
      DataArrayTexture: A0,
      DataTexture: ac,
      DataTextureLoader: m8,
      DataUtils: Uz,
      DecrementStencilOp: Uk,
      DecrementWrapStencilOp: zk,
      DefaultLoadingManager: gL,
      DepthFormat: ca,
      DepthStencilFormat: Ll,
      DepthTexture: V2,
      DirectionalLight: N1,
      DirectionalLightHelper: rV,
      DiscreteInterpolant: pL,
      DisplayP3ColorSpace: o1,
      DodecahedronGeometry: I0,
      DoubleSide: Li,
      DstAlphaFactor: kB,
      DstColorFactor: HB,
      DynamicCopyUsage: tz,
      DynamicDrawUsage: Yk,
      DynamicReadUsage: Zk,
      EdgesGeometry: $2,
      EllipseCurve: R0,
      EqualCompare: A2,
      EqualDepth: JB,
      EqualStencilFunc: Wk,
      EquirectangularReflectionMapping: Ph,
      EquirectangularRefractionMapping: Bh,
      Euler: ad,
      EventDispatcher: Mo,
      ExtrudeGeometry: F0,
      FileLoader: hi,
      Float16BufferAttribute: Wz,
      Float32BufferAttribute: Xe,
      Float64BufferAttribute: jz,
      FloatType: Cs,
      Fog: C0,
      FogExp2: w0,
      FramebufferTexture: P9,
      FrontSide: Fs,
      Frustum: M0,
      GLBufferAttribute: j8,
      GLSL1: rz,
      GLSL3: mS,
      GreaterCompare: E2,
      GreaterDepth: YB,
      GreaterEqualCompare: C2,
      GreaterEqualDepth: KB,
      GreaterEqualStencilFunc: Kk,
      GreaterStencilFunc: Xk,
      GridHelper: tV,
      Group: uo,
      HalfFloatType: Ac,
      HemisphereLight: vL,
      HemisphereLightHelper: eV,
      HemisphereLightProbe: A8,
      IcosahedronGeometry: N0,
      ImageBitmapLoader: EL,
      ImageLoader: Hh,
      ImageUtils: l1,
      IncrementStencilOp: Ok,
      IncrementWrapStencilOp: kk,
      InstancedBufferAttribute: Cc,
      InstancedBufferGeometry: AL,
      InstancedInterleavedBuffer: W8,
      InstancedMesh: v1,
      Int16BufferAttribute: Gz,
      Int32BufferAttribute: Vz,
      Int8BufferAttribute: kz,
      IntType: qA,
      InterleavedBuffer: fd,
      InterleavedBufferAttribute: Sa,
      Interpolant: Xc,
      InterpolateDiscrete: Mc,
      InterpolateLinear: Il,
      InterpolateSmooth: Km,
      InvertStencilOp: Hk,
      KeepStencilOp: Ym,
      KeyframeTrack: hs,
      LOD: J2,
      LatheGeometry: dd,
      Layers: Sl,
      LessCompare: S2,
      LessDepth: XB,
      LessEqualCompare: M2,
      LessEqualDepth: Rg,
      LessEqualStencilFunc: jk,
      LessStencilFunc: Vk,
      Light: Ba,
      LightProbe: V0,
      Line: vo,
      Line3: Y8,
      LineBasicMaterial: yr,
      LineCurve: P0,
      LineCurve3: q2,
      LineDashedMaterial: fL,
      LineLoop: y1,
      LineSegments: cs,
      LinearEncoding: s1,
      LinearFilter: sn,
      LinearInterpolant: P1,
      LinearMipMapLinearFilter: Dk,
      LinearMipMapNearestFilter: Ik,
      LinearMipmapLinearFilter: Ns,
      LinearMipmapNearestFilter: y0,
      LinearSRGBColorSpace: as,
      LinearToneMapping: $B,
      Loader: xr,
      LoaderUtils: Is,
      LoadingManager: L1,
      LoopOnce: h2,
      LoopPingPong: p2,
      LoopRepeat: d2,
      LuminanceAlphaFormat: a2,
      LuminanceFormat: o2,
      MOUSE: Tk,
      Material: In,
      MaterialLoader: W0,
      MathUtils: R2,
      Matrix3: _t,
      Matrix4: rt,
      MaxEquation: jx,
      Mesh: kn,
      MeshBasicMaterial: kr,
      MeshDepthMaterial: d1,
      MeshDistanceMaterial: p1,
      MeshLambertMaterial: uL,
      MeshMatcapMaterial: cL,
      MeshNormalMaterial: lL,
      MeshPhongMaterial: oL,
      MeshPhysicalMaterial: zs,
      MeshStandardMaterial: da,
      MeshToonMaterial: aL,
      MinEquation: Wx,
      MirroredRepeatWrapping: Sc,
      MixOperation: qB,
      MultiplyBlending: Vx,
      MultiplyOperation: od,
      NearestFilter: mn,
      NearestMipMapLinearFilter: Lk,
      NearestMipMapNearestFilter: Bk,
      NearestMipmapLinearFilter: sc,
      NearestMipmapNearestFilter: Lh,
      NeverCompare: x2,
      NeverDepth: WB,
      NeverStencilFunc: Gk,
      NoBlending: ho,
      NoColorSpace: ha,
      NoToneMapping: is,
      NormalAnimationBlendMode: S0,
      NormalBlending: yl,
      NotEqualCompare: w2,
      NotEqualDepth: QB,
      NotEqualStencilFunc: Jk,
      NumberKeyframeTrack: Tc,
      Object3D: bt,
      ObjectLoader: y8,
      ObjectSpaceNormalMap: v2,
      OctahedronGeometry: md,
      OneFactor: NB,
      OneMinusDstAlphaFactor: zB,
      OneMinusDstColorFactor: GB,
      OneMinusSrcAlphaFactor: YA,
      OneMinusSrcColorFactor: UB,
      OrthographicCamera: Ra,
      PCFShadowMap: _0,
      PCFSoftShadowMap: nh,
      PMREMGenerator: _S,
      Path: Oh,
      PerspectiveCamera: Mn,
      Plane: Wo,
      PlaneGeometry: cd,
      PlaneHelper: aV,
      PointLight: F1,
      PointLightHelper: Z8,
      Points: x1,
      PointsMaterial: b0,
      PolarGridHelper: nV,
      PolyhedronGeometry: Pa,
      PositionalAudio: b8,
      PropertyBinding: Tt,
      PropertyMixer: CL,
      QuadraticBezierCurve: E1,
      QuadraticBezierCurve3: w1,
      Quaternion: mr,
      QuaternionKeyframeTrack: Aa,
      QuaternionLinearInterpolant: mL,
      RED_GREEN_RGTC2_Format: dS,
      RED_RGTC1_Format: f2,
      REVISION: sd,
      RGBADepthPacking: _2,
      RGBAFormat: Nr,
      RGBAIntegerFormat: n1,
      RGBA_ASTC_10x10_Format: uS,
      RGBA_ASTC_10x5_Format: oS,
      RGBA_ASTC_10x6_Format: aS,
      RGBA_ASTC_10x8_Format: lS,
      RGBA_ASTC_12x10_Format: cS,
      RGBA_ASTC_12x12_Format: fS,
      RGBA_ASTC_4x4_Format: Zx,
      RGBA_ASTC_5x4_Format: $x,
      RGBA_ASTC_5x5_Format: eS,
      RGBA_ASTC_6x5_Format: tS,
      RGBA_ASTC_6x6_Format: nS,
      RGBA_ASTC_8x5_Format: rS,
      RGBA_ASTC_8x6_Format: iS,
      RGBA_ASTC_8x8_Format: sS,
      RGBA_BPTC_Format: Jm,
      RGBA_ETC2_EAC_Format: qx,
      RGBA_PVRTC_2BPPV1_Format: Yx,
      RGBA_PVRTC_4BPPV1_Format: Kx,
      RGBA_S3TC_DXT1_Format: Wm,
      RGBA_S3TC_DXT3_Format: jm,
      RGBA_S3TC_DXT5_Format: Xm,
      RGB_ETC1_Format: c2,
      RGB_ETC2_Format: Qx,
      RGB_PVRTC_2BPPV1_Format: Jx,
      RGB_PVRTC_4BPPV1_Format: Xx,
      RGB_S3TC_DXT1_Format: Vm,
      RGFormat: u2,
      RGIntegerFormat: t1,
      RawShaderMaterial: sL,
      Ray: Vc,
      Raycaster: bL,
      RectAreaLight: xL,
      RedFormat: l2,
      RedIntegerFormat: e1,
      ReinhardToneMapping: e2,
      RepeatWrapping: xa,
      ReplaceStencilOp: Nk,
      ReverseSubtractEquation: DB,
      RingGeometry: O0,
      SIGNED_RED_GREEN_RGTC2_Format: pS,
      SIGNED_RED_RGTC1_Format: hS,
      SRGBColorSpace: ht,
      Scene: Ig,
      ShaderChunk: pt,
      ShaderLib: ts,
      ShaderMaterial: Os,
      ShadowMaterial: iL,
      Shape: Al,
      ShapeGeometry: U0,
      ShapePath: cV,
      ShapeUtils: Ls,
      ShortType: i2,
      Skeleton: hd,
      SkeletonHelper: q8,
      SkinnedMesh: _1,
      Source: dl,
      Sphere: Gi,
      SphereGeometry: gd,
      Spherical: X8,
      SphericalHarmonics3: SL,
      SplineCurve: C1,
      SpotLight: D1,
      SpotLightHelper: Q8,
      Sprite: X2,
      SpriteMaterial: g1,
      SrcAlphaFactor: KA,
      SrcAlphaSaturateFactor: VB,
      SrcColorFactor: OB,
      StaticCopyUsage: ez,
      StaticDrawUsage: Dh,
      StaticReadUsage: qk,
      StereoCamera: E8,
      StreamCopyUsage: nz,
      StreamDrawUsage: Qk,
      StreamReadUsage: $k,
      StringKeyframeTrack: Gl,
      SubtractEquation: IB,
      SubtractiveBlending: Gx,
      TOUCH: bk,
      TangentSpaceNormalMap: ba,
      TetrahedronGeometry: k0,
      Texture: en,
      TextureLoader: _L,
      TorusGeometry: z0,
      TorusKnotGeometry: H0,
      Triangle: Fr,
      TriangleFanDrawMode: Pg,
      TriangleStripDrawMode: i1,
      TrianglesDrawMode: m2,
      TubeGeometry: G0,
      TwoPassDoubleSide: Pk,
      UVMapping: v0,
      Uint16BufferAttribute: c1,
      Uint32BufferAttribute: f1,
      Uint8BufferAttribute: zz,
      Uint8ClampedBufferAttribute: Hz,
      Uniform: H1,
      UniformsGroup: V8,
      UniformsLib: be,
      UniformsUtils: I2,
      UnsignedByteType: Bs,
      UnsignedInt248Type: ua,
      UnsignedIntType: lo,
      UnsignedShort4444Type: ZA,
      UnsignedShort5551Type: $A,
      UnsignedShortType: x0,
      VSMShadowMap: Zi,
      Vector2: ge,
      Vector3: U,
      Vector4: Nt,
      VectorKeyframeTrack: bc,
      VideoTexture: R9,
      WebGL1Renderer: W2,
      WebGL3DRenderTarget: Tz,
      WebGLArrayRenderTarget: Cz,
      WebGLCoordinateSystem: Ts,
      WebGLCubeRenderTarget: F2,
      WebGLMultipleRenderTargets: bz,
      WebGLRenderTarget: ls,
      WebGLRenderer: m1,
      WebGLUtils: H2,
      WebGPUCoordinateSystem: Fh,
      WireframeGeometry: rL,
      WrapAroundEnding: Ih,
      ZeroCurvatureEnding: fl,
      ZeroFactor: FB,
      ZeroSlopeEnding: hl,
      ZeroStencilOp: Fk,
      _SRGBAFormat: Bg,
      sRGBEncoding: fa,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var PL = { exports: {} },
  Vl = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Vl.ConcurrentRoot = 1;
Vl.ContinuousEventPriority = 4;
Vl.DefaultEventPriority = 16;
Vl.DiscreteEventPriority = 1;
Vl.IdleEventPriority = 536870912;
Vl.LegacyRoot = 0;
PL.exports = Vl;
var Qu = PL.exports;
function hV(n) {
  let e;
  const t = new Set(),
    r = (u, h) => {
      const d = typeof u == "function" ? u(e) : u;
      if (d !== e) {
        const p = e;
        (e = h ? d : Object.assign({}, e, d)), t.forEach((m) => m(e, p));
      }
    },
    i = () => e,
    s = (u, h = i, d = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let p = h(e);
      function m() {
        const _ = h(e);
        if (!d(p, _)) {
          const y = p;
          u((p = _), y);
        }
      }
      return t.add(m), () => t.delete(m);
    },
    l = {
      setState: r,
      getState: i,
      subscribe: (u, h, d) =>
        h || d ? s(u, h, d) : (t.add(u), () => t.delete(u)),
      destroy: () => t.clear(),
    };
  return (e = n(r, i, l)), l;
}
const dV =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  GT = dV ? te.useEffect : te.useLayoutEffect;
function pV(n) {
  const e = typeof n == "function" ? hV(n) : n,
    t = (r = e.getState, i = Object.is) => {
      const [, s] = te.useReducer((x) => x + 1, 0),
        o = e.getState(),
        a = te.useRef(o),
        l = te.useRef(r),
        u = te.useRef(i),
        h = te.useRef(!1),
        d = te.useRef();
      d.current === void 0 && (d.current = r(o));
      let p,
        m = !1;
      (a.current !== o || l.current !== r || u.current !== i || h.current) &&
        ((p = r(o)), (m = !i(d.current, p))),
        GT(() => {
          m && (d.current = p),
            (a.current = o),
            (l.current = r),
            (u.current = i),
            (h.current = !1);
        });
      const _ = te.useRef(o);
      GT(() => {
        const x = () => {
            try {
              const S = e.getState(),
                A = l.current(S);
              u.current(d.current, A) ||
                ((a.current = S), (d.current = A), s());
            } catch {
              (h.current = !0), s();
            }
          },
          g = e.subscribe(x);
        return e.getState() !== _.current && x(), g;
      }, []);
      const y = m ? p : d.current;
      return te.useDebugValue(y), y;
    };
  return (
    Object.assign(t, e),
    (t[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const r = [t, e];
      return {
        next() {
          const i = r.length <= 0;
          return { value: r.shift(), done: i };
        },
      };
    }),
    t
  );
}
var BL = { exports: {} },
  dy = { exports: {} },
  py = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var VT;
function mV() {
  return (
    VT ||
      ((VT = 1),
      (function (n) {
        function e(N, W) {
          var G = N.length;
          N.push(W);
          e: for (; 0 < G; ) {
            var X = (G - 1) >>> 1,
              Y = N[X];
            if (0 < i(Y, W)) (N[X] = W), (N[G] = Y), (G = X);
            else break e;
          }
        }
        function t(N) {
          return N.length === 0 ? null : N[0];
        }
        function r(N) {
          if (N.length === 0) return null;
          var W = N[0],
            G = N.pop();
          if (G !== W) {
            N[0] = G;
            e: for (var X = 0, Y = N.length, de = Y >>> 1; X < de; ) {
              var ae = 2 * (X + 1) - 1,
                ye = N[ae],
                we = ae + 1,
                Ne = N[we];
              if (0 > i(ye, G))
                we < Y && 0 > i(Ne, ye)
                  ? ((N[X] = Ne), (N[we] = G), (X = we))
                  : ((N[X] = ye), (N[ae] = G), (X = ae));
              else if (we < Y && 0 > i(Ne, G))
                (N[X] = Ne), (N[we] = G), (X = we);
              else break e;
            }
          }
          return W;
        }
        function i(N, W) {
          var G = N.sortIndex - W.sortIndex;
          return G !== 0 ? G : N.id - W.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var s = performance;
          n.unstable_now = function () {
            return s.now();
          };
        } else {
          var o = Date,
            a = o.now();
          n.unstable_now = function () {
            return o.now() - a;
          };
        }
        var l = [],
          u = [],
          h = 1,
          d = null,
          p = 3,
          m = !1,
          _ = !1,
          y = !1,
          x = typeof setTimeout == "function" ? setTimeout : null,
          g = typeof clearTimeout == "function" ? clearTimeout : null,
          S = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function A(N) {
          for (var W = t(u); W !== null; ) {
            if (W.callback === null) r(u);
            else if (W.startTime <= N)
              r(u), (W.sortIndex = W.expirationTime), e(l, W);
            else break;
            W = t(u);
          }
        }
        function E(N) {
          if (((y = !1), A(N), !_))
            if (t(l) !== null) (_ = !0), Z(C);
            else {
              var W = t(u);
              W !== null && Q(E, W.startTime - N);
            }
        }
        function C(N, W) {
          (_ = !1), y && ((y = !1), g(L), (L = -1)), (m = !0);
          var G = p;
          try {
            for (
              A(W), d = t(l);
              d !== null && (!(d.expirationTime > W) || (N && !D()));

            ) {
              var X = d.callback;
              if (typeof X == "function") {
                (d.callback = null), (p = d.priorityLevel);
                var Y = X(d.expirationTime <= W);
                (W = n.unstable_now()),
                  typeof Y == "function"
                    ? (d.callback = Y)
                    : d === t(l) && r(l),
                  A(W);
              } else r(l);
              d = t(l);
            }
            if (d !== null) var de = !0;
            else {
              var ae = t(u);
              ae !== null && Q(E, ae.startTime - W), (de = !1);
            }
            return de;
          } finally {
            (d = null), (p = G), (m = !1);
          }
        }
        var R = !1,
          P = null,
          L = -1,
          T = 5,
          B = -1;
        function D() {
          return !(n.unstable_now() - B < T);
        }
        function I() {
          if (P !== null) {
            var N = n.unstable_now();
            B = N;
            var W = !0;
            try {
              W = P(!0, N);
            } finally {
              W ? F() : ((R = !1), (P = null));
            }
          } else R = !1;
        }
        var F;
        if (typeof S == "function")
          F = function () {
            S(I);
          };
        else if (typeof MessageChannel < "u") {
          var k = new MessageChannel(),
            j = k.port2;
          (k.port1.onmessage = I),
            (F = function () {
              j.postMessage(null);
            });
        } else
          F = function () {
            x(I, 0);
          };
        function Z(N) {
          (P = N), R || ((R = !0), F());
        }
        function Q(N, W) {
          L = x(function () {
            N(n.unstable_now());
          }, W);
        }
        (n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (N) {
            N.callback = null;
          }),
          (n.unstable_continueExecution = function () {
            _ || m || ((_ = !0), Z(C));
          }),
          (n.unstable_forceFrameRate = function (N) {
            0 > N || 125 < N
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (T = 0 < N ? Math.floor(1e3 / N) : 5);
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return p;
          }),
          (n.unstable_getFirstCallbackNode = function () {
            return t(l);
          }),
          (n.unstable_next = function (N) {
            switch (p) {
              case 1:
              case 2:
              case 3:
                var W = 3;
                break;
              default:
                W = p;
            }
            var G = p;
            p = W;
            try {
              return N();
            } finally {
              p = G;
            }
          }),
          (n.unstable_pauseExecution = function () {}),
          (n.unstable_requestPaint = function () {}),
          (n.unstable_runWithPriority = function (N, W) {
            switch (N) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                N = 3;
            }
            var G = p;
            p = N;
            try {
              return W();
            } finally {
              p = G;
            }
          }),
          (n.unstable_scheduleCallback = function (N, W, G) {
            var X = n.unstable_now();
            switch (
              (typeof G == "object" && G !== null
                ? ((G = G.delay),
                  (G = typeof G == "number" && 0 < G ? X + G : X))
                : (G = X),
              N)
            ) {
              case 1:
                var Y = -1;
                break;
              case 2:
                Y = 250;
                break;
              case 5:
                Y = 1073741823;
                break;
              case 4:
                Y = 1e4;
                break;
              default:
                Y = 5e3;
            }
            return (
              (Y = G + Y),
              (N = {
                id: h++,
                callback: W,
                priorityLevel: N,
                startTime: G,
                expirationTime: Y,
                sortIndex: -1,
              }),
              G > X
                ? ((N.sortIndex = G),
                  e(u, N),
                  t(l) === null &&
                    N === t(u) &&
                    (y ? (g(L), (L = -1)) : (y = !0), Q(E, G - X)))
                : ((N.sortIndex = Y), e(l, N), _ || m || ((_ = !0), Z(C))),
              N
            );
          }),
          (n.unstable_shouldYield = D),
          (n.unstable_wrapCallback = function (N) {
            var W = p;
            return function () {
              var G = p;
              p = W;
              try {
                return N.apply(this, arguments);
              } finally {
                p = G;
              }
            };
          });
      })(py)),
    py
  );
}
var WT;
function gV() {
  return WT || ((WT = 1), (dy.exports = mV())), dy.exports;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var _V = function (e) {
  var t = {},
    r = te,
    i = gV(),
    s = Object.assign;
  function o(c) {
    for (
      var f = "https://reactjs.org/docs/error-decoder.html?invariant=" + c,
        v = 1;
      v < arguments.length;
      v++
    )
      f += "&args[]=" + encodeURIComponent(arguments[v]);
    return (
      "Minified React error #" +
      c +
      "; visit " +
      f +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    l = Symbol.for("react.element"),
    u = Symbol.for("react.portal"),
    h = Symbol.for("react.fragment"),
    d = Symbol.for("react.strict_mode"),
    p = Symbol.for("react.profiler"),
    m = Symbol.for("react.provider"),
    _ = Symbol.for("react.context"),
    y = Symbol.for("react.forward_ref"),
    x = Symbol.for("react.suspense"),
    g = Symbol.for("react.suspense_list"),
    S = Symbol.for("react.memo"),
    A = Symbol.for("react.lazy"),
    E = Symbol.for("react.offscreen"),
    C = Symbol.iterator;
  function R(c) {
    return c === null || typeof c != "object"
      ? null
      : ((c = (C && c[C]) || c["@@iterator"]),
        typeof c == "function" ? c : null);
  }
  function P(c) {
    if (c == null) return null;
    if (typeof c == "function") return c.displayName || c.name || null;
    if (typeof c == "string") return c;
    switch (c) {
      case h:
        return "Fragment";
      case u:
        return "Portal";
      case p:
        return "Profiler";
      case d:
        return "StrictMode";
      case x:
        return "Suspense";
      case g:
        return "SuspenseList";
    }
    if (typeof c == "object")
      switch (c.$$typeof) {
        case _:
          return (c.displayName || "Context") + ".Consumer";
        case m:
          return (c._context.displayName || "Context") + ".Provider";
        case y:
          var f = c.render;
          return (
            (c = c.displayName),
            c ||
              ((c = f.displayName || f.name || ""),
              (c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef")),
            c
          );
        case S:
          return (
            (f = c.displayName || null), f !== null ? f : P(c.type) || "Memo"
          );
        case A:
          (f = c._payload), (c = c._init);
          try {
            return P(c(f));
          } catch {}
      }
    return null;
  }
  function L(c) {
    var f = c.type;
    switch (c.tag) {
      case 24:
        return "Cache";
      case 9:
        return (f.displayName || "Context") + ".Consumer";
      case 10:
        return (f._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (c = f.render),
          (c = c.displayName || c.name || ""),
          f.displayName || (c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return f;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return P(f);
      case 8:
        return f === d ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof f == "function") return f.displayName || f.name || null;
        if (typeof f == "string") return f;
    }
    return null;
  }
  function T(c) {
    var f = c,
      v = c;
    if (c.alternate) for (; f.return; ) f = f.return;
    else {
      c = f;
      do (f = c), f.flags & 4098 && (v = f.return), (c = f.return);
      while (c);
    }
    return f.tag === 3 ? v : null;
  }
  function B(c) {
    if (T(c) !== c) throw Error(o(188));
  }
  function D(c) {
    var f = c.alternate;
    if (!f) {
      if (((f = T(c)), f === null)) throw Error(o(188));
      return f !== c ? null : c;
    }
    for (var v = c, M = f; ; ) {
      var w = v.return;
      if (w === null) break;
      var b = w.alternate;
      if (b === null) {
        if (((M = w.return), M !== null)) {
          v = M;
          continue;
        }
        break;
      }
      if (w.child === b.child) {
        for (b = w.child; b; ) {
          if (b === v) return B(w), c;
          if (b === M) return B(w), f;
          b = b.sibling;
        }
        throw Error(o(188));
      }
      if (v.return !== M.return) (v = w), (M = b);
      else {
        for (var H = !1, $ = w.child; $; ) {
          if ($ === v) {
            (H = !0), (v = w), (M = b);
            break;
          }
          if ($ === M) {
            (H = !0), (M = w), (v = b);
            break;
          }
          $ = $.sibling;
        }
        if (!H) {
          for ($ = b.child; $; ) {
            if ($ === v) {
              (H = !0), (v = b), (M = w);
              break;
            }
            if ($ === M) {
              (H = !0), (M = b), (v = w);
              break;
            }
            $ = $.sibling;
          }
          if (!H) throw Error(o(189));
        }
      }
      if (v.alternate !== M) throw Error(o(190));
    }
    if (v.tag !== 3) throw Error(o(188));
    return v.stateNode.current === v ? c : f;
  }
  function I(c) {
    return (c = D(c)), c !== null ? F(c) : null;
  }
  function F(c) {
    if (c.tag === 5 || c.tag === 6) return c;
    for (c = c.child; c !== null; ) {
      var f = F(c);
      if (f !== null) return f;
      c = c.sibling;
    }
    return null;
  }
  function k(c) {
    if (c.tag === 5 || c.tag === 6) return c;
    for (c = c.child; c !== null; ) {
      if (c.tag !== 4) {
        var f = k(c);
        if (f !== null) return f;
      }
      c = c.sibling;
    }
    return null;
  }
  var j = Array.isArray,
    Z = e.getPublicInstance,
    Q = e.getRootHostContext,
    N = e.getChildHostContext,
    W = e.prepareForCommit,
    G = e.resetAfterCommit,
    X = e.createInstance,
    Y = e.appendInitialChild,
    de = e.finalizeInitialChildren,
    ae = e.prepareUpdate,
    ye = e.shouldSetTextContent,
    we = e.createTextInstance,
    Ne = e.scheduleTimeout,
    je = e.cancelTimeout,
    At = e.noTimeout,
    lt = e.isPrimaryRenderer,
    Ce = e.supportsMutation,
    K = e.supportsPersistence,
    _e = e.supportsHydration,
    pe = e.getInstanceFromNode,
    Ae = e.preparePortalMount,
    ve = e.getCurrentEventPriority,
    Ge = e.detachDeletedInstance,
    Oe = e.supportsMicrotasks,
    Ue = e.scheduleMicrotask,
    Qe = e.supportsTestSelectors,
    yt = e.findFiberRoot,
    Vt = e.getBoundingRect,
    V = e.getTextContent,
    O = e.isHiddenSubtree,
    ue = e.matchAccessibilityRole,
    Me = e.setFocusIfFocusable,
    xe = e.setupIntersectionObserver,
    Re = e.appendChild,
    Je = e.appendChildToContainer,
    Pe = e.commitTextUpdate,
    he = e.commitMount,
    qe = e.commitUpdate,
    Ze = e.insertBefore,
    tt = e.insertInContainerBefore,
    Ve = e.removeChild,
    We = e.removeChildFromContainer,
    mt = e.resetTextContent,
    Ut = e.hideInstance,
    q = e.hideTextInstance,
    Le = e.unhideInstance,
    oe = e.unhideTextInstance,
    Te = e.clearContainer,
    De = e.cloneInstance,
    Et = e.createContainerChildSet,
    Wt = e.appendChildToContainerChildSet,
    En = e.finalizeContainerChildren,
    Jr = e.replaceContainerChildren,
    Jt = e.cloneHiddenInstance,
    Kr = e.cloneHiddenTextInstance,
    Qn = e.canHydrateInstance,
    Sd = e.canHydrateTextInstance,
    Ad = e.canHydrateSuspenseInstance,
    Md = e.isSuspenseInstancePending,
    Eo = e.isSuspenseInstanceFallback,
    Ed = e.registerSuspenseInstanceRetry,
    ds = e.getNextHydratableSibling,
    wd = e.getFirstHydratableChild,
    Y0 = e.getFirstHydratableChildWithinContainer,
    Q0 = e.getFirstHydratableChildWithinSuspenseInstance,
    q0 = e.hydrateInstance,
    z = e.hydrateTextInstance,
    ie = e.hydrateSuspenseInstance,
    ce = e.getNextHydratableInstanceAfterSuspenseInstance,
    ne = e.commitHydratedContainer,
    fe = e.commitHydratedSuspenseInstance,
    ze = e.clearSuspenseBoundary,
    $e = e.clearSuspenseBoundaryFromContainer,
    nt = e.shouldDeleteUnhydratedTailInstances,
    it = e.didNotMatchHydratedContainerTextInstance,
    xt = e.didNotMatchHydratedTextInstance,
    st;
  function ot(c) {
    if (st === void 0)
      try {
        throw Error();
      } catch (v) {
        var f = v.stack.trim().match(/\n( *(at )?)/);
        st = (f && f[1]) || "";
      }
    return (
      `
` +
      st +
      c
    );
  }
  var jt = !1;
  function Kt(c, f) {
    if (!c || jt) return "";
    jt = !0;
    var v = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (f)
        if (
          ((f = function () {
            throw Error();
          }),
          Object.defineProperty(f.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(f, []);
          } catch (Ee) {
            var M = Ee;
          }
          Reflect.construct(c, [], f);
        } else {
          try {
            f.call();
          } catch (Ee) {
            M = Ee;
          }
          c.call(f.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Ee) {
          M = Ee;
        }
        c();
      }
    } catch (Ee) {
      if (Ee && M && typeof Ee.stack == "string") {
        for (
          var w = Ee.stack.split(`
`),
            b = M.stack.split(`
`),
            H = w.length - 1,
            $ = b.length - 1;
          1 <= H && 0 <= $ && w[H] !== b[$];

        )
          $--;
        for (; 1 <= H && 0 <= $; H--, $--)
          if (w[H] !== b[$]) {
            if (H !== 1 || $ !== 1)
              do
                if ((H--, $--, 0 > $ || w[H] !== b[$])) {
                  var le =
                    `
` + w[H].replace(" at new ", " at ");
                  return (
                    c.displayName &&
                      le.includes("<anonymous>") &&
                      (le = le.replace("<anonymous>", c.displayName)),
                    le
                  );
                }
              while (1 <= H && 0 <= $);
            break;
          }
      }
    } finally {
      (jt = !1), (Error.prepareStackTrace = v);
    }
    return (c = c ? c.displayName || c.name : "") ? ot(c) : "";
  }
  var Yr = Object.prototype.hasOwnProperty,
    Qr = [],
    kt = -1;
  function ut(c) {
    return { current: c };
  }
  function Ft(c) {
    0 > kt || ((c.current = Qr[kt]), (Qr[kt] = null), kt--);
  }
  function at(c, f) {
    kt++, (Qr[kt] = c.current), (c.current = f);
  }
  var rr = {},
    Dn = ut(rr),
    wn = ut(!1),
    Vi = rr;
  function cn(c, f) {
    var v = c.type.contextTypes;
    if (!v) return rr;
    var M = c.stateNode;
    if (M && M.__reactInternalMemoizedUnmaskedChildContext === f)
      return M.__reactInternalMemoizedMaskedChildContext;
    var w = {},
      b;
    for (b in v) w[b] = f[b];
    return (
      M &&
        ((c = c.stateNode),
        (c.__reactInternalMemoizedUnmaskedChildContext = f),
        (c.__reactInternalMemoizedMaskedChildContext = w)),
      w
    );
  }
  function fn(c) {
    return (c = c.childContextTypes), c != null;
  }
  function wo() {
    Ft(wn), Ft(Dn);
  }
  function ir(c, f, v) {
    if (Dn.current !== rr) throw Error(o(168));
    at(Dn, f), at(wn, v);
  }
  function jl(c, f, v) {
    var M = c.stateNode;
    if (((f = f.childContextTypes), typeof M.getChildContext != "function"))
      return v;
    M = M.getChildContext();
    for (var w in M) if (!(w in f)) throw Error(o(108, L(c) || "Unknown", w));
    return s({}, v, M);
  }
  function Xl(c) {
    return (
      (c =
        ((c = c.stateNode) && c.__reactInternalMemoizedMergedChildContext) ||
        rr),
      (Vi = Dn.current),
      at(Dn, c),
      at(wn, wn.current),
      !0
    );
  }
  function Jc(c, f, v) {
    var M = c.stateNode;
    if (!M) throw Error(o(169));
    v
      ? ((c = jl(c, f, Vi)),
        (M.__reactInternalMemoizedMergedChildContext = c),
        Ft(wn),
        Ft(Dn),
        at(Dn, c))
      : Ft(wn),
      at(wn, v);
  }
  var Wi = Math.clz32 ? Math.clz32 : cD,
    lD = Math.log,
    uD = Math.LN2;
  function cD(c) {
    return (c >>>= 0), c === 0 ? 32 : (31 - ((lD(c) / uD) | 0)) | 0;
  }
  var Cd = 64,
    Td = 4194304;
  function Kc(c) {
    switch (c & -c) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return c & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return c & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return c;
    }
  }
  function bd(c, f) {
    var v = c.pendingLanes;
    if (v === 0) return 0;
    var M = 0,
      w = c.suspendedLanes,
      b = c.pingedLanes,
      H = v & 268435455;
    if (H !== 0) {
      var $ = H & ~w;
      $ !== 0 ? (M = Kc($)) : ((b &= H), b !== 0 && (M = Kc(b)));
    } else (H = v & ~w), H !== 0 ? (M = Kc(H)) : b !== 0 && (M = Kc(b));
    if (M === 0) return 0;
    if (
      f !== 0 &&
      f !== M &&
      !(f & w) &&
      ((w = M & -M), (b = f & -f), w >= b || (w === 16 && (b & 4194240) !== 0))
    )
      return f;
    if ((M & 4 && (M |= v & 16), (f = c.entangledLanes), f !== 0))
      for (c = c.entanglements, f &= M; 0 < f; )
        (v = 31 - Wi(f)), (w = 1 << v), (M |= c[v]), (f &= ~w);
    return M;
  }
  function fD(c, f) {
    switch (c) {
      case 1:
      case 2:
      case 4:
        return f + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return f + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function hD(c, f) {
    for (
      var v = c.suspendedLanes,
        M = c.pingedLanes,
        w = c.expirationTimes,
        b = c.pendingLanes;
      0 < b;

    ) {
      var H = 31 - Wi(b),
        $ = 1 << H,
        le = w[H];
      le === -1
        ? (!($ & v) || $ & M) && (w[H] = fD($, f))
        : le <= f && (c.expiredLanes |= $),
        (b &= ~$);
    }
  }
  function Z0(c) {
    return (
      (c = c.pendingLanes & -1073741825),
      c !== 0 ? c : c & 1073741824 ? 1073741824 : 0
    );
  }
  function $0(c) {
    for (var f = [], v = 0; 31 > v; v++) f.push(c);
    return f;
  }
  function Yc(c, f, v) {
    (c.pendingLanes |= f),
      f !== 536870912 && ((c.suspendedLanes = 0), (c.pingedLanes = 0)),
      (c = c.eventTimes),
      (f = 31 - Wi(f)),
      (c[f] = v);
  }
  function dD(c, f) {
    var v = c.pendingLanes & ~f;
    (c.pendingLanes = f),
      (c.suspendedLanes = 0),
      (c.pingedLanes = 0),
      (c.expiredLanes &= f),
      (c.mutableReadLanes &= f),
      (c.entangledLanes &= f),
      (f = c.entanglements);
    var M = c.eventTimes;
    for (c = c.expirationTimes; 0 < v; ) {
      var w = 31 - Wi(v),
        b = 1 << w;
      (f[w] = 0), (M[w] = -1), (c[w] = -1), (v &= ~b);
    }
  }
  function e_(c, f) {
    var v = (c.entangledLanes |= f);
    for (c = c.entanglements; v; ) {
      var M = 31 - Wi(v),
        w = 1 << M;
      (w & f) | (c[M] & f) && (c[M] |= f), (v &= ~w);
    }
  }
  var Bt = 0;
  function cM(c) {
    return (
      (c &= -c), 1 < c ? (4 < c ? (c & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var t_ = i.unstable_scheduleCallback,
    fM = i.unstable_cancelCallback,
    pD = i.unstable_shouldYield,
    mD = i.unstable_requestPaint,
    Vn = i.unstable_now,
    n_ = i.unstable_ImmediatePriority,
    gD = i.unstable_UserBlockingPriority,
    r_ = i.unstable_NormalPriority,
    _D = i.unstable_IdlePriority,
    Rd = null,
    ps = null;
  function vD(c) {
    if (ps && typeof ps.onCommitFiberRoot == "function")
      try {
        ps.onCommitFiberRoot(Rd, c, void 0, (c.current.flags & 128) === 128);
      } catch {}
  }
  function yD(c, f) {
    return (c === f && (c !== 0 || 1 / c === 1 / f)) || (c !== c && f !== f);
  }
  var ms = typeof Object.is == "function" ? Object.is : yD,
    Hs = null,
    Pd = !1,
    i_ = !1;
  function hM(c) {
    Hs === null ? (Hs = [c]) : Hs.push(c);
  }
  function xD(c) {
    (Pd = !0), hM(c);
  }
  function gs() {
    if (!i_ && Hs !== null) {
      i_ = !0;
      var c = 0,
        f = Bt;
      try {
        var v = Hs;
        for (Bt = 1; c < v.length; c++) {
          var M = v[c];
          do M = M(!0);
          while (M !== null);
        }
        (Hs = null), (Pd = !1);
      } catch (w) {
        throw (Hs !== null && (Hs = Hs.slice(c + 1)), t_(n_, gs), w);
      } finally {
        (Bt = f), (i_ = !1);
      }
    }
    return null;
  }
  var SD = a.ReactCurrentBatchConfig;
  function Bd(c, f) {
    if (ms(c, f)) return !0;
    if (
      typeof c != "object" ||
      c === null ||
      typeof f != "object" ||
      f === null
    )
      return !1;
    var v = Object.keys(c),
      M = Object.keys(f);
    if (v.length !== M.length) return !1;
    for (M = 0; M < v.length; M++) {
      var w = v[M];
      if (!Yr.call(f, w) || !ms(c[w], f[w])) return !1;
    }
    return !0;
  }
  function AD(c) {
    switch (c.tag) {
      case 5:
        return ot(c.type);
      case 16:
        return ot("Lazy");
      case 13:
        return ot("Suspense");
      case 19:
        return ot("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (c = Kt(c.type, !1)), c;
      case 11:
        return (c = Kt(c.type.render, !1)), c;
      case 1:
        return (c = Kt(c.type, !0)), c;
      default:
        return "";
    }
  }
  function ji(c, f) {
    if (c && c.defaultProps) {
      (f = s({}, f)), (c = c.defaultProps);
      for (var v in c) f[v] === void 0 && (f[v] = c[v]);
      return f;
    }
    return f;
  }
  var Ld = ut(null),
    Id = null,
    Jl = null,
    s_ = null;
  function o_() {
    s_ = Jl = Id = null;
  }
  function dM(c, f, v) {
    lt
      ? (at(Ld, f._currentValue), (f._currentValue = v))
      : (at(Ld, f._currentValue2), (f._currentValue2 = v));
  }
  function a_(c) {
    var f = Ld.current;
    Ft(Ld), lt ? (c._currentValue = f) : (c._currentValue2 = f);
  }
  function l_(c, f, v) {
    for (; c !== null; ) {
      var M = c.alternate;
      if (
        ((c.childLanes & f) !== f
          ? ((c.childLanes |= f), M !== null && (M.childLanes |= f))
          : M !== null && (M.childLanes & f) !== f && (M.childLanes |= f),
        c === v)
      )
        break;
      c = c.return;
    }
  }
  function Kl(c, f) {
    (Id = c),
      (s_ = Jl = null),
      (c = c.dependencies),
      c !== null &&
        c.firstContext !== null &&
        (c.lanes & f && ($r = !0), (c.firstContext = null));
  }
  function gi(c) {
    var f = lt ? c._currentValue : c._currentValue2;
    if (s_ !== c)
      if (((c = { context: c, memoizedValue: f, next: null }), Jl === null)) {
        if (Id === null) throw Error(o(308));
        (Jl = c), (Id.dependencies = { lanes: 0, firstContext: c });
      } else Jl = Jl.next = c;
    return f;
  }
  var _s = null,
    Co = !1;
  function u_(c) {
    c.updateQueue = {
      baseState: c.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function pM(c, f) {
    (c = c.updateQueue),
      f.updateQueue === c &&
        (f.updateQueue = {
          baseState: c.baseState,
          firstBaseUpdate: c.firstBaseUpdate,
          lastBaseUpdate: c.lastBaseUpdate,
          shared: c.shared,
          effects: c.effects,
        });
  }
  function Gs(c, f) {
    return {
      eventTime: c,
      lane: f,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function To(c, f) {
    var v = c.updateQueue;
    v !== null &&
      ((v = v.shared),
      Cn !== null && c.mode & 1 && !(St & 2)
        ? ((c = v.interleaved),
          c === null
            ? ((f.next = f), _s === null ? (_s = [v]) : _s.push(v))
            : ((f.next = c.next), (c.next = f)),
          (v.interleaved = f))
        : ((c = v.pending),
          c === null ? (f.next = f) : ((f.next = c.next), (c.next = f)),
          (v.pending = f)));
  }
  function Dd(c, f, v) {
    if (
      ((f = f.updateQueue), f !== null && ((f = f.shared), (v & 4194240) !== 0))
    ) {
      var M = f.lanes;
      (M &= c.pendingLanes), (v |= M), (f.lanes = v), e_(c, v);
    }
  }
  function mM(c, f) {
    var v = c.updateQueue,
      M = c.alternate;
    if (M !== null && ((M = M.updateQueue), v === M)) {
      var w = null,
        b = null;
      if (((v = v.firstBaseUpdate), v !== null)) {
        do {
          var H = {
            eventTime: v.eventTime,
            lane: v.lane,
            tag: v.tag,
            payload: v.payload,
            callback: v.callback,
            next: null,
          };
          b === null ? (w = b = H) : (b = b.next = H), (v = v.next);
        } while (v !== null);
        b === null ? (w = b = f) : (b = b.next = f);
      } else w = b = f;
      (v = {
        baseState: M.baseState,
        firstBaseUpdate: w,
        lastBaseUpdate: b,
        shared: M.shared,
        effects: M.effects,
      }),
        (c.updateQueue = v);
      return;
    }
    (c = v.lastBaseUpdate),
      c === null ? (v.firstBaseUpdate = f) : (c.next = f),
      (v.lastBaseUpdate = f);
  }
  function Fd(c, f, v, M) {
    var w = c.updateQueue;
    Co = !1;
    var b = w.firstBaseUpdate,
      H = w.lastBaseUpdate,
      $ = w.shared.pending;
    if ($ !== null) {
      w.shared.pending = null;
      var le = $,
        Ee = le.next;
      (le.next = null), H === null ? (b = Ee) : (H.next = Ee), (H = le);
      var He = c.alternate;
      He !== null &&
        ((He = He.updateQueue),
        ($ = He.lastBaseUpdate),
        $ !== H &&
          ($ === null ? (He.firstBaseUpdate = Ee) : ($.next = Ee),
          (He.lastBaseUpdate = le)));
    }
    if (b !== null) {
      var ct = w.baseState;
      (H = 0), (He = Ee = le = null), ($ = b);
      do {
        var et = $.lane,
          zt = $.eventTime;
        if ((M & et) === et) {
          He !== null &&
            (He = He.next =
              {
                eventTime: zt,
                lane: 0,
                tag: $.tag,
                payload: $.payload,
                callback: $.callback,
                next: null,
              });
          e: {
            var Ye = c,
              lr = $;
            switch (((et = f), (zt = v), lr.tag)) {
              case 1:
                if (((Ye = lr.payload), typeof Ye == "function")) {
                  ct = Ye.call(zt, ct, et);
                  break e;
                }
                ct = Ye;
                break e;
              case 3:
                Ye.flags = (Ye.flags & -65537) | 128;
              case 0:
                if (
                  ((Ye = lr.payload),
                  (et = typeof Ye == "function" ? Ye.call(zt, ct, et) : Ye),
                  et == null)
                )
                  break e;
                ct = s({}, ct, et);
                break e;
              case 2:
                Co = !0;
            }
          }
          $.callback !== null &&
            $.lane !== 0 &&
            ((c.flags |= 64),
            (et = w.effects),
            et === null ? (w.effects = [$]) : et.push($));
        } else
          (zt = {
            eventTime: zt,
            lane: et,
            tag: $.tag,
            payload: $.payload,
            callback: $.callback,
            next: null,
          }),
            He === null ? ((Ee = He = zt), (le = ct)) : (He = He.next = zt),
            (H |= et);
        if ((($ = $.next), $ === null)) {
          if ((($ = w.shared.pending), $ === null)) break;
          (et = $),
            ($ = et.next),
            (et.next = null),
            (w.lastBaseUpdate = et),
            (w.shared.pending = null);
        }
      } while (1);
      if (
        (He === null && (le = ct),
        (w.baseState = le),
        (w.firstBaseUpdate = Ee),
        (w.lastBaseUpdate = He),
        (f = w.shared.interleaved),
        f !== null)
      ) {
        w = f;
        do (H |= w.lane), (w = w.next);
        while (w !== f);
      } else b === null && (w.shared.lanes = 0);
      (ru |= H), (c.lanes = H), (c.memoizedState = ct);
    }
  }
  function gM(c, f, v) {
    if (((c = f.effects), (f.effects = null), c !== null))
      for (f = 0; f < c.length; f++) {
        var M = c[f],
          w = M.callback;
        if (w !== null) {
          if (((M.callback = null), (M = v), typeof w != "function"))
            throw Error(o(191, w));
          w.call(M);
        }
      }
  }
  var _M = new r.Component().refs;
  function c_(c, f, v, M) {
    (f = c.memoizedState),
      (v = v(M, f)),
      (v = v == null ? f : s({}, f, v)),
      (c.memoizedState = v),
      c.lanes === 0 && (c.updateQueue.baseState = v);
  }
  var Nd = {
    isMounted: function (c) {
      return (c = c._reactInternals) ? T(c) === c : !1;
    },
    enqueueSetState: function (c, f, v) {
      c = c._reactInternals;
      var M = Ar(),
        w = Po(c),
        b = Gs(M, w);
      (b.payload = f),
        v != null && (b.callback = v),
        To(c, b),
        (f = Si(c, w, M)),
        f !== null && Dd(f, c, w);
    },
    enqueueReplaceState: function (c, f, v) {
      c = c._reactInternals;
      var M = Ar(),
        w = Po(c),
        b = Gs(M, w);
      (b.tag = 1),
        (b.payload = f),
        v != null && (b.callback = v),
        To(c, b),
        (f = Si(c, w, M)),
        f !== null && Dd(f, c, w);
    },
    enqueueForceUpdate: function (c, f) {
      c = c._reactInternals;
      var v = Ar(),
        M = Po(c),
        w = Gs(v, M);
      (w.tag = 2),
        f != null && (w.callback = f),
        To(c, w),
        (f = Si(c, M, v)),
        f !== null && Dd(f, c, M);
    },
  };
  function vM(c, f, v, M, w, b, H) {
    return (
      (c = c.stateNode),
      typeof c.shouldComponentUpdate == "function"
        ? c.shouldComponentUpdate(M, b, H)
        : f.prototype && f.prototype.isPureReactComponent
        ? !Bd(v, M) || !Bd(w, b)
        : !0
    );
  }
  function yM(c, f, v) {
    var M = !1,
      w = rr,
      b = f.contextType;
    return (
      typeof b == "object" && b !== null
        ? (b = gi(b))
        : ((w = fn(f) ? Vi : Dn.current),
          (M = f.contextTypes),
          (b = (M = M != null) ? cn(c, w) : rr)),
      (f = new f(v, b)),
      (c.memoizedState =
        f.state !== null && f.state !== void 0 ? f.state : null),
      (f.updater = Nd),
      (c.stateNode = f),
      (f._reactInternals = c),
      M &&
        ((c = c.stateNode),
        (c.__reactInternalMemoizedUnmaskedChildContext = w),
        (c.__reactInternalMemoizedMaskedChildContext = b)),
      f
    );
  }
  function xM(c, f, v, M) {
    (c = f.state),
      typeof f.componentWillReceiveProps == "function" &&
        f.componentWillReceiveProps(v, M),
      typeof f.UNSAFE_componentWillReceiveProps == "function" &&
        f.UNSAFE_componentWillReceiveProps(v, M),
      f.state !== c && Nd.enqueueReplaceState(f, f.state, null);
  }
  function f_(c, f, v, M) {
    var w = c.stateNode;
    (w.props = v), (w.state = c.memoizedState), (w.refs = _M), u_(c);
    var b = f.contextType;
    typeof b == "object" && b !== null
      ? (w.context = gi(b))
      : ((b = fn(f) ? Vi : Dn.current), (w.context = cn(c, b))),
      (w.state = c.memoizedState),
      (b = f.getDerivedStateFromProps),
      typeof b == "function" && (c_(c, f, b, v), (w.state = c.memoizedState)),
      typeof f.getDerivedStateFromProps == "function" ||
        typeof w.getSnapshotBeforeUpdate == "function" ||
        (typeof w.UNSAFE_componentWillMount != "function" &&
          typeof w.componentWillMount != "function") ||
        ((f = w.state),
        typeof w.componentWillMount == "function" && w.componentWillMount(),
        typeof w.UNSAFE_componentWillMount == "function" &&
          w.UNSAFE_componentWillMount(),
        f !== w.state && Nd.enqueueReplaceState(w, w.state, null),
        Fd(c, v, w, M),
        (w.state = c.memoizedState)),
      typeof w.componentDidMount == "function" && (c.flags |= 4194308);
  }
  var Yl = [],
    Ql = 0,
    Od = null,
    Ud = 0,
    _i = [],
    vi = 0,
    Ia = null,
    Vs = 1,
    Ws = "";
  function Da(c, f) {
    (Yl[Ql++] = Ud), (Yl[Ql++] = Od), (Od = c), (Ud = f);
  }
  function SM(c, f, v) {
    (_i[vi++] = Vs), (_i[vi++] = Ws), (_i[vi++] = Ia), (Ia = c);
    var M = Vs;
    c = Ws;
    var w = 32 - Wi(M) - 1;
    (M &= ~(1 << w)), (v += 1);
    var b = 32 - Wi(f) + w;
    if (30 < b) {
      var H = w - (w % 5);
      (b = (M & ((1 << H) - 1)).toString(32)),
        (M >>= H),
        (w -= H),
        (Vs = (1 << (32 - Wi(f) + w)) | (v << w) | M),
        (Ws = b + c);
    } else (Vs = (1 << b) | (v << w) | M), (Ws = c);
  }
  function h_(c) {
    c.return !== null && (Da(c, 1), SM(c, 1, 0));
  }
  function d_(c) {
    for (; c === Od; )
      (Od = Yl[--Ql]), (Yl[Ql] = null), (Ud = Yl[--Ql]), (Yl[Ql] = null);
    for (; c === Ia; )
      (Ia = _i[--vi]),
        (_i[vi] = null),
        (Ws = _i[--vi]),
        (_i[vi] = null),
        (Vs = _i[--vi]),
        (_i[vi] = null);
  }
  var qr = null,
    Zr = null,
    Zt = !1,
    Qc = !1,
    Xi = null;
  function AM(c, f) {
    var v = Ai(5, null, null, 0);
    (v.elementType = "DELETED"),
      (v.stateNode = f),
      (v.return = c),
      (f = c.deletions),
      f === null ? ((c.deletions = [v]), (c.flags |= 16)) : f.push(v);
  }
  function MM(c, f) {
    switch (c.tag) {
      case 5:
        return (
          (f = Qn(f, c.type, c.pendingProps)),
          f !== null ? ((c.stateNode = f), (qr = c), (Zr = wd(f)), !0) : !1
        );
      case 6:
        return (
          (f = Sd(f, c.pendingProps)),
          f !== null ? ((c.stateNode = f), (qr = c), (Zr = null), !0) : !1
        );
      case 13:
        if (((f = Ad(f)), f !== null)) {
          var v = Ia !== null ? { id: Vs, overflow: Ws } : null;
          return (
            (c.memoizedState = {
              dehydrated: f,
              treeContext: v,
              retryLane: 1073741824,
            }),
            (v = Ai(18, null, null, 0)),
            (v.stateNode = f),
            (v.return = c),
            (c.child = v),
            (qr = c),
            (Zr = null),
            !0
          );
        }
        return !1;
      default:
        return !1;
    }
  }
  function p_(c) {
    return (c.mode & 1) !== 0 && (c.flags & 128) === 0;
  }
  function m_(c) {
    if (Zt) {
      var f = Zr;
      if (f) {
        var v = f;
        if (!MM(c, f)) {
          if (p_(c)) throw Error(o(418));
          f = ds(v);
          var M = qr;
          f && MM(c, f)
            ? AM(M, v)
            : ((c.flags = (c.flags & -4097) | 2), (Zt = !1), (qr = c));
        }
      } else {
        if (p_(c)) throw Error(o(418));
        (c.flags = (c.flags & -4097) | 2), (Zt = !1), (qr = c);
      }
    }
  }
  function EM(c) {
    for (
      c = c.return;
      c !== null && c.tag !== 5 && c.tag !== 3 && c.tag !== 13;

    )
      c = c.return;
    qr = c;
  }
  function qc(c) {
    if (!_e || c !== qr) return !1;
    if (!Zt) return EM(c), (Zt = !0), !1;
    if (
      c.tag !== 3 &&
      (c.tag !== 5 || (nt(c.type) && !ye(c.type, c.memoizedProps)))
    ) {
      var f = Zr;
      if (f) {
        if (p_(c)) {
          for (c = Zr; c; ) c = ds(c);
          throw Error(o(418));
        }
        for (; f; ) AM(c, f), (f = ds(f));
      }
    }
    if ((EM(c), c.tag === 13)) {
      if (!_e) throw Error(o(316));
      if (((c = c.memoizedState), (c = c !== null ? c.dehydrated : null), !c))
        throw Error(o(317));
      Zr = ce(c);
    } else Zr = qr ? ds(c.stateNode) : null;
    return !0;
  }
  function ql() {
    _e && ((Zr = qr = null), (Qc = Zt = !1));
  }
  function g_(c) {
    Xi === null ? (Xi = [c]) : Xi.push(c);
  }
  function Zc(c, f, v) {
    if (
      ((c = v.ref),
      c !== null && typeof c != "function" && typeof c != "object")
    ) {
      if (v._owner) {
        if (((v = v._owner), v)) {
          if (v.tag !== 1) throw Error(o(309));
          var M = v.stateNode;
        }
        if (!M) throw Error(o(147, c));
        var w = M,
          b = "" + c;
        return f !== null &&
          f.ref !== null &&
          typeof f.ref == "function" &&
          f.ref._stringRef === b
          ? f.ref
          : ((f = function (H) {
              var $ = w.refs;
              $ === _M && ($ = w.refs = {}),
                H === null ? delete $[b] : ($[b] = H);
            }),
            (f._stringRef = b),
            f);
      }
      if (typeof c != "string") throw Error(o(284));
      if (!v._owner) throw Error(o(290, c));
    }
    return c;
  }
  function kd(c, f) {
    throw (
      ((c = Object.prototype.toString.call(f)),
      Error(
        o(
          31,
          c === "[object Object]"
            ? "object with keys {" + Object.keys(f).join(", ") + "}"
            : c
        )
      ))
    );
  }
  function wM(c) {
    var f = c._init;
    return f(c._payload);
  }
  function CM(c) {
    function f(re, ee) {
      if (c) {
        var se = re.deletions;
        se === null ? ((re.deletions = [ee]), (re.flags |= 16)) : se.push(ee);
      }
    }
    function v(re, ee) {
      if (!c) return null;
      for (; ee !== null; ) f(re, ee), (ee = ee.sibling);
      return null;
    }
    function M(re, ee) {
      for (re = new Map(); ee !== null; )
        ee.key !== null ? re.set(ee.key, ee) : re.set(ee.index, ee),
          (ee = ee.sibling);
      return re;
    }
    function w(re, ee) {
      return (re = Lo(re, ee)), (re.index = 0), (re.sibling = null), re;
    }
    function b(re, ee, se) {
      return (
        (re.index = se),
        c
          ? ((se = re.alternate),
            se !== null
              ? ((se = se.index), se < ee ? ((re.flags |= 2), ee) : se)
              : ((re.flags |= 2), ee))
          : ((re.flags |= 1048576), ee)
      );
    }
    function H(re) {
      return c && re.alternate === null && (re.flags |= 2), re;
    }
    function $(re, ee, se, Fe) {
      return ee === null || ee.tag !== 6
        ? ((ee = $_(se, re.mode, Fe)), (ee.return = re), ee)
        : ((ee = w(ee, se)), (ee.return = re), ee);
    }
    function le(re, ee, se, Fe) {
      var Ke = se.type;
      return Ke === h
        ? He(re, ee, se.props.children, Fe, se.key)
        : ee !== null &&
          (ee.elementType === Ke ||
            (typeof Ke == "object" &&
              Ke !== null &&
              Ke.$$typeof === A &&
              wM(Ke) === ee.type))
        ? ((Fe = w(ee, se.props)),
          (Fe.ref = Zc(re, ee, se)),
          (Fe.return = re),
          Fe)
        : ((Fe = gp(se.type, se.key, se.props, null, re.mode, Fe)),
          (Fe.ref = Zc(re, ee, se)),
          (Fe.return = re),
          Fe);
    }
    function Ee(re, ee, se, Fe) {
      return ee === null ||
        ee.tag !== 4 ||
        ee.stateNode.containerInfo !== se.containerInfo ||
        ee.stateNode.implementation !== se.implementation
        ? ((ee = ev(se, re.mode, Fe)), (ee.return = re), ee)
        : ((ee = w(ee, se.children || [])), (ee.return = re), ee);
    }
    function He(re, ee, se, Fe, Ke) {
      return ee === null || ee.tag !== 7
        ? ((ee = Ha(se, re.mode, Fe, Ke)), (ee.return = re), ee)
        : ((ee = w(ee, se)), (ee.return = re), ee);
    }
    function ct(re, ee, se) {
      if ((typeof ee == "string" && ee !== "") || typeof ee == "number")
        return (ee = $_("" + ee, re.mode, se)), (ee.return = re), ee;
      if (typeof ee == "object" && ee !== null) {
        switch (ee.$$typeof) {
          case l:
            return (
              (se = gp(ee.type, ee.key, ee.props, null, re.mode, se)),
              (se.ref = Zc(re, null, ee)),
              (se.return = re),
              se
            );
          case u:
            return (ee = ev(ee, re.mode, se)), (ee.return = re), ee;
          case A:
            var Fe = ee._init;
            return ct(re, Fe(ee._payload), se);
        }
        if (j(ee) || R(ee))
          return (ee = Ha(ee, re.mode, se, null)), (ee.return = re), ee;
        kd(re, ee);
      }
      return null;
    }
    function et(re, ee, se, Fe) {
      var Ke = ee !== null ? ee.key : null;
      if ((typeof se == "string" && se !== "") || typeof se == "number")
        return Ke !== null ? null : $(re, ee, "" + se, Fe);
      if (typeof se == "object" && se !== null) {
        switch (se.$$typeof) {
          case l:
            return se.key === Ke ? le(re, ee, se, Fe) : null;
          case u:
            return se.key === Ke ? Ee(re, ee, se, Fe) : null;
          case A:
            return (Ke = se._init), et(re, ee, Ke(se._payload), Fe);
        }
        if (j(se) || R(se))
          return Ke !== null ? null : He(re, ee, se, Fe, null);
        kd(re, se);
      }
      return null;
    }
    function zt(re, ee, se, Fe, Ke) {
      if ((typeof Fe == "string" && Fe !== "") || typeof Fe == "number")
        return (re = re.get(se) || null), $(ee, re, "" + Fe, Ke);
      if (typeof Fe == "object" && Fe !== null) {
        switch (Fe.$$typeof) {
          case l:
            return (
              (re = re.get(Fe.key === null ? se : Fe.key) || null),
              le(ee, re, Fe, Ke)
            );
          case u:
            return (
              (re = re.get(Fe.key === null ? se : Fe.key) || null),
              Ee(ee, re, Fe, Ke)
            );
          case A:
            var gt = Fe._init;
            return zt(re, ee, se, gt(Fe._payload), Ke);
        }
        if (j(Fe) || R(Fe))
          return (re = re.get(se) || null), He(ee, re, Fe, Ke, null);
        kd(ee, Fe);
      }
      return null;
    }
    function Ye(re, ee, se, Fe) {
      for (
        var Ke = null, gt = null, ft = ee, Lt = (ee = 0), jn = null;
        ft !== null && Lt < se.length;
        Lt++
      ) {
        ft.index > Lt ? ((jn = ft), (ft = null)) : (jn = ft.sibling);
        var It = et(re, ft, se[Lt], Fe);
        if (It === null) {
          ft === null && (ft = jn);
          break;
        }
        c && ft && It.alternate === null && f(re, ft),
          (ee = b(It, ee, Lt)),
          gt === null ? (Ke = It) : (gt.sibling = It),
          (gt = It),
          (ft = jn);
      }
      if (Lt === se.length) return v(re, ft), Zt && Da(re, Lt), Ke;
      if (ft === null) {
        for (; Lt < se.length; Lt++)
          (ft = ct(re, se[Lt], Fe)),
            ft !== null &&
              ((ee = b(ft, ee, Lt)),
              gt === null ? (Ke = ft) : (gt.sibling = ft),
              (gt = ft));
        return Zt && Da(re, Lt), Ke;
      }
      for (ft = M(re, ft); Lt < se.length; Lt++)
        (jn = zt(ft, re, Lt, se[Lt], Fe)),
          jn !== null &&
            (c &&
              jn.alternate !== null &&
              ft.delete(jn.key === null ? Lt : jn.key),
            (ee = b(jn, ee, Lt)),
            gt === null ? (Ke = jn) : (gt.sibling = jn),
            (gt = jn));
      return (
        c &&
          ft.forEach(function (Io) {
            return f(re, Io);
          }),
        Zt && Da(re, Lt),
        Ke
      );
    }
    function lr(re, ee, se, Fe) {
      var Ke = R(se);
      if (typeof Ke != "function") throw Error(o(150));
      if (((se = Ke.call(se)), se == null)) throw Error(o(151));
      for (
        var gt = (Ke = null), ft = ee, Lt = (ee = 0), jn = null, It = se.next();
        ft !== null && !It.done;
        Lt++, It = se.next()
      ) {
        ft.index > Lt ? ((jn = ft), (ft = null)) : (jn = ft.sibling);
        var Io = et(re, ft, It.value, Fe);
        if (Io === null) {
          ft === null && (ft = jn);
          break;
        }
        c && ft && Io.alternate === null && f(re, ft),
          (ee = b(Io, ee, Lt)),
          gt === null ? (Ke = Io) : (gt.sibling = Io),
          (gt = Io),
          (ft = jn);
      }
      if (It.done) return v(re, ft), Zt && Da(re, Lt), Ke;
      if (ft === null) {
        for (; !It.done; Lt++, It = se.next())
          (It = ct(re, It.value, Fe)),
            It !== null &&
              ((ee = b(It, ee, Lt)),
              gt === null ? (Ke = It) : (gt.sibling = It),
              (gt = It));
        return Zt && Da(re, Lt), Ke;
      }
      for (ft = M(re, ft); !It.done; Lt++, It = se.next())
        (It = zt(ft, re, Lt, It.value, Fe)),
          It !== null &&
            (c &&
              It.alternate !== null &&
              ft.delete(It.key === null ? Lt : It.key),
            (ee = b(It, ee, Lt)),
            gt === null ? (Ke = It) : (gt.sibling = It),
            (gt = It));
      return (
        c &&
          ft.forEach(function (ZD) {
            return f(re, ZD);
          }),
        Zt && Da(re, Lt),
        Ke
      );
    }
    function Mi(re, ee, se, Fe) {
      if (
        (typeof se == "object" &&
          se !== null &&
          se.type === h &&
          se.key === null &&
          (se = se.props.children),
        typeof se == "object" && se !== null)
      ) {
        switch (se.$$typeof) {
          case l:
            e: {
              for (var Ke = se.key, gt = ee; gt !== null; ) {
                if (gt.key === Ke) {
                  if (((Ke = se.type), Ke === h)) {
                    if (gt.tag === 7) {
                      v(re, gt.sibling),
                        (ee = w(gt, se.props.children)),
                        (ee.return = re),
                        (re = ee);
                      break e;
                    }
                  } else if (
                    gt.elementType === Ke ||
                    (typeof Ke == "object" &&
                      Ke !== null &&
                      Ke.$$typeof === A &&
                      wM(Ke) === gt.type)
                  ) {
                    v(re, gt.sibling),
                      (ee = w(gt, se.props)),
                      (ee.ref = Zc(re, gt, se)),
                      (ee.return = re),
                      (re = ee);
                    break e;
                  }
                  v(re, gt);
                  break;
                } else f(re, gt);
                gt = gt.sibling;
              }
              se.type === h
                ? ((ee = Ha(se.props.children, re.mode, Fe, se.key)),
                  (ee.return = re),
                  (re = ee))
                : ((Fe = gp(se.type, se.key, se.props, null, re.mode, Fe)),
                  (Fe.ref = Zc(re, ee, se)),
                  (Fe.return = re),
                  (re = Fe));
            }
            return H(re);
          case u:
            e: {
              for (gt = se.key; ee !== null; ) {
                if (ee.key === gt)
                  if (
                    ee.tag === 4 &&
                    ee.stateNode.containerInfo === se.containerInfo &&
                    ee.stateNode.implementation === se.implementation
                  ) {
                    v(re, ee.sibling),
                      (ee = w(ee, se.children || [])),
                      (ee.return = re),
                      (re = ee);
                    break e;
                  } else {
                    v(re, ee);
                    break;
                  }
                else f(re, ee);
                ee = ee.sibling;
              }
              (ee = ev(se, re.mode, Fe)), (ee.return = re), (re = ee);
            }
            return H(re);
          case A:
            return (gt = se._init), Mi(re, ee, gt(se._payload), Fe);
        }
        if (j(se)) return Ye(re, ee, se, Fe);
        if (R(se)) return lr(re, ee, se, Fe);
        kd(re, se);
      }
      return (typeof se == "string" && se !== "") || typeof se == "number"
        ? ((se = "" + se),
          ee !== null && ee.tag === 6
            ? (v(re, ee.sibling), (ee = w(ee, se)), (ee.return = re), (re = ee))
            : (v(re, ee),
              (ee = $_(se, re.mode, Fe)),
              (ee.return = re),
              (re = ee)),
          H(re))
        : v(re, ee);
    }
    return Mi;
  }
  var Zl = CM(!0),
    TM = CM(!1),
    $c = {},
    yi = ut($c),
    ef = ut($c),
    $l = ut($c);
  function vs(c) {
    if (c === $c) throw Error(o(174));
    return c;
  }
  function __(c, f) {
    at($l, f), at(ef, c), at(yi, $c), (c = Q(f)), Ft(yi), at(yi, c);
  }
  function eu() {
    Ft(yi), Ft(ef), Ft($l);
  }
  function bM(c) {
    var f = vs($l.current),
      v = vs(yi.current);
    (f = N(v, c.type, f)), v !== f && (at(ef, c), at(yi, f));
  }
  function v_(c) {
    ef.current === c && (Ft(yi), Ft(ef));
  }
  var tn = ut(0);
  function zd(c) {
    for (var f = c; f !== null; ) {
      if (f.tag === 13) {
        var v = f.memoizedState;
        if (v !== null && ((v = v.dehydrated), v === null || Md(v) || Eo(v)))
          return f;
      } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
        if (f.flags & 128) return f;
      } else if (f.child !== null) {
        (f.child.return = f), (f = f.child);
        continue;
      }
      if (f === c) break;
      for (; f.sibling === null; ) {
        if (f.return === null || f.return === c) return null;
        f = f.return;
      }
      (f.sibling.return = f.return), (f = f.sibling);
    }
    return null;
  }
  var y_ = [];
  function x_() {
    for (var c = 0; c < y_.length; c++) {
      var f = y_[c];
      lt
        ? (f._workInProgressVersionPrimary = null)
        : (f._workInProgressVersionSecondary = null);
    }
    y_.length = 0;
  }
  var Hd = a.ReactCurrentDispatcher,
    xi = a.ReactCurrentBatchConfig,
    tu = 0,
    hn = null,
    sr = null,
    Wn = null,
    Gd = !1,
    tf = !1,
    nf = 0,
    MD = 0;
  function or() {
    throw Error(o(321));
  }
  function S_(c, f) {
    if (f === null) return !1;
    for (var v = 0; v < f.length && v < c.length; v++)
      if (!ms(c[v], f[v])) return !1;
    return !0;
  }
  function A_(c, f, v, M, w, b) {
    if (
      ((tu = b),
      (hn = f),
      (f.memoizedState = null),
      (f.updateQueue = null),
      (f.lanes = 0),
      (Hd.current = c === null || c.memoizedState === null ? TD : bD),
      (c = v(M, w)),
      tf)
    ) {
      b = 0;
      do {
        if (((tf = !1), (nf = 0), 25 <= b)) throw Error(o(301));
        (b += 1),
          (Wn = sr = null),
          (f.updateQueue = null),
          (Hd.current = RD),
          (c = v(M, w));
      } while (tf);
    }
    if (
      ((Hd.current = Jd),
      (f = sr !== null && sr.next !== null),
      (tu = 0),
      (Wn = sr = hn = null),
      (Gd = !1),
      f)
    )
      throw Error(o(300));
    return c;
  }
  function M_() {
    var c = nf !== 0;
    return (nf = 0), c;
  }
  function js() {
    var c = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Wn === null ? (hn.memoizedState = Wn = c) : (Wn = Wn.next = c), Wn;
  }
  function ys() {
    if (sr === null) {
      var c = hn.alternate;
      c = c !== null ? c.memoizedState : null;
    } else c = sr.next;
    var f = Wn === null ? hn.memoizedState : Wn.next;
    if (f !== null) (Wn = f), (sr = c);
    else {
      if (c === null) throw Error(o(310));
      (sr = c),
        (c = {
          memoizedState: sr.memoizedState,
          baseState: sr.baseState,
          baseQueue: sr.baseQueue,
          queue: sr.queue,
          next: null,
        }),
        Wn === null ? (hn.memoizedState = Wn = c) : (Wn = Wn.next = c);
    }
    return Wn;
  }
  function Fa(c, f) {
    return typeof f == "function" ? f(c) : f;
  }
  function Vd(c) {
    var f = ys(),
      v = f.queue;
    if (v === null) throw Error(o(311));
    v.lastRenderedReducer = c;
    var M = sr,
      w = M.baseQueue,
      b = v.pending;
    if (b !== null) {
      if (w !== null) {
        var H = w.next;
        (w.next = b.next), (b.next = H);
      }
      (M.baseQueue = w = b), (v.pending = null);
    }
    if (w !== null) {
      (b = w.next), (M = M.baseState);
      var $ = (H = null),
        le = null,
        Ee = b;
      do {
        var He = Ee.lane;
        if ((tu & He) === He)
          le !== null &&
            (le = le.next =
              {
                lane: 0,
                action: Ee.action,
                hasEagerState: Ee.hasEagerState,
                eagerState: Ee.eagerState,
                next: null,
              }),
            (M = Ee.hasEagerState ? Ee.eagerState : c(M, Ee.action));
        else {
          var ct = {
            lane: He,
            action: Ee.action,
            hasEagerState: Ee.hasEagerState,
            eagerState: Ee.eagerState,
            next: null,
          };
          le === null ? (($ = le = ct), (H = M)) : (le = le.next = ct),
            (hn.lanes |= He),
            (ru |= He);
        }
        Ee = Ee.next;
      } while (Ee !== null && Ee !== b);
      le === null ? (H = M) : (le.next = $),
        ms(M, f.memoizedState) || ($r = !0),
        (f.memoizedState = M),
        (f.baseState = H),
        (f.baseQueue = le),
        (v.lastRenderedState = M);
    }
    if (((c = v.interleaved), c !== null)) {
      w = c;
      do (b = w.lane), (hn.lanes |= b), (ru |= b), (w = w.next);
      while (w !== c);
    } else w === null && (v.lanes = 0);
    return [f.memoizedState, v.dispatch];
  }
  function Wd(c) {
    var f = ys(),
      v = f.queue;
    if (v === null) throw Error(o(311));
    v.lastRenderedReducer = c;
    var M = v.dispatch,
      w = v.pending,
      b = f.memoizedState;
    if (w !== null) {
      v.pending = null;
      var H = (w = w.next);
      do (b = c(b, H.action)), (H = H.next);
      while (H !== w);
      ms(b, f.memoizedState) || ($r = !0),
        (f.memoizedState = b),
        f.baseQueue === null && (f.baseState = b),
        (v.lastRenderedState = b);
    }
    return [b, M];
  }
  function RM() {}
  function PM(c, f) {
    var v = hn,
      M = ys(),
      w = f(),
      b = !ms(M.memoizedState, w);
    if (
      (b && ((M.memoizedState = w), ($r = !0)),
      (M = M.queue),
      sf(IM.bind(null, v, M, c), [c]),
      M.getSnapshot !== f || b || (Wn !== null && Wn.memoizedState.tag & 1))
    ) {
      if (
        ((v.flags |= 2048),
        rf(9, LM.bind(null, v, M, w, f), void 0, null),
        Cn === null)
      )
        throw Error(o(349));
      tu & 30 || BM(v, f, w);
    }
    return w;
  }
  function BM(c, f, v) {
    (c.flags |= 16384),
      (c = { getSnapshot: f, value: v }),
      (f = hn.updateQueue),
      f === null
        ? ((f = { lastEffect: null, stores: null }),
          (hn.updateQueue = f),
          (f.stores = [c]))
        : ((v = f.stores), v === null ? (f.stores = [c]) : v.push(c));
  }
  function LM(c, f, v, M) {
    (f.value = v), (f.getSnapshot = M), DM(f) && Si(c, 1, -1);
  }
  function IM(c, f, v) {
    return v(function () {
      DM(f) && Si(c, 1, -1);
    });
  }
  function DM(c) {
    var f = c.getSnapshot;
    c = c.value;
    try {
      var v = f();
      return !ms(c, v);
    } catch {
      return !0;
    }
  }
  function E_(c) {
    var f = js();
    return (
      typeof c == "function" && (c = c()),
      (f.memoizedState = f.baseState = c),
      (c = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Fa,
        lastRenderedState: c,
      }),
      (f.queue = c),
      (c = c.dispatch = CD.bind(null, hn, c)),
      [f.memoizedState, c]
    );
  }
  function rf(c, f, v, M) {
    return (
      (c = { tag: c, create: f, destroy: v, deps: M, next: null }),
      (f = hn.updateQueue),
      f === null
        ? ((f = { lastEffect: null, stores: null }),
          (hn.updateQueue = f),
          (f.lastEffect = c.next = c))
        : ((v = f.lastEffect),
          v === null
            ? (f.lastEffect = c.next = c)
            : ((M = v.next), (v.next = c), (c.next = M), (f.lastEffect = c))),
      c
    );
  }
  function FM() {
    return ys().memoizedState;
  }
  function jd(c, f, v, M) {
    var w = js();
    (hn.flags |= c),
      (w.memoizedState = rf(1 | f, v, void 0, M === void 0 ? null : M));
  }
  function Xd(c, f, v, M) {
    var w = ys();
    M = M === void 0 ? null : M;
    var b = void 0;
    if (sr !== null) {
      var H = sr.memoizedState;
      if (((b = H.destroy), M !== null && S_(M, H.deps))) {
        w.memoizedState = rf(f, v, b, M);
        return;
      }
    }
    (hn.flags |= c), (w.memoizedState = rf(1 | f, v, b, M));
  }
  function w_(c, f) {
    return jd(8390656, 8, c, f);
  }
  function sf(c, f) {
    return Xd(2048, 8, c, f);
  }
  function NM(c, f) {
    return Xd(4, 2, c, f);
  }
  function OM(c, f) {
    return Xd(4, 4, c, f);
  }
  function UM(c, f) {
    if (typeof f == "function")
      return (
        (c = c()),
        f(c),
        function () {
          f(null);
        }
      );
    if (f != null)
      return (
        (c = c()),
        (f.current = c),
        function () {
          f.current = null;
        }
      );
  }
  function kM(c, f, v) {
    return (
      (v = v != null ? v.concat([c]) : null), Xd(4, 4, UM.bind(null, f, c), v)
    );
  }
  function C_() {}
  function zM(c, f) {
    var v = ys();
    f = f === void 0 ? null : f;
    var M = v.memoizedState;
    return M !== null && f !== null && S_(f, M[1])
      ? M[0]
      : ((v.memoizedState = [c, f]), c);
  }
  function HM(c, f) {
    var v = ys();
    f = f === void 0 ? null : f;
    var M = v.memoizedState;
    return M !== null && f !== null && S_(f, M[1])
      ? M[0]
      : ((c = c()), (v.memoizedState = [c, f]), c);
  }
  function ED(c, f) {
    var v = Bt;
    (Bt = v !== 0 && 4 > v ? v : 4), c(!0);
    var M = xi.transition;
    xi.transition = {};
    try {
      c(!1), f();
    } finally {
      (Bt = v), (xi.transition = M);
    }
  }
  function GM() {
    return ys().memoizedState;
  }
  function wD(c, f, v) {
    var M = Po(c);
    (v = {
      lane: M,
      action: v,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      VM(c)
        ? WM(f, v)
        : (jM(c, f, v),
          (v = Ar()),
          (c = Si(c, M, v)),
          c !== null && XM(c, f, M));
  }
  function CD(c, f, v) {
    var M = Po(c),
      w = {
        lane: M,
        action: v,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (VM(c)) WM(f, w);
    else {
      jM(c, f, w);
      var b = c.alternate;
      if (
        c.lanes === 0 &&
        (b === null || b.lanes === 0) &&
        ((b = f.lastRenderedReducer), b !== null)
      )
        try {
          var H = f.lastRenderedState,
            $ = b(H, v);
          if (((w.hasEagerState = !0), (w.eagerState = $), ms($, H))) return;
        } catch {
        } finally {
        }
      (v = Ar()), (c = Si(c, M, v)), c !== null && XM(c, f, M);
    }
  }
  function VM(c) {
    var f = c.alternate;
    return c === hn || (f !== null && f === hn);
  }
  function WM(c, f) {
    tf = Gd = !0;
    var v = c.pending;
    v === null ? (f.next = f) : ((f.next = v.next), (v.next = f)),
      (c.pending = f);
  }
  function jM(c, f, v) {
    Cn !== null && c.mode & 1 && !(St & 2)
      ? ((c = f.interleaved),
        c === null
          ? ((v.next = v), _s === null ? (_s = [f]) : _s.push(f))
          : ((v.next = c.next), (c.next = v)),
        (f.interleaved = v))
      : ((c = f.pending),
        c === null ? (v.next = v) : ((v.next = c.next), (c.next = v)),
        (f.pending = v));
  }
  function XM(c, f, v) {
    if (v & 4194240) {
      var M = f.lanes;
      (M &= c.pendingLanes), (v |= M), (f.lanes = v), e_(c, v);
    }
  }
  var Jd = {
      readContext: gi,
      useCallback: or,
      useContext: or,
      useEffect: or,
      useImperativeHandle: or,
      useInsertionEffect: or,
      useLayoutEffect: or,
      useMemo: or,
      useReducer: or,
      useRef: or,
      useState: or,
      useDebugValue: or,
      useDeferredValue: or,
      useTransition: or,
      useMutableSource: or,
      useSyncExternalStore: or,
      useId: or,
      unstable_isNewReconciler: !1,
    },
    TD = {
      readContext: gi,
      useCallback: function (c, f) {
        return (js().memoizedState = [c, f === void 0 ? null : f]), c;
      },
      useContext: gi,
      useEffect: w_,
      useImperativeHandle: function (c, f, v) {
        return (
          (v = v != null ? v.concat([c]) : null),
          jd(4194308, 4, UM.bind(null, f, c), v)
        );
      },
      useLayoutEffect: function (c, f) {
        return jd(4194308, 4, c, f);
      },
      useInsertionEffect: function (c, f) {
        return jd(4, 2, c, f);
      },
      useMemo: function (c, f) {
        var v = js();
        return (
          (f = f === void 0 ? null : f),
          (c = c()),
          (v.memoizedState = [c, f]),
          c
        );
      },
      useReducer: function (c, f, v) {
        var M = js();
        return (
          (f = v !== void 0 ? v(f) : f),
          (M.memoizedState = M.baseState = f),
          (c = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: c,
            lastRenderedState: f,
          }),
          (M.queue = c),
          (c = c.dispatch = wD.bind(null, hn, c)),
          [M.memoizedState, c]
        );
      },
      useRef: function (c) {
        var f = js();
        return (c = { current: c }), (f.memoizedState = c);
      },
      useState: E_,
      useDebugValue: C_,
      useDeferredValue: function (c) {
        var f = E_(c),
          v = f[0],
          M = f[1];
        return (
          w_(
            function () {
              var w = xi.transition;
              xi.transition = {};
              try {
                M(c);
              } finally {
                xi.transition = w;
              }
            },
            [c]
          ),
          v
        );
      },
      useTransition: function () {
        var c = E_(!1),
          f = c[0];
        return (c = ED.bind(null, c[1])), (js().memoizedState = c), [f, c];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (c, f, v) {
        var M = hn,
          w = js();
        if (Zt) {
          if (v === void 0) throw Error(o(407));
          v = v();
        } else {
          if (((v = f()), Cn === null)) throw Error(o(349));
          tu & 30 || BM(M, f, v);
        }
        w.memoizedState = v;
        var b = { value: v, getSnapshot: f };
        return (
          (w.queue = b),
          w_(IM.bind(null, M, b, c), [c]),
          (M.flags |= 2048),
          rf(9, LM.bind(null, M, b, v, f), void 0, null),
          v
        );
      },
      useId: function () {
        var c = js(),
          f = Cn.identifierPrefix;
        if (Zt) {
          var v = Ws,
            M = Vs;
          (v = (M & ~(1 << (32 - Wi(M) - 1))).toString(32) + v),
            (f = ":" + f + "R" + v),
            (v = nf++),
            0 < v && (f += "H" + v.toString(32)),
            (f += ":");
        } else (v = MD++), (f = ":" + f + "r" + v.toString(32) + ":");
        return (c.memoizedState = f);
      },
      unstable_isNewReconciler: !1,
    },
    bD = {
      readContext: gi,
      useCallback: zM,
      useContext: gi,
      useEffect: sf,
      useImperativeHandle: kM,
      useInsertionEffect: NM,
      useLayoutEffect: OM,
      useMemo: HM,
      useReducer: Vd,
      useRef: FM,
      useState: function () {
        return Vd(Fa);
      },
      useDebugValue: C_,
      useDeferredValue: function (c) {
        var f = Vd(Fa),
          v = f[0],
          M = f[1];
        return (
          sf(
            function () {
              var w = xi.transition;
              xi.transition = {};
              try {
                M(c);
              } finally {
                xi.transition = w;
              }
            },
            [c]
          ),
          v
        );
      },
      useTransition: function () {
        var c = Vd(Fa)[0],
          f = ys().memoizedState;
        return [c, f];
      },
      useMutableSource: RM,
      useSyncExternalStore: PM,
      useId: GM,
      unstable_isNewReconciler: !1,
    },
    RD = {
      readContext: gi,
      useCallback: zM,
      useContext: gi,
      useEffect: sf,
      useImperativeHandle: kM,
      useInsertionEffect: NM,
      useLayoutEffect: OM,
      useMemo: HM,
      useReducer: Wd,
      useRef: FM,
      useState: function () {
        return Wd(Fa);
      },
      useDebugValue: C_,
      useDeferredValue: function (c) {
        var f = Wd(Fa),
          v = f[0],
          M = f[1];
        return (
          sf(
            function () {
              var w = xi.transition;
              xi.transition = {};
              try {
                M(c);
              } finally {
                xi.transition = w;
              }
            },
            [c]
          ),
          v
        );
      },
      useTransition: function () {
        var c = Wd(Fa)[0],
          f = ys().memoizedState;
        return [c, f];
      },
      useMutableSource: RM,
      useSyncExternalStore: PM,
      useId: GM,
      unstable_isNewReconciler: !1,
    };
  function T_(c, f) {
    try {
      var v = "",
        M = f;
      do (v += AD(M)), (M = M.return);
      while (M);
      var w = v;
    } catch (b) {
      w =
        `
Error generating stack: ` +
        b.message +
        `
` +
        b.stack;
    }
    return { value: c, source: f, stack: w };
  }
  function b_(c, f) {
    try {
      console.error(f.value);
    } catch (v) {
      setTimeout(function () {
        throw v;
      });
    }
  }
  var PD = typeof WeakMap == "function" ? WeakMap : Map;
  function JM(c, f, v) {
    (v = Gs(-1, v)), (v.tag = 3), (v.payload = { element: null });
    var M = f.value;
    return (
      (v.callback = function () {
        up || ((up = !0), (X_ = M)), b_(c, f);
      }),
      v
    );
  }
  function KM(c, f, v) {
    (v = Gs(-1, v)), (v.tag = 3);
    var M = c.type.getDerivedStateFromError;
    if (typeof M == "function") {
      var w = f.value;
      (v.payload = function () {
        return M(w);
      }),
        (v.callback = function () {
          b_(c, f);
        });
    }
    var b = c.stateNode;
    return (
      b !== null &&
        typeof b.componentDidCatch == "function" &&
        (v.callback = function () {
          b_(c, f),
            typeof M != "function" &&
              (bo === null ? (bo = new Set([this])) : bo.add(this));
          var H = f.stack;
          this.componentDidCatch(f.value, {
            componentStack: H !== null ? H : "",
          });
        }),
      v
    );
  }
  function YM(c, f, v) {
    var M = c.pingCache;
    if (M === null) {
      M = c.pingCache = new PD();
      var w = new Set();
      M.set(f, w);
    } else (w = M.get(f)), w === void 0 && ((w = new Set()), M.set(f, w));
    w.has(v) || (w.add(v), (c = WD.bind(null, c, f, v)), f.then(c, c));
  }
  function QM(c) {
    do {
      var f;
      if (
        ((f = c.tag === 13) &&
          ((f = c.memoizedState),
          (f = f !== null ? f.dehydrated !== null : !0)),
        f)
      )
        return c;
      c = c.return;
    } while (c !== null);
    return null;
  }
  function qM(c, f, v, M, w) {
    return c.mode & 1
      ? ((c.flags |= 65536), (c.lanes = w), c)
      : (c === f
          ? (c.flags |= 65536)
          : ((c.flags |= 128),
            (v.flags |= 131072),
            (v.flags &= -52805),
            v.tag === 1 &&
              (v.alternate === null
                ? (v.tag = 17)
                : ((f = Gs(-1, 1)), (f.tag = 2), To(v, f))),
            (v.lanes |= 1)),
        c);
  }
  function xs(c) {
    c.flags |= 4;
  }
  function ZM(c, f) {
    if (c !== null && c.child === f.child) return !0;
    if (f.flags & 16) return !1;
    for (c = f.child; c !== null; ) {
      if (c.flags & 12854 || c.subtreeFlags & 12854) return !1;
      c = c.sibling;
    }
    return !0;
  }
  var of, af, Kd, Yd;
  if (Ce)
    (of = function (c, f) {
      for (var v = f.child; v !== null; ) {
        if (v.tag === 5 || v.tag === 6) Y(c, v.stateNode);
        else if (v.tag !== 4 && v.child !== null) {
          (v.child.return = v), (v = v.child);
          continue;
        }
        if (v === f) break;
        for (; v.sibling === null; ) {
          if (v.return === null || v.return === f) return;
          v = v.return;
        }
        (v.sibling.return = v.return), (v = v.sibling);
      }
    }),
      (af = function () {}),
      (Kd = function (c, f, v, M, w) {
        if (((c = c.memoizedProps), c !== M)) {
          var b = f.stateNode,
            H = vs(yi.current);
          (v = ae(b, v, c, M, w, H)), (f.updateQueue = v) && xs(f);
        }
      }),
      (Yd = function (c, f, v, M) {
        v !== M && xs(f);
      });
  else if (K) {
    of = function (c, f, v, M) {
      for (var w = f.child; w !== null; ) {
        if (w.tag === 5) {
          var b = w.stateNode;
          v && M && (b = Jt(b, w.type, w.memoizedProps, w)), Y(c, b);
        } else if (w.tag === 6)
          (b = w.stateNode), v && M && (b = Kr(b, w.memoizedProps, w)), Y(c, b);
        else if (w.tag !== 4) {
          if (w.tag === 22 && w.memoizedState !== null)
            (b = w.child), b !== null && (b.return = w), of(c, w, !0, !0);
          else if (w.child !== null) {
            (w.child.return = w), (w = w.child);
            continue;
          }
        }
        if (w === f) break;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === f) return;
          w = w.return;
        }
        (w.sibling.return = w.return), (w = w.sibling);
      }
    };
    var $M = function (c, f, v, M) {
      for (var w = f.child; w !== null; ) {
        if (w.tag === 5) {
          var b = w.stateNode;
          v && M && (b = Jt(b, w.type, w.memoizedProps, w)), Wt(c, b);
        } else if (w.tag === 6)
          (b = w.stateNode),
            v && M && (b = Kr(b, w.memoizedProps, w)),
            Wt(c, b);
        else if (w.tag !== 4) {
          if (w.tag === 22 && w.memoizedState !== null)
            (b = w.child), b !== null && (b.return = w), $M(c, w, !0, !0);
          else if (w.child !== null) {
            (w.child.return = w), (w = w.child);
            continue;
          }
        }
        if (w === f) break;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === f) return;
          w = w.return;
        }
        (w.sibling.return = w.return), (w = w.sibling);
      }
    };
    (af = function (c, f) {
      var v = f.stateNode;
      if (!ZM(c, f)) {
        c = v.containerInfo;
        var M = Et(c);
        $M(M, f, !1, !1), (v.pendingChildren = M), xs(f), En(c, M);
      }
    }),
      (Kd = function (c, f, v, M, w) {
        var b = c.stateNode,
          H = c.memoizedProps;
        if ((c = ZM(c, f)) && H === M) f.stateNode = b;
        else {
          var $ = f.stateNode,
            le = vs(yi.current),
            Ee = null;
          H !== M && (Ee = ae($, v, H, M, w, le)),
            c && Ee === null
              ? (f.stateNode = b)
              : ((b = De(b, Ee, v, H, M, f, c, $)),
                de(b, v, M, w, le) && xs(f),
                (f.stateNode = b),
                c ? xs(f) : of(b, f, !1, !1));
        }
      }),
      (Yd = function (c, f, v, M) {
        v !== M
          ? ((c = vs($l.current)),
            (v = vs(yi.current)),
            (f.stateNode = we(M, c, v, f)),
            xs(f))
          : (f.stateNode = c.stateNode);
      });
  } else (af = function () {}), (Kd = function () {}), (Yd = function () {});
  function lf(c, f) {
    if (!Zt)
      switch (c.tailMode) {
        case "hidden":
          f = c.tail;
          for (var v = null; f !== null; )
            f.alternate !== null && (v = f), (f = f.sibling);
          v === null ? (c.tail = null) : (v.sibling = null);
          break;
        case "collapsed":
          v = c.tail;
          for (var M = null; v !== null; )
            v.alternate !== null && (M = v), (v = v.sibling);
          M === null
            ? f || c.tail === null
              ? (c.tail = null)
              : (c.tail.sibling = null)
            : (M.sibling = null);
      }
  }
  function ar(c) {
    var f = c.alternate !== null && c.alternate.child === c.child,
      v = 0,
      M = 0;
    if (f)
      for (var w = c.child; w !== null; )
        (v |= w.lanes | w.childLanes),
          (M |= w.subtreeFlags & 14680064),
          (M |= w.flags & 14680064),
          (w.return = c),
          (w = w.sibling);
    else
      for (w = c.child; w !== null; )
        (v |= w.lanes | w.childLanes),
          (M |= w.subtreeFlags),
          (M |= w.flags),
          (w.return = c),
          (w = w.sibling);
    return (c.subtreeFlags |= M), (c.childLanes = v), f;
  }
  function BD(c, f, v) {
    var M = f.pendingProps;
    switch ((d_(f), f.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ar(f), null;
      case 1:
        return fn(f.type) && wo(), ar(f), null;
      case 3:
        return (
          (M = f.stateNode),
          eu(),
          Ft(wn),
          Ft(Dn),
          x_(),
          M.pendingContext &&
            ((M.context = M.pendingContext), (M.pendingContext = null)),
          (c === null || c.child === null) &&
            (qc(f)
              ? xs(f)
              : c === null ||
                (c.memoizedState.isDehydrated && !(f.flags & 256)) ||
                ((f.flags |= 1024), Xi !== null && (Y_(Xi), (Xi = null)))),
          af(c, f),
          ar(f),
          null
        );
      case 5:
        v_(f), (v = vs($l.current));
        var w = f.type;
        if (c !== null && f.stateNode != null)
          Kd(c, f, w, M, v),
            c.ref !== f.ref && ((f.flags |= 512), (f.flags |= 2097152));
        else {
          if (!M) {
            if (f.stateNode === null) throw Error(o(166));
            return ar(f), null;
          }
          if (((c = vs(yi.current)), qc(f))) {
            if (!_e) throw Error(o(175));
            (c = q0(f.stateNode, f.type, f.memoizedProps, v, c, f, !Qc)),
              (f.updateQueue = c),
              c !== null && xs(f);
          } else {
            var b = X(w, M, v, c, f);
            of(b, f, !1, !1), (f.stateNode = b), de(b, w, M, v, c) && xs(f);
          }
          f.ref !== null && ((f.flags |= 512), (f.flags |= 2097152));
        }
        return ar(f), null;
      case 6:
        if (c && f.stateNode != null) Yd(c, f, c.memoizedProps, M);
        else {
          if (typeof M != "string" && f.stateNode === null) throw Error(o(166));
          if (((c = vs($l.current)), (v = vs(yi.current)), qc(f))) {
            if (!_e) throw Error(o(176));
            if (
              ((c = f.stateNode),
              (M = f.memoizedProps),
              (v = z(c, M, f, !Qc)) && ((w = qr), w !== null))
            )
              switch (((b = (w.mode & 1) !== 0), w.tag)) {
                case 3:
                  it(w.stateNode.containerInfo, c, M, b);
                  break;
                case 5:
                  xt(w.type, w.memoizedProps, w.stateNode, c, M, b);
              }
            v && xs(f);
          } else f.stateNode = we(M, c, v, f);
        }
        return ar(f), null;
      case 13:
        if (
          (Ft(tn),
          (M = f.memoizedState),
          Zt && Zr !== null && f.mode & 1 && !(f.flags & 128))
        ) {
          for (c = Zr; c; ) c = ds(c);
          return ql(), (f.flags |= 98560), f;
        }
        if (M !== null && M.dehydrated !== null) {
          if (((M = qc(f)), c === null)) {
            if (!M) throw Error(o(318));
            if (!_e) throw Error(o(344));
            if (
              ((c = f.memoizedState),
              (c = c !== null ? c.dehydrated : null),
              !c)
            )
              throw Error(o(317));
            ie(c, f);
          } else
            ql(), !(f.flags & 128) && (f.memoizedState = null), (f.flags |= 4);
          return ar(f), null;
        }
        return (
          Xi !== null && (Y_(Xi), (Xi = null)),
          f.flags & 128
            ? ((f.lanes = v), f)
            : ((M = M !== null),
              (v = !1),
              c === null ? qc(f) : (v = c.memoizedState !== null),
              M &&
                !v &&
                ((f.child.flags |= 8192),
                f.mode & 1 &&
                  (c === null || tn.current & 1 ? Fn === 0 && (Fn = 3) : q_())),
              f.updateQueue !== null && (f.flags |= 4),
              ar(f),
              null)
        );
      case 4:
        return (
          eu(),
          af(c, f),
          c === null && Ae(f.stateNode.containerInfo),
          ar(f),
          null
        );
      case 10:
        return a_(f.type._context), ar(f), null;
      case 17:
        return fn(f.type) && wo(), ar(f), null;
      case 19:
        if ((Ft(tn), (w = f.memoizedState), w === null)) return ar(f), null;
        if (((M = (f.flags & 128) !== 0), (b = w.rendering), b === null))
          if (M) lf(w, !1);
          else {
            if (Fn !== 0 || (c !== null && c.flags & 128))
              for (c = f.child; c !== null; ) {
                if (((b = zd(c)), b !== null)) {
                  for (
                    f.flags |= 128,
                      lf(w, !1),
                      c = b.updateQueue,
                      c !== null && ((f.updateQueue = c), (f.flags |= 4)),
                      f.subtreeFlags = 0,
                      c = v,
                      M = f.child;
                    M !== null;

                  )
                    (v = M),
                      (w = c),
                      (v.flags &= 14680066),
                      (b = v.alternate),
                      b === null
                        ? ((v.childLanes = 0),
                          (v.lanes = w),
                          (v.child = null),
                          (v.subtreeFlags = 0),
                          (v.memoizedProps = null),
                          (v.memoizedState = null),
                          (v.updateQueue = null),
                          (v.dependencies = null),
                          (v.stateNode = null))
                        : ((v.childLanes = b.childLanes),
                          (v.lanes = b.lanes),
                          (v.child = b.child),
                          (v.subtreeFlags = 0),
                          (v.deletions = null),
                          (v.memoizedProps = b.memoizedProps),
                          (v.memoizedState = b.memoizedState),
                          (v.updateQueue = b.updateQueue),
                          (v.type = b.type),
                          (w = b.dependencies),
                          (v.dependencies =
                            w === null
                              ? null
                              : {
                                  lanes: w.lanes,
                                  firstContext: w.firstContext,
                                })),
                      (M = M.sibling);
                  return at(tn, (tn.current & 1) | 2), f.child;
                }
                c = c.sibling;
              }
            w.tail !== null &&
              Vn() > j_ &&
              ((f.flags |= 128), (M = !0), lf(w, !1), (f.lanes = 4194304));
          }
        else {
          if (!M)
            if (((c = zd(b)), c !== null)) {
              if (
                ((f.flags |= 128),
                (M = !0),
                (c = c.updateQueue),
                c !== null && ((f.updateQueue = c), (f.flags |= 4)),
                lf(w, !0),
                w.tail === null &&
                  w.tailMode === "hidden" &&
                  !b.alternate &&
                  !Zt)
              )
                return ar(f), null;
            } else
              2 * Vn() - w.renderingStartTime > j_ &&
                v !== 1073741824 &&
                ((f.flags |= 128), (M = !0), lf(w, !1), (f.lanes = 4194304));
          w.isBackwards
            ? ((b.sibling = f.child), (f.child = b))
            : ((c = w.last),
              c !== null ? (c.sibling = b) : (f.child = b),
              (w.last = b));
        }
        return w.tail !== null
          ? ((f = w.tail),
            (w.rendering = f),
            (w.tail = f.sibling),
            (w.renderingStartTime = Vn()),
            (f.sibling = null),
            (c = tn.current),
            at(tn, M ? (c & 1) | 2 : c & 1),
            f)
          : (ar(f), null);
      case 22:
      case 23:
        return (
          Q_(),
          (M = f.memoizedState !== null),
          c !== null && (c.memoizedState !== null) !== M && (f.flags |= 8192),
          M && f.mode & 1
            ? ei & 1073741824 &&
              (ar(f), Ce && f.subtreeFlags & 6 && (f.flags |= 8192))
            : ar(f),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(o(156, f.tag));
  }
  var LD = a.ReactCurrentOwner,
    $r = !1;
  function Sr(c, f, v, M) {
    f.child = c === null ? TM(f, null, v, M) : Zl(f, c.child, v, M);
  }
  function eE(c, f, v, M, w) {
    v = v.render;
    var b = f.ref;
    return (
      Kl(f, w),
      (M = A_(c, f, v, M, b, w)),
      (v = M_()),
      c !== null && !$r
        ? ((f.updateQueue = c.updateQueue),
          (f.flags &= -2053),
          (c.lanes &= ~w),
          Xs(c, f, w))
        : (Zt && v && h_(f), (f.flags |= 1), Sr(c, f, M, w), f.child)
    );
  }
  function tE(c, f, v, M, w) {
    if (c === null) {
      var b = v.type;
      return typeof b == "function" &&
        !Z_(b) &&
        b.defaultProps === void 0 &&
        v.compare === null &&
        v.defaultProps === void 0
        ? ((f.tag = 15), (f.type = b), nE(c, f, b, M, w))
        : ((c = gp(v.type, null, M, f, f.mode, w)),
          (c.ref = f.ref),
          (c.return = f),
          (f.child = c));
    }
    if (((b = c.child), !(c.lanes & w))) {
      var H = b.memoizedProps;
      if (
        ((v = v.compare), (v = v !== null ? v : Bd), v(H, M) && c.ref === f.ref)
      )
        return Xs(c, f, w);
    }
    return (
      (f.flags |= 1),
      (c = Lo(b, M)),
      (c.ref = f.ref),
      (c.return = f),
      (f.child = c)
    );
  }
  function nE(c, f, v, M, w) {
    if (c !== null && Bd(c.memoizedProps, M) && c.ref === f.ref)
      if ((($r = !1), (c.lanes & w) !== 0)) c.flags & 131072 && ($r = !0);
      else return (f.lanes = c.lanes), Xs(c, f, w);
    return R_(c, f, v, M, w);
  }
  function rE(c, f, v) {
    var M = f.pendingProps,
      w = M.children,
      b = c !== null ? c.memoizedState : null;
    if (M.mode === "hidden")
      if (!(f.mode & 1))
        (f.memoizedState = { baseLanes: 0, cachePool: null }),
          at(nu, ei),
          (ei |= v);
      else if (v & 1073741824)
        (f.memoizedState = { baseLanes: 0, cachePool: null }),
          (M = b !== null ? b.baseLanes : v),
          at(nu, ei),
          (ei |= M);
      else
        return (
          (c = b !== null ? b.baseLanes | v : v),
          (f.lanes = f.childLanes = 1073741824),
          (f.memoizedState = { baseLanes: c, cachePool: null }),
          (f.updateQueue = null),
          at(nu, ei),
          (ei |= c),
          null
        );
    else
      b !== null ? ((M = b.baseLanes | v), (f.memoizedState = null)) : (M = v),
        at(nu, ei),
        (ei |= M);
    return Sr(c, f, w, v), f.child;
  }
  function iE(c, f) {
    var v = f.ref;
    ((c === null && v !== null) || (c !== null && c.ref !== v)) &&
      ((f.flags |= 512), (f.flags |= 2097152));
  }
  function R_(c, f, v, M, w) {
    var b = fn(v) ? Vi : Dn.current;
    return (
      (b = cn(f, b)),
      Kl(f, w),
      (v = A_(c, f, v, M, b, w)),
      (M = M_()),
      c !== null && !$r
        ? ((f.updateQueue = c.updateQueue),
          (f.flags &= -2053),
          (c.lanes &= ~w),
          Xs(c, f, w))
        : (Zt && M && h_(f), (f.flags |= 1), Sr(c, f, v, w), f.child)
    );
  }
  function sE(c, f, v, M, w) {
    if (fn(v)) {
      var b = !0;
      Xl(f);
    } else b = !1;
    if ((Kl(f, w), f.stateNode === null))
      c !== null &&
        ((c.alternate = null), (f.alternate = null), (f.flags |= 2)),
        yM(f, v, M),
        f_(f, v, M, w),
        (M = !0);
    else if (c === null) {
      var H = f.stateNode,
        $ = f.memoizedProps;
      H.props = $;
      var le = H.context,
        Ee = v.contextType;
      typeof Ee == "object" && Ee !== null
        ? (Ee = gi(Ee))
        : ((Ee = fn(v) ? Vi : Dn.current), (Ee = cn(f, Ee)));
      var He = v.getDerivedStateFromProps,
        ct =
          typeof He == "function" ||
          typeof H.getSnapshotBeforeUpdate == "function";
      ct ||
        (typeof H.UNSAFE_componentWillReceiveProps != "function" &&
          typeof H.componentWillReceiveProps != "function") ||
        (($ !== M || le !== Ee) && xM(f, H, M, Ee)),
        (Co = !1);
      var et = f.memoizedState;
      (H.state = et),
        Fd(f, M, H, w),
        (le = f.memoizedState),
        $ !== M || et !== le || wn.current || Co
          ? (typeof He == "function" &&
              (c_(f, v, He, M), (le = f.memoizedState)),
            ($ = Co || vM(f, v, $, M, et, le, Ee))
              ? (ct ||
                  (typeof H.UNSAFE_componentWillMount != "function" &&
                    typeof H.componentWillMount != "function") ||
                  (typeof H.componentWillMount == "function" &&
                    H.componentWillMount(),
                  typeof H.UNSAFE_componentWillMount == "function" &&
                    H.UNSAFE_componentWillMount()),
                typeof H.componentDidMount == "function" &&
                  (f.flags |= 4194308))
              : (typeof H.componentDidMount == "function" &&
                  (f.flags |= 4194308),
                (f.memoizedProps = M),
                (f.memoizedState = le)),
            (H.props = M),
            (H.state = le),
            (H.context = Ee),
            (M = $))
          : (typeof H.componentDidMount == "function" && (f.flags |= 4194308),
            (M = !1));
    } else {
      (H = f.stateNode),
        pM(c, f),
        ($ = f.memoizedProps),
        (Ee = f.type === f.elementType ? $ : ji(f.type, $)),
        (H.props = Ee),
        (ct = f.pendingProps),
        (et = H.context),
        (le = v.contextType),
        typeof le == "object" && le !== null
          ? (le = gi(le))
          : ((le = fn(v) ? Vi : Dn.current), (le = cn(f, le)));
      var zt = v.getDerivedStateFromProps;
      (He =
        typeof zt == "function" ||
        typeof H.getSnapshotBeforeUpdate == "function") ||
        (typeof H.UNSAFE_componentWillReceiveProps != "function" &&
          typeof H.componentWillReceiveProps != "function") ||
        (($ !== ct || et !== le) && xM(f, H, M, le)),
        (Co = !1),
        (et = f.memoizedState),
        (H.state = et),
        Fd(f, M, H, w);
      var Ye = f.memoizedState;
      $ !== ct || et !== Ye || wn.current || Co
        ? (typeof zt == "function" && (c_(f, v, zt, M), (Ye = f.memoizedState)),
          (Ee = Co || vM(f, v, Ee, M, et, Ye, le) || !1)
            ? (He ||
                (typeof H.UNSAFE_componentWillUpdate != "function" &&
                  typeof H.componentWillUpdate != "function") ||
                (typeof H.componentWillUpdate == "function" &&
                  H.componentWillUpdate(M, Ye, le),
                typeof H.UNSAFE_componentWillUpdate == "function" &&
                  H.UNSAFE_componentWillUpdate(M, Ye, le)),
              typeof H.componentDidUpdate == "function" && (f.flags |= 4),
              typeof H.getSnapshotBeforeUpdate == "function" &&
                (f.flags |= 1024))
            : (typeof H.componentDidUpdate != "function" ||
                ($ === c.memoizedProps && et === c.memoizedState) ||
                (f.flags |= 4),
              typeof H.getSnapshotBeforeUpdate != "function" ||
                ($ === c.memoizedProps && et === c.memoizedState) ||
                (f.flags |= 1024),
              (f.memoizedProps = M),
              (f.memoizedState = Ye)),
          (H.props = M),
          (H.state = Ye),
          (H.context = le),
          (M = Ee))
        : (typeof H.componentDidUpdate != "function" ||
            ($ === c.memoizedProps && et === c.memoizedState) ||
            (f.flags |= 4),
          typeof H.getSnapshotBeforeUpdate != "function" ||
            ($ === c.memoizedProps && et === c.memoizedState) ||
            (f.flags |= 1024),
          (M = !1));
    }
    return P_(c, f, v, M, b, w);
  }
  function P_(c, f, v, M, w, b) {
    iE(c, f);
    var H = (f.flags & 128) !== 0;
    if (!M && !H) return w && Jc(f, v, !1), Xs(c, f, b);
    (M = f.stateNode), (LD.current = f);
    var $ =
      H && typeof v.getDerivedStateFromError != "function" ? null : M.render();
    return (
      (f.flags |= 1),
      c !== null && H
        ? ((f.child = Zl(f, c.child, null, b)), (f.child = Zl(f, null, $, b)))
        : Sr(c, f, $, b),
      (f.memoizedState = M.state),
      w && Jc(f, v, !0),
      f.child
    );
  }
  function oE(c) {
    var f = c.stateNode;
    f.pendingContext
      ? ir(c, f.pendingContext, f.pendingContext !== f.context)
      : f.context && ir(c, f.context, !1),
      __(c, f.containerInfo);
  }
  function aE(c, f, v, M, w) {
    return ql(), g_(w), (f.flags |= 256), Sr(c, f, v, M), f.child;
  }
  var Qd = { dehydrated: null, treeContext: null, retryLane: 0 };
  function qd(c) {
    return { baseLanes: c, cachePool: null };
  }
  function lE(c, f, v) {
    var M = f.pendingProps,
      w = tn.current,
      b = !1,
      H = (f.flags & 128) !== 0,
      $;
    if (
      (($ = H) ||
        ($ = c !== null && c.memoizedState === null ? !1 : (w & 2) !== 0),
      $
        ? ((b = !0), (f.flags &= -129))
        : (c === null || c.memoizedState !== null) && (w |= 1),
      at(tn, w & 1),
      c === null)
    )
      return (
        m_(f),
        (c = f.memoizedState),
        c !== null && ((c = c.dehydrated), c !== null)
          ? (f.mode & 1
              ? Eo(c)
                ? (f.lanes = 8)
                : (f.lanes = 1073741824)
              : (f.lanes = 1),
            null)
          : ((w = M.children),
            (c = M.fallback),
            b
              ? ((M = f.mode),
                (b = f.child),
                (w = { mode: "hidden", children: w }),
                !(M & 1) && b !== null
                  ? ((b.childLanes = 0), (b.pendingProps = w))
                  : (b = _p(w, M, 0, null)),
                (c = Ha(c, M, v, null)),
                (b.return = f),
                (c.return = f),
                (b.sibling = c),
                (f.child = b),
                (f.child.memoizedState = qd(v)),
                (f.memoizedState = Qd),
                c)
              : B_(f, w))
      );
    if (((w = c.memoizedState), w !== null)) {
      if ((($ = w.dehydrated), $ !== null)) {
        if (H)
          return f.flags & 256
            ? ((f.flags &= -257), Zd(c, f, v, Error(o(422))))
            : f.memoizedState !== null
            ? ((f.child = c.child), (f.flags |= 128), null)
            : ((b = M.fallback),
              (w = f.mode),
              (M = _p({ mode: "visible", children: M.children }, w, 0, null)),
              (b = Ha(b, w, v, null)),
              (b.flags |= 2),
              (M.return = f),
              (b.return = f),
              (M.sibling = b),
              (f.child = M),
              f.mode & 1 && Zl(f, c.child, null, v),
              (f.child.memoizedState = qd(v)),
              (f.memoizedState = Qd),
              b);
        if (!(f.mode & 1)) f = Zd(c, f, v, null);
        else if (Eo($)) f = Zd(c, f, v, Error(o(419)));
        else if (((M = (v & c.childLanes) !== 0), $r || M)) {
          if (((M = Cn), M !== null)) {
            switch (v & -v) {
              case 4:
                b = 2;
                break;
              case 16:
                b = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                b = 32;
                break;
              case 536870912:
                b = 268435456;
                break;
              default:
                b = 0;
            }
            (M = b & (M.suspendedLanes | v) ? 0 : b),
              M !== 0 && M !== w.retryLane && ((w.retryLane = M), Si(c, M, -1));
          }
          q_(), (f = Zd(c, f, v, Error(o(421))));
        } else
          Md($)
            ? ((f.flags |= 128),
              (f.child = c.child),
              (f = jD.bind(null, c)),
              Ed($, f),
              (f = null))
            : ((v = w.treeContext),
              _e &&
                ((Zr = Q0($)),
                (qr = f),
                (Zt = !0),
                (Xi = null),
                (Qc = !1),
                v !== null &&
                  ((_i[vi++] = Vs),
                  (_i[vi++] = Ws),
                  (_i[vi++] = Ia),
                  (Vs = v.id),
                  (Ws = v.overflow),
                  (Ia = f))),
              (f = B_(f, f.pendingProps.children)),
              (f.flags |= 4096));
        return f;
      }
      return b
        ? ((M = cE(c, f, M.children, M.fallback, v)),
          (b = f.child),
          (w = c.child.memoizedState),
          (b.memoizedState =
            w === null
              ? qd(v)
              : { baseLanes: w.baseLanes | v, cachePool: null }),
          (b.childLanes = c.childLanes & ~v),
          (f.memoizedState = Qd),
          M)
        : ((v = uE(c, f, M.children, v)), (f.memoizedState = null), v);
    }
    return b
      ? ((M = cE(c, f, M.children, M.fallback, v)),
        (b = f.child),
        (w = c.child.memoizedState),
        (b.memoizedState =
          w === null ? qd(v) : { baseLanes: w.baseLanes | v, cachePool: null }),
        (b.childLanes = c.childLanes & ~v),
        (f.memoizedState = Qd),
        M)
      : ((v = uE(c, f, M.children, v)), (f.memoizedState = null), v);
  }
  function B_(c, f) {
    return (
      (f = _p({ mode: "visible", children: f }, c.mode, 0, null)),
      (f.return = c),
      (c.child = f)
    );
  }
  function uE(c, f, v, M) {
    var w = c.child;
    return (
      (c = w.sibling),
      (v = Lo(w, { mode: "visible", children: v })),
      !(f.mode & 1) && (v.lanes = M),
      (v.return = f),
      (v.sibling = null),
      c !== null &&
        ((M = f.deletions),
        M === null ? ((f.deletions = [c]), (f.flags |= 16)) : M.push(c)),
      (f.child = v)
    );
  }
  function cE(c, f, v, M, w) {
    var b = f.mode;
    c = c.child;
    var H = c.sibling,
      $ = { mode: "hidden", children: v };
    return (
      !(b & 1) && f.child !== c
        ? ((v = f.child),
          (v.childLanes = 0),
          (v.pendingProps = $),
          (f.deletions = null))
        : ((v = Lo(c, $)), (v.subtreeFlags = c.subtreeFlags & 14680064)),
      H !== null ? (M = Lo(H, M)) : ((M = Ha(M, b, w, null)), (M.flags |= 2)),
      (M.return = f),
      (v.return = f),
      (v.sibling = M),
      (f.child = v),
      M
    );
  }
  function Zd(c, f, v, M) {
    return (
      M !== null && g_(M),
      Zl(f, c.child, null, v),
      (c = B_(f, f.pendingProps.children)),
      (c.flags |= 2),
      (f.memoizedState = null),
      c
    );
  }
  function fE(c, f, v) {
    c.lanes |= f;
    var M = c.alternate;
    M !== null && (M.lanes |= f), l_(c.return, f, v);
  }
  function L_(c, f, v, M, w) {
    var b = c.memoizedState;
    b === null
      ? (c.memoizedState = {
          isBackwards: f,
          rendering: null,
          renderingStartTime: 0,
          last: M,
          tail: v,
          tailMode: w,
        })
      : ((b.isBackwards = f),
        (b.rendering = null),
        (b.renderingStartTime = 0),
        (b.last = M),
        (b.tail = v),
        (b.tailMode = w));
  }
  function hE(c, f, v) {
    var M = f.pendingProps,
      w = M.revealOrder,
      b = M.tail;
    if ((Sr(c, f, M.children, v), (M = tn.current), M & 2))
      (M = (M & 1) | 2), (f.flags |= 128);
    else {
      if (c !== null && c.flags & 128)
        e: for (c = f.child; c !== null; ) {
          if (c.tag === 13) c.memoizedState !== null && fE(c, v, f);
          else if (c.tag === 19) fE(c, v, f);
          else if (c.child !== null) {
            (c.child.return = c), (c = c.child);
            continue;
          }
          if (c === f) break e;
          for (; c.sibling === null; ) {
            if (c.return === null || c.return === f) break e;
            c = c.return;
          }
          (c.sibling.return = c.return), (c = c.sibling);
        }
      M &= 1;
    }
    if ((at(tn, M), !(f.mode & 1))) f.memoizedState = null;
    else
      switch (w) {
        case "forwards":
          for (v = f.child, w = null; v !== null; )
            (c = v.alternate),
              c !== null && zd(c) === null && (w = v),
              (v = v.sibling);
          (v = w),
            v === null
              ? ((w = f.child), (f.child = null))
              : ((w = v.sibling), (v.sibling = null)),
            L_(f, !1, w, v, b);
          break;
        case "backwards":
          for (v = null, w = f.child, f.child = null; w !== null; ) {
            if (((c = w.alternate), c !== null && zd(c) === null)) {
              f.child = w;
              break;
            }
            (c = w.sibling), (w.sibling = v), (v = w), (w = c);
          }
          L_(f, !0, v, null, b);
          break;
        case "together":
          L_(f, !1, null, null, void 0);
          break;
        default:
          f.memoizedState = null;
      }
    return f.child;
  }
  function Xs(c, f, v) {
    if (
      (c !== null && (f.dependencies = c.dependencies),
      (ru |= f.lanes),
      !(v & f.childLanes))
    )
      return null;
    if (c !== null && f.child !== c.child) throw Error(o(153));
    if (f.child !== null) {
      for (
        c = f.child, v = Lo(c, c.pendingProps), f.child = v, v.return = f;
        c.sibling !== null;

      )
        (c = c.sibling),
          (v = v.sibling = Lo(c, c.pendingProps)),
          (v.return = f);
      v.sibling = null;
    }
    return f.child;
  }
  function ID(c, f, v) {
    switch (f.tag) {
      case 3:
        oE(f), ql();
        break;
      case 5:
        bM(f);
        break;
      case 1:
        fn(f.type) && Xl(f);
        break;
      case 4:
        __(f, f.stateNode.containerInfo);
        break;
      case 10:
        dM(f, f.type._context, f.memoizedProps.value);
        break;
      case 13:
        var M = f.memoizedState;
        if (M !== null)
          return M.dehydrated !== null
            ? (at(tn, tn.current & 1), (f.flags |= 128), null)
            : v & f.child.childLanes
            ? lE(c, f, v)
            : (at(tn, tn.current & 1),
              (c = Xs(c, f, v)),
              c !== null ? c.sibling : null);
        at(tn, tn.current & 1);
        break;
      case 19:
        if (((M = (v & f.childLanes) !== 0), c.flags & 128)) {
          if (M) return hE(c, f, v);
          f.flags |= 128;
        }
        var w = f.memoizedState;
        if (
          (w !== null &&
            ((w.rendering = null), (w.tail = null), (w.lastEffect = null)),
          at(tn, tn.current),
          M)
        )
          break;
        return null;
      case 22:
      case 23:
        return (f.lanes = 0), rE(c, f, v);
    }
    return Xs(c, f, v);
  }
  function DD(c, f) {
    switch ((d_(f), f.tag)) {
      case 1:
        return (
          fn(f.type) && wo(),
          (c = f.flags),
          c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null
        );
      case 3:
        return (
          eu(),
          Ft(wn),
          Ft(Dn),
          x_(),
          (c = f.flags),
          c & 65536 && !(c & 128) ? ((f.flags = (c & -65537) | 128), f) : null
        );
      case 5:
        return v_(f), null;
      case 13:
        if (
          (Ft(tn), (c = f.memoizedState), c !== null && c.dehydrated !== null)
        ) {
          if (f.alternate === null) throw Error(o(340));
          ql();
        }
        return (
          (c = f.flags), c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null
        );
      case 19:
        return Ft(tn), null;
      case 4:
        return eu(), null;
      case 10:
        return a_(f.type._context), null;
      case 22:
      case 23:
        return Q_(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var $d = !1,
    Na = !1,
    FD = typeof WeakSet == "function" ? WeakSet : Set,
    Ie = null;
  function ep(c, f) {
    var v = c.ref;
    if (v !== null)
      if (typeof v == "function")
        try {
          v(null);
        } catch (M) {
          Lr(c, f, M);
        }
      else v.current = null;
  }
  function I_(c, f, v) {
    try {
      v();
    } catch (M) {
      Lr(c, f, M);
    }
  }
  var dE = !1;
  function ND(c, f) {
    for (W(c.containerInfo), Ie = f; Ie !== null; )
      if (
        ((c = Ie), (f = c.child), (c.subtreeFlags & 1028) !== 0 && f !== null)
      )
        (f.return = c), (Ie = f);
      else
        for (; Ie !== null; ) {
          c = Ie;
          try {
            var v = c.alternate;
            if (c.flags & 1024)
              switch (c.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (v !== null) {
                    var M = v.memoizedProps,
                      w = v.memoizedState,
                      b = c.stateNode,
                      H = b.getSnapshotBeforeUpdate(
                        c.elementType === c.type ? M : ji(c.type, M),
                        w
                      );
                    b.__reactInternalSnapshotBeforeUpdate = H;
                  }
                  break;
                case 3:
                  Ce && Te(c.stateNode.containerInfo);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(o(163));
              }
          } catch ($) {
            Lr(c, c.return, $);
          }
          if (((f = c.sibling), f !== null)) {
            (f.return = c.return), (Ie = f);
            break;
          }
          Ie = c.return;
        }
    return (v = dE), (dE = !1), v;
  }
  function Oa(c, f, v) {
    var M = f.updateQueue;
    if (((M = M !== null ? M.lastEffect : null), M !== null)) {
      var w = (M = M.next);
      do {
        if ((w.tag & c) === c) {
          var b = w.destroy;
          (w.destroy = void 0), b !== void 0 && I_(f, v, b);
        }
        w = w.next;
      } while (w !== M);
    }
  }
  function uf(c, f) {
    if (
      ((f = f.updateQueue), (f = f !== null ? f.lastEffect : null), f !== null)
    ) {
      var v = (f = f.next);
      do {
        if ((v.tag & c) === c) {
          var M = v.create;
          v.destroy = M();
        }
        v = v.next;
      } while (v !== f);
    }
  }
  function D_(c) {
    var f = c.ref;
    if (f !== null) {
      var v = c.stateNode;
      switch (c.tag) {
        case 5:
          c = Z(v);
          break;
        default:
          c = v;
      }
      typeof f == "function" ? f(c) : (f.current = c);
    }
  }
  function pE(c, f, v) {
    if (ps && typeof ps.onCommitFiberUnmount == "function")
      try {
        ps.onCommitFiberUnmount(Rd, f);
      } catch {}
    switch (f.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          ((c = f.updateQueue), c !== null && ((c = c.lastEffect), c !== null))
        ) {
          var M = (c = c.next);
          do {
            var w = M,
              b = w.destroy;
            (w = w.tag),
              b !== void 0 && (w & 2 || w & 4) && I_(f, v, b),
              (M = M.next);
          } while (M !== c);
        }
        break;
      case 1:
        if (
          (ep(f, v),
          (c = f.stateNode),
          typeof c.componentWillUnmount == "function")
        )
          try {
            (c.props = f.memoizedProps),
              (c.state = f.memoizedState),
              c.componentWillUnmount();
          } catch (H) {
            Lr(f, v, H);
          }
        break;
      case 5:
        ep(f, v);
        break;
      case 4:
        Ce
          ? xE(c, f, v)
          : K && K && ((f = f.stateNode.containerInfo), (v = Et(f)), Jr(f, v));
    }
  }
  function mE(c, f, v) {
    for (var M = f; ; )
      if ((pE(c, M, v), M.child === null || (Ce && M.tag === 4))) {
        if (M === f) break;
        for (; M.sibling === null; ) {
          if (M.return === null || M.return === f) return;
          M = M.return;
        }
        (M.sibling.return = M.return), (M = M.sibling);
      } else (M.child.return = M), (M = M.child);
  }
  function gE(c) {
    var f = c.alternate;
    f !== null && ((c.alternate = null), gE(f)),
      (c.child = null),
      (c.deletions = null),
      (c.sibling = null),
      c.tag === 5 && ((f = c.stateNode), f !== null && Ge(f)),
      (c.stateNode = null),
      (c.return = null),
      (c.dependencies = null),
      (c.memoizedProps = null),
      (c.memoizedState = null),
      (c.pendingProps = null),
      (c.stateNode = null),
      (c.updateQueue = null);
  }
  function _E(c) {
    return c.tag === 5 || c.tag === 3 || c.tag === 4;
  }
  function vE(c) {
    e: for (;;) {
      for (; c.sibling === null; ) {
        if (c.return === null || _E(c.return)) return null;
        c = c.return;
      }
      for (
        c.sibling.return = c.return, c = c.sibling;
        c.tag !== 5 && c.tag !== 6 && c.tag !== 18;

      ) {
        if (c.flags & 2 || c.child === null || c.tag === 4) continue e;
        (c.child.return = c), (c = c.child);
      }
      if (!(c.flags & 2)) return c.stateNode;
    }
  }
  function yE(c) {
    if (Ce) {
      e: {
        for (var f = c.return; f !== null; ) {
          if (_E(f)) break e;
          f = f.return;
        }
        throw Error(o(160));
      }
      var v = f;
      switch (v.tag) {
        case 5:
          (f = v.stateNode),
            v.flags & 32 && (mt(f), (v.flags &= -33)),
            (v = vE(c)),
            N_(c, v, f);
          break;
        case 3:
        case 4:
          (f = v.stateNode.containerInfo), (v = vE(c)), F_(c, v, f);
          break;
        default:
          throw Error(o(161));
      }
    }
  }
  function F_(c, f, v) {
    var M = c.tag;
    if (M === 5 || M === 6) (c = c.stateNode), f ? tt(v, c, f) : Je(v, c);
    else if (M !== 4 && ((c = c.child), c !== null))
      for (F_(c, f, v), c = c.sibling; c !== null; )
        F_(c, f, v), (c = c.sibling);
  }
  function N_(c, f, v) {
    var M = c.tag;
    if (M === 5 || M === 6) (c = c.stateNode), f ? Ze(v, c, f) : Re(v, c);
    else if (M !== 4 && ((c = c.child), c !== null))
      for (N_(c, f, v), c = c.sibling; c !== null; )
        N_(c, f, v), (c = c.sibling);
  }
  function xE(c, f, v) {
    for (var M = f, w = !1, b, H; ; ) {
      if (!w) {
        w = M.return;
        e: for (;;) {
          if (w === null) throw Error(o(160));
          switch (((b = w.stateNode), w.tag)) {
            case 5:
              H = !1;
              break e;
            case 3:
              (b = b.containerInfo), (H = !0);
              break e;
            case 4:
              (b = b.containerInfo), (H = !0);
              break e;
          }
          w = w.return;
        }
        w = !0;
      }
      if (M.tag === 5 || M.tag === 6)
        mE(c, M, v), H ? We(b, M.stateNode) : Ve(b, M.stateNode);
      else if (M.tag === 18) H ? $e(b, M.stateNode) : ze(b, M.stateNode);
      else if (M.tag === 4) {
        if (M.child !== null) {
          (b = M.stateNode.containerInfo),
            (H = !0),
            (M.child.return = M),
            (M = M.child);
          continue;
        }
      } else if ((pE(c, M, v), M.child !== null)) {
        (M.child.return = M), (M = M.child);
        continue;
      }
      if (M === f) break;
      for (; M.sibling === null; ) {
        if (M.return === null || M.return === f) return;
        (M = M.return), M.tag === 4 && (w = !1);
      }
      (M.sibling.return = M.return), (M = M.sibling);
    }
  }
  function O_(c, f) {
    if (Ce) {
      switch (f.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Oa(3, f, f.return), uf(3, f), Oa(5, f, f.return);
          return;
        case 1:
          return;
        case 5:
          var v = f.stateNode;
          if (v != null) {
            var M = f.memoizedProps;
            c = c !== null ? c.memoizedProps : M;
            var w = f.type,
              b = f.updateQueue;
            (f.updateQueue = null), b !== null && qe(v, b, w, c, M, f);
          }
          return;
        case 6:
          if (f.stateNode === null) throw Error(o(162));
          (v = f.memoizedProps),
            Pe(f.stateNode, c !== null ? c.memoizedProps : v, v);
          return;
        case 3:
          _e &&
            c !== null &&
            c.memoizedState.isDehydrated &&
            ne(f.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          tp(f);
          return;
        case 19:
          tp(f);
          return;
        case 17:
          return;
      }
      throw Error(o(163));
    }
    switch (f.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Oa(3, f, f.return), uf(3, f), Oa(5, f, f.return);
        return;
      case 12:
        return;
      case 13:
        tp(f);
        return;
      case 19:
        tp(f);
        return;
      case 3:
        _e &&
          c !== null &&
          c.memoizedState.isDehydrated &&
          ne(f.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e: if (K) {
      switch (f.tag) {
        case 1:
        case 5:
        case 6:
          break e;
        case 3:
        case 4:
          (f = f.stateNode), Jr(f.containerInfo, f.pendingChildren);
          break e;
      }
      throw Error(o(163));
    }
  }
  function tp(c) {
    var f = c.updateQueue;
    if (f !== null) {
      c.updateQueue = null;
      var v = c.stateNode;
      v === null && (v = c.stateNode = new FD()),
        f.forEach(function (M) {
          var w = XD.bind(null, c, M);
          v.has(M) || (v.add(M), M.then(w, w));
        });
    }
  }
  function OD(c, f) {
    for (Ie = f; Ie !== null; ) {
      f = Ie;
      var v = f.deletions;
      if (v !== null)
        for (var M = 0; M < v.length; M++) {
          var w = v[M];
          try {
            var b = c;
            Ce ? xE(b, w, f) : mE(b, w, f);
            var H = w.alternate;
            H !== null && (H.return = null), (w.return = null);
          } catch (Ke) {
            Lr(w, f, Ke);
          }
        }
      if (((v = f.child), f.subtreeFlags & 12854 && v !== null))
        (v.return = f), (Ie = v);
      else
        for (; Ie !== null; ) {
          f = Ie;
          try {
            var $ = f.flags;
            if (($ & 32 && Ce && mt(f.stateNode), $ & 512)) {
              var le = f.alternate;
              if (le !== null) {
                var Ee = le.ref;
                Ee !== null &&
                  (typeof Ee == "function" ? Ee(null) : (Ee.current = null));
              }
            }
            if ($ & 8192)
              switch (f.tag) {
                case 13:
                  if (f.memoizedState !== null) {
                    var He = f.alternate;
                    (He === null || He.memoizedState === null) && (W_ = Vn());
                  }
                  break;
                case 22:
                  var ct = f.memoizedState !== null,
                    et = f.alternate,
                    zt = et !== null && et.memoizedState !== null;
                  if (((v = f), Ce)) {
                    e: if (((M = v), (w = ct), (b = null), Ce))
                      for (var Ye = M; ; ) {
                        if (Ye.tag === 5) {
                          if (b === null) {
                            b = Ye;
                            var lr = Ye.stateNode;
                            w ? Ut(lr) : Le(Ye.stateNode, Ye.memoizedProps);
                          }
                        } else if (Ye.tag === 6) {
                          if (b === null) {
                            var Mi = Ye.stateNode;
                            w ? q(Mi) : oe(Mi, Ye.memoizedProps);
                          }
                        } else if (
                          ((Ye.tag !== 22 && Ye.tag !== 23) ||
                            Ye.memoizedState === null ||
                            Ye === M) &&
                          Ye.child !== null
                        ) {
                          (Ye.child.return = Ye), (Ye = Ye.child);
                          continue;
                        }
                        if (Ye === M) break;
                        for (; Ye.sibling === null; ) {
                          if (Ye.return === null || Ye.return === M) break e;
                          b === Ye && (b = null), (Ye = Ye.return);
                        }
                        b === Ye && (b = null),
                          (Ye.sibling.return = Ye.return),
                          (Ye = Ye.sibling);
                      }
                  }
                  if (ct && !zt && v.mode & 1) {
                    Ie = v;
                    for (var re = v.child; re !== null; ) {
                      for (v = Ie = re; Ie !== null; ) {
                        M = Ie;
                        var ee = M.child;
                        switch (M.tag) {
                          case 0:
                          case 11:
                          case 14:
                          case 15:
                            Oa(4, M, M.return);
                            break;
                          case 1:
                            ep(M, M.return);
                            var se = M.stateNode;
                            if (typeof se.componentWillUnmount == "function") {
                              var Fe = M.return;
                              try {
                                (se.props = M.memoizedProps),
                                  (se.state = M.memoizedState),
                                  se.componentWillUnmount();
                              } catch (Ke) {
                                Lr(M, Fe, Ke);
                              }
                            }
                            break;
                          case 5:
                            ep(M, M.return);
                            break;
                          case 22:
                            if (M.memoizedState !== null) {
                              ME(v);
                              continue;
                            }
                        }
                        ee !== null ? ((ee.return = M), (Ie = ee)) : ME(v);
                      }
                      re = re.sibling;
                    }
                  }
              }
            switch ($ & 4102) {
              case 2:
                yE(f), (f.flags &= -3);
                break;
              case 6:
                yE(f), (f.flags &= -3), O_(f.alternate, f);
                break;
              case 4096:
                f.flags &= -4097;
                break;
              case 4100:
                (f.flags &= -4097), O_(f.alternate, f);
                break;
              case 4:
                O_(f.alternate, f);
            }
          } catch (Ke) {
            Lr(f, f.return, Ke);
          }
          if (((v = f.sibling), v !== null)) {
            (v.return = f.return), (Ie = v);
            break;
          }
          Ie = f.return;
        }
    }
  }
  function UD(c, f, v) {
    (Ie = c), SE(c);
  }
  function SE(c, f, v) {
    for (var M = (c.mode & 1) !== 0; Ie !== null; ) {
      var w = Ie,
        b = w.child;
      if (w.tag === 22 && M) {
        var H = w.memoizedState !== null || $d;
        if (!H) {
          var $ = w.alternate,
            le = ($ !== null && $.memoizedState !== null) || Na;
          $ = $d;
          var Ee = Na;
          if ((($d = H), (Na = le) && !Ee))
            for (Ie = w; Ie !== null; )
              (H = Ie),
                (le = H.child),
                H.tag === 22 && H.memoizedState !== null
                  ? EE(w)
                  : le !== null
                  ? ((le.return = H), (Ie = le))
                  : EE(w);
          for (; b !== null; ) (Ie = b), SE(b), (b = b.sibling);
          (Ie = w), ($d = $), (Na = Ee);
        }
        AE(c);
      } else
        w.subtreeFlags & 8772 && b !== null
          ? ((b.return = w), (Ie = b))
          : AE(c);
    }
  }
  function AE(c) {
    for (; Ie !== null; ) {
      var f = Ie;
      if (f.flags & 8772) {
        var v = f.alternate;
        try {
          if (f.flags & 8772)
            switch (f.tag) {
              case 0:
              case 11:
              case 15:
                Na || uf(5, f);
                break;
              case 1:
                var M = f.stateNode;
                if (f.flags & 4 && !Na)
                  if (v === null) M.componentDidMount();
                  else {
                    var w =
                      f.elementType === f.type
                        ? v.memoizedProps
                        : ji(f.type, v.memoizedProps);
                    M.componentDidUpdate(
                      w,
                      v.memoizedState,
                      M.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var b = f.updateQueue;
                b !== null && gM(f, b, M);
                break;
              case 3:
                var H = f.updateQueue;
                if (H !== null) {
                  if (((v = null), f.child !== null))
                    switch (f.child.tag) {
                      case 5:
                        v = Z(f.child.stateNode);
                        break;
                      case 1:
                        v = f.child.stateNode;
                    }
                  gM(f, H, v);
                }
                break;
              case 5:
                var $ = f.stateNode;
                v === null && f.flags & 4 && he($, f.type, f.memoizedProps, f);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (_e && f.memoizedState === null) {
                  var le = f.alternate;
                  if (le !== null) {
                    var Ee = le.memoizedState;
                    if (Ee !== null) {
                      var He = Ee.dehydrated;
                      He !== null && fe(He);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(o(163));
            }
          Na || (f.flags & 512 && D_(f));
        } catch (ct) {
          Lr(f, f.return, ct);
        }
      }
      if (f === c) {
        Ie = null;
        break;
      }
      if (((v = f.sibling), v !== null)) {
        (v.return = f.return), (Ie = v);
        break;
      }
      Ie = f.return;
    }
  }
  function ME(c) {
    for (; Ie !== null; ) {
      var f = Ie;
      if (f === c) {
        Ie = null;
        break;
      }
      var v = f.sibling;
      if (v !== null) {
        (v.return = f.return), (Ie = v);
        break;
      }
      Ie = f.return;
    }
  }
  function EE(c) {
    for (; Ie !== null; ) {
      var f = Ie;
      try {
        switch (f.tag) {
          case 0:
          case 11:
          case 15:
            var v = f.return;
            try {
              uf(4, f);
            } catch (le) {
              Lr(f, v, le);
            }
            break;
          case 1:
            var M = f.stateNode;
            if (typeof M.componentDidMount == "function") {
              var w = f.return;
              try {
                M.componentDidMount();
              } catch (le) {
                Lr(f, w, le);
              }
            }
            var b = f.return;
            try {
              D_(f);
            } catch (le) {
              Lr(f, b, le);
            }
            break;
          case 5:
            var H = f.return;
            try {
              D_(f);
            } catch (le) {
              Lr(f, H, le);
            }
        }
      } catch (le) {
        Lr(f, f.return, le);
      }
      if (f === c) {
        Ie = null;
        break;
      }
      var $ = f.sibling;
      if ($ !== null) {
        ($.return = f.return), (Ie = $);
        break;
      }
      Ie = f.return;
    }
  }
  var np = 0,
    rp = 1,
    ip = 2,
    sp = 3,
    op = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var cf = Symbol.for;
    (np = cf("selector.component")),
      (rp = cf("selector.has_pseudo_class")),
      (ip = cf("selector.role")),
      (sp = cf("selector.test_id")),
      (op = cf("selector.text"));
  }
  function U_(c) {
    var f = pe(c);
    if (f != null) {
      if (typeof f.memoizedProps["data-testname"] != "string")
        throw Error(o(364));
      return f;
    }
    if (((c = yt(c)), c === null)) throw Error(o(362));
    return c.stateNode.current;
  }
  function k_(c, f) {
    switch (f.$$typeof) {
      case np:
        if (c.type === f.value) return !0;
        break;
      case rp:
        e: {
          (f = f.value), (c = [c, 0]);
          for (var v = 0; v < c.length; ) {
            var M = c[v++],
              w = c[v++],
              b = f[w];
            if (M.tag !== 5 || !O(M)) {
              for (; b != null && k_(M, b); ) w++, (b = f[w]);
              if (w === f.length) {
                f = !0;
                break e;
              } else
                for (M = M.child; M !== null; ) c.push(M, w), (M = M.sibling);
            }
          }
          f = !1;
        }
        return f;
      case ip:
        if (c.tag === 5 && ue(c.stateNode, f.value)) return !0;
        break;
      case op:
        if (
          (c.tag === 5 || c.tag === 6) &&
          ((c = V(c)), c !== null && 0 <= c.indexOf(f.value))
        )
          return !0;
        break;
      case sp:
        if (
          c.tag === 5 &&
          ((c = c.memoizedProps["data-testname"]),
          typeof c == "string" && c.toLowerCase() === f.value.toLowerCase())
        )
          return !0;
        break;
      default:
        throw Error(o(365));
    }
    return !1;
  }
  function z_(c) {
    switch (c.$$typeof) {
      case np:
        return "<" + (P(c.value) || "Unknown") + ">";
      case rp:
        return ":has(" + (z_(c) || "") + ")";
      case ip:
        return '[role="' + c.value + '"]';
      case op:
        return '"' + c.value + '"';
      case sp:
        return '[data-testname="' + c.value + '"]';
      default:
        throw Error(o(365));
    }
  }
  function wE(c, f) {
    var v = [];
    c = [c, 0];
    for (var M = 0; M < c.length; ) {
      var w = c[M++],
        b = c[M++],
        H = f[b];
      if (w.tag !== 5 || !O(w)) {
        for (; H != null && k_(w, H); ) b++, (H = f[b]);
        if (b === f.length) v.push(w);
        else for (w = w.child; w !== null; ) c.push(w, b), (w = w.sibling);
      }
    }
    return v;
  }
  function H_(c, f) {
    if (!Qe) throw Error(o(363));
    (c = U_(c)), (c = wE(c, f)), (f = []), (c = Array.from(c));
    for (var v = 0; v < c.length; ) {
      var M = c[v++];
      if (M.tag === 5) O(M) || f.push(M.stateNode);
      else for (M = M.child; M !== null; ) c.push(M), (M = M.sibling);
    }
    return f;
  }
  var kD = Math.ceil,
    ap = a.ReactCurrentDispatcher,
    G_ = a.ReactCurrentOwner,
    yn = a.ReactCurrentBatchConfig,
    St = 0,
    Cn = null,
    Tn = null,
    qn = 0,
    ei = 0,
    nu = ut(0),
    Fn = 0,
    ff = null,
    ru = 0,
    lp = 0,
    V_ = 0,
    hf = null,
    Pr = null,
    W_ = 0,
    j_ = 1 / 0;
  function iu() {
    j_ = Vn() + 500;
  }
  var up = !1,
    X_ = null,
    bo = null,
    cp = !1,
    Ro = null,
    fp = 0,
    df = 0,
    J_ = null,
    hp = -1,
    dp = 0;
  function Ar() {
    return St & 6 ? Vn() : hp !== -1 ? hp : (hp = Vn());
  }
  function Po(c) {
    return c.mode & 1
      ? St & 2 && qn !== 0
        ? qn & -qn
        : SD.transition !== null
        ? (dp === 0 &&
            ((c = Cd), (Cd <<= 1), !(Cd & 4194240) && (Cd = 64), (dp = c)),
          dp)
        : ((c = Bt), c !== 0 ? c : ve())
      : 1;
  }
  function Si(c, f, v) {
    if (50 < df) throw ((df = 0), (J_ = null), Error(o(185)));
    var M = pp(c, f);
    return M === null
      ? null
      : (Yc(M, f, v),
        (!(St & 2) || M !== Cn) &&
          (M === Cn && (!(St & 2) && (lp |= f), Fn === 4 && Bo(M, qn)),
          Br(M, v),
          f === 1 && St === 0 && !(c.mode & 1) && (iu(), Pd && gs())),
        M);
  }
  function pp(c, f) {
    c.lanes |= f;
    var v = c.alternate;
    for (v !== null && (v.lanes |= f), v = c, c = c.return; c !== null; )
      (c.childLanes |= f),
        (v = c.alternate),
        v !== null && (v.childLanes |= f),
        (v = c),
        (c = c.return);
    return v.tag === 3 ? v.stateNode : null;
  }
  function Br(c, f) {
    var v = c.callbackNode;
    hD(c, f);
    var M = bd(c, c === Cn ? qn : 0);
    if (M === 0)
      v !== null && fM(v), (c.callbackNode = null), (c.callbackPriority = 0);
    else if (((f = M & -M), c.callbackPriority !== f)) {
      if ((v != null && fM(v), f === 1))
        c.tag === 0 ? xD(TE.bind(null, c)) : hM(TE.bind(null, c)),
          Oe
            ? Ue(function () {
                St === 0 && gs();
              })
            : t_(n_, gs),
          (v = null);
      else {
        switch (cM(M)) {
          case 1:
            v = n_;
            break;
          case 4:
            v = gD;
            break;
          case 16:
            v = r_;
            break;
          case 536870912:
            v = _D;
            break;
          default:
            v = r_;
        }
        v = NE(v, CE.bind(null, c));
      }
      (c.callbackPriority = f), (c.callbackNode = v);
    }
  }
  function CE(c, f) {
    if (((hp = -1), (dp = 0), St & 6)) throw Error(o(327));
    var v = c.callbackNode;
    if (za() && c.callbackNode !== v) return null;
    var M = bd(c, c === Cn ? qn : 0);
    if (M === 0) return null;
    if (M & 30 || M & c.expiredLanes || f) f = mp(c, M);
    else {
      f = M;
      var w = St;
      St |= 2;
      var b = PE();
      (Cn !== c || qn !== f) && (iu(), Ua(c, f));
      do
        try {
          GD();
          break;
        } catch ($) {
          RE(c, $);
        }
      while (1);
      o_(),
        (ap.current = b),
        (St = w),
        Tn !== null ? (f = 0) : ((Cn = null), (qn = 0), (f = Fn));
    }
    if (f !== 0) {
      if (
        (f === 2 && ((w = Z0(c)), w !== 0 && ((M = w), (f = K_(c, w)))),
        f === 1)
      )
        throw ((v = ff), Ua(c, 0), Bo(c, M), Br(c, Vn()), v);
      if (f === 6) Bo(c, M);
      else {
        if (
          ((w = c.current.alternate),
          !(M & 30) &&
            !zD(w) &&
            ((f = mp(c, M)),
            f === 2 && ((b = Z0(c)), b !== 0 && ((M = b), (f = K_(c, b)))),
            f === 1))
        )
          throw ((v = ff), Ua(c, 0), Bo(c, M), Br(c, Vn()), v);
        switch (((c.finishedWork = w), (c.finishedLanes = M), f)) {
          case 0:
          case 1:
            throw Error(o(345));
          case 2:
            ka(c, Pr);
            break;
          case 3:
            if (
              (Bo(c, M),
              (M & 130023424) === M && ((f = W_ + 500 - Vn()), 10 < f))
            ) {
              if (bd(c, 0) !== 0) break;
              if (((w = c.suspendedLanes), (w & M) !== M)) {
                Ar(), (c.pingedLanes |= c.suspendedLanes & w);
                break;
              }
              c.timeoutHandle = Ne(ka.bind(null, c, Pr), f);
              break;
            }
            ka(c, Pr);
            break;
          case 4:
            if ((Bo(c, M), (M & 4194240) === M)) break;
            for (f = c.eventTimes, w = -1; 0 < M; ) {
              var H = 31 - Wi(M);
              (b = 1 << H), (H = f[H]), H > w && (w = H), (M &= ~b);
            }
            if (
              ((M = w),
              (M = Vn() - M),
              (M =
                (120 > M
                  ? 120
                  : 480 > M
                  ? 480
                  : 1080 > M
                  ? 1080
                  : 1920 > M
                  ? 1920
                  : 3e3 > M
                  ? 3e3
                  : 4320 > M
                  ? 4320
                  : 1960 * kD(M / 1960)) - M),
              10 < M)
            ) {
              c.timeoutHandle = Ne(ka.bind(null, c, Pr), M);
              break;
            }
            ka(c, Pr);
            break;
          case 5:
            ka(c, Pr);
            break;
          default:
            throw Error(o(329));
        }
      }
    }
    return Br(c, Vn()), c.callbackNode === v ? CE.bind(null, c) : null;
  }
  function K_(c, f) {
    var v = hf;
    return (
      c.current.memoizedState.isDehydrated && (Ua(c, f).flags |= 256),
      (c = mp(c, f)),
      c !== 2 && ((f = Pr), (Pr = v), f !== null && Y_(f)),
      c
    );
  }
  function Y_(c) {
    Pr === null ? (Pr = c) : Pr.push.apply(Pr, c);
  }
  function zD(c) {
    for (var f = c; ; ) {
      if (f.flags & 16384) {
        var v = f.updateQueue;
        if (v !== null && ((v = v.stores), v !== null))
          for (var M = 0; M < v.length; M++) {
            var w = v[M],
              b = w.getSnapshot;
            w = w.value;
            try {
              if (!ms(b(), w)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((v = f.child), f.subtreeFlags & 16384 && v !== null))
        (v.return = f), (f = v);
      else {
        if (f === c) break;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === c) return !0;
          f = f.return;
        }
        (f.sibling.return = f.return), (f = f.sibling);
      }
    }
    return !0;
  }
  function Bo(c, f) {
    for (
      f &= ~V_,
        f &= ~lp,
        c.suspendedLanes |= f,
        c.pingedLanes &= ~f,
        c = c.expirationTimes;
      0 < f;

    ) {
      var v = 31 - Wi(f),
        M = 1 << v;
      (c[v] = -1), (f &= ~M);
    }
  }
  function TE(c) {
    if (St & 6) throw Error(o(327));
    za();
    var f = bd(c, 0);
    if (!(f & 1)) return Br(c, Vn()), null;
    var v = mp(c, f);
    if (c.tag !== 0 && v === 2) {
      var M = Z0(c);
      M !== 0 && ((f = M), (v = K_(c, M)));
    }
    if (v === 1) throw ((v = ff), Ua(c, 0), Bo(c, f), Br(c, Vn()), v);
    if (v === 6) throw Error(o(345));
    return (
      (c.finishedWork = c.current.alternate),
      (c.finishedLanes = f),
      ka(c, Pr),
      Br(c, Vn()),
      null
    );
  }
  function bE(c) {
    Ro !== null && Ro.tag === 0 && !(St & 6) && za();
    var f = St;
    St |= 1;
    var v = yn.transition,
      M = Bt;
    try {
      if (((yn.transition = null), (Bt = 1), c)) return c();
    } finally {
      (Bt = M), (yn.transition = v), (St = f), !(St & 6) && gs();
    }
  }
  function Q_() {
    (ei = nu.current), Ft(nu);
  }
  function Ua(c, f) {
    (c.finishedWork = null), (c.finishedLanes = 0);
    var v = c.timeoutHandle;
    if ((v !== At && ((c.timeoutHandle = At), je(v)), Tn !== null))
      for (v = Tn.return; v !== null; ) {
        var M = v;
        switch ((d_(M), M.tag)) {
          case 1:
            (M = M.type.childContextTypes), M != null && wo();
            break;
          case 3:
            eu(), Ft(wn), Ft(Dn), x_();
            break;
          case 5:
            v_(M);
            break;
          case 4:
            eu();
            break;
          case 13:
            Ft(tn);
            break;
          case 19:
            Ft(tn);
            break;
          case 10:
            a_(M.type._context);
            break;
          case 22:
          case 23:
            Q_();
        }
        v = v.return;
      }
    if (
      ((Cn = c),
      (Tn = c = Lo(c.current, null)),
      (qn = ei = f),
      (Fn = 0),
      (ff = null),
      (V_ = lp = ru = 0),
      (Pr = hf = null),
      _s !== null)
    ) {
      for (f = 0; f < _s.length; f++)
        if (((v = _s[f]), (M = v.interleaved), M !== null)) {
          v.interleaved = null;
          var w = M.next,
            b = v.pending;
          if (b !== null) {
            var H = b.next;
            (b.next = w), (M.next = H);
          }
          v.pending = M;
        }
      _s = null;
    }
    return c;
  }
  function RE(c, f) {
    do {
      var v = Tn;
      try {
        if ((o_(), (Hd.current = Jd), Gd)) {
          for (var M = hn.memoizedState; M !== null; ) {
            var w = M.queue;
            w !== null && (w.pending = null), (M = M.next);
          }
          Gd = !1;
        }
        if (
          ((tu = 0),
          (Wn = sr = hn = null),
          (tf = !1),
          (nf = 0),
          (G_.current = null),
          v === null || v.return === null)
        ) {
          (Fn = 1), (ff = f), (Tn = null);
          break;
        }
        e: {
          var b = c,
            H = v.return,
            $ = v,
            le = f;
          if (
            ((f = qn),
            ($.flags |= 32768),
            le !== null &&
              typeof le == "object" &&
              typeof le.then == "function")
          ) {
            var Ee = le,
              He = $,
              ct = He.tag;
            if (!(He.mode & 1) && (ct === 0 || ct === 11 || ct === 15)) {
              var et = He.alternate;
              et
                ? ((He.updateQueue = et.updateQueue),
                  (He.memoizedState = et.memoizedState),
                  (He.lanes = et.lanes))
                : ((He.updateQueue = null), (He.memoizedState = null));
            }
            var zt = QM(H);
            if (zt !== null) {
              (zt.flags &= -257),
                qM(zt, H, $, b, f),
                zt.mode & 1 && YM(b, Ee, f),
                (f = zt),
                (le = Ee);
              var Ye = f.updateQueue;
              if (Ye === null) {
                var lr = new Set();
                lr.add(le), (f.updateQueue = lr);
              } else Ye.add(le);
              break e;
            } else {
              if (!(f & 1)) {
                YM(b, Ee, f), q_();
                break e;
              }
              le = Error(o(426));
            }
          } else if (Zt && $.mode & 1) {
            var Mi = QM(H);
            if (Mi !== null) {
              !(Mi.flags & 65536) && (Mi.flags |= 256),
                qM(Mi, H, $, b, f),
                g_(le);
              break e;
            }
          }
          (b = le),
            Fn !== 4 && (Fn = 2),
            hf === null ? (hf = [b]) : hf.push(b),
            (le = T_(le, $)),
            ($ = H);
          do {
            switch ($.tag) {
              case 3:
                ($.flags |= 65536), (f &= -f), ($.lanes |= f);
                var re = JM($, le, f);
                mM($, re);
                break e;
              case 1:
                b = le;
                var ee = $.type,
                  se = $.stateNode;
                if (
                  !($.flags & 128) &&
                  (typeof ee.getDerivedStateFromError == "function" ||
                    (se !== null &&
                      typeof se.componentDidCatch == "function" &&
                      (bo === null || !bo.has(se))))
                ) {
                  ($.flags |= 65536), (f &= -f), ($.lanes |= f);
                  var Fe = KM($, b, f);
                  mM($, Fe);
                  break e;
                }
            }
            $ = $.return;
          } while ($ !== null);
        }
        LE(v);
      } catch (Ke) {
        (f = Ke), Tn === v && v !== null && (Tn = v = v.return);
        continue;
      }
      break;
    } while (1);
  }
  function PE() {
    var c = ap.current;
    return (ap.current = Jd), c === null ? Jd : c;
  }
  function q_() {
    (Fn === 0 || Fn === 3 || Fn === 2) && (Fn = 4),
      Cn === null || (!(ru & 268435455) && !(lp & 268435455)) || Bo(Cn, qn);
  }
  function mp(c, f) {
    var v = St;
    St |= 2;
    var M = PE();
    (Cn === c && qn === f) || Ua(c, f);
    do
      try {
        HD();
        break;
      } catch (w) {
        RE(c, w);
      }
    while (1);
    if ((o_(), (St = v), (ap.current = M), Tn !== null)) throw Error(o(261));
    return (Cn = null), (qn = 0), Fn;
  }
  function HD() {
    for (; Tn !== null; ) BE(Tn);
  }
  function GD() {
    for (; Tn !== null && !pD(); ) BE(Tn);
  }
  function BE(c) {
    var f = FE(c.alternate, c, ei);
    (c.memoizedProps = c.pendingProps),
      f === null ? LE(c) : (Tn = f),
      (G_.current = null);
  }
  function LE(c) {
    var f = c;
    do {
      var v = f.alternate;
      if (((c = f.return), f.flags & 32768)) {
        if (((v = DD(v, f)), v !== null)) {
          (v.flags &= 32767), (Tn = v);
          return;
        }
        if (c !== null)
          (c.flags |= 32768), (c.subtreeFlags = 0), (c.deletions = null);
        else {
          (Fn = 6), (Tn = null);
          return;
        }
      } else if (((v = BD(v, f, ei)), v !== null)) {
        Tn = v;
        return;
      }
      if (((f = f.sibling), f !== null)) {
        Tn = f;
        return;
      }
      Tn = f = c;
    } while (f !== null);
    Fn === 0 && (Fn = 5);
  }
  function ka(c, f) {
    var v = Bt,
      M = yn.transition;
    try {
      (yn.transition = null), (Bt = 1), VD(c, f, v);
    } finally {
      (yn.transition = M), (Bt = v);
    }
    return null;
  }
  function VD(c, f, v) {
    do za();
    while (Ro !== null);
    if (St & 6) throw Error(o(327));
    var M = c.finishedWork,
      w = c.finishedLanes;
    if (M === null) return null;
    if (((c.finishedWork = null), (c.finishedLanes = 0), M === c.current))
      throw Error(o(177));
    (c.callbackNode = null), (c.callbackPriority = 0);
    var b = M.lanes | M.childLanes;
    if (
      (dD(c, b),
      c === Cn && ((Tn = Cn = null), (qn = 0)),
      (!(M.subtreeFlags & 2064) && !(M.flags & 2064)) ||
        cp ||
        ((cp = !0),
        NE(r_, function () {
          return za(), null;
        })),
      (b = (M.flags & 15990) !== 0),
      M.subtreeFlags & 15990 || b)
    ) {
      (b = yn.transition), (yn.transition = null);
      var H = Bt;
      Bt = 1;
      var $ = St;
      (St |= 4),
        (G_.current = null),
        ND(c, M),
        OD(c, M),
        G(c.containerInfo),
        (c.current = M),
        UD(M),
        mD(),
        (St = $),
        (Bt = H),
        (yn.transition = b);
    } else c.current = M;
    if (
      (cp && ((cp = !1), (Ro = c), (fp = w)),
      (b = c.pendingLanes),
      b === 0 && (bo = null),
      vD(M.stateNode),
      Br(c, Vn()),
      f !== null)
    )
      for (v = c.onRecoverableError, M = 0; M < f.length; M++) v(f[M]);
    if (up) throw ((up = !1), (c = X_), (X_ = null), c);
    return (
      fp & 1 && c.tag !== 0 && za(),
      (b = c.pendingLanes),
      b & 1 ? (c === J_ ? df++ : ((df = 0), (J_ = c))) : (df = 0),
      gs(),
      null
    );
  }
  function za() {
    if (Ro !== null) {
      var c = cM(fp),
        f = yn.transition,
        v = Bt;
      try {
        if (((yn.transition = null), (Bt = 16 > c ? 16 : c), Ro === null))
          var M = !1;
        else {
          if (((c = Ro), (Ro = null), (fp = 0), St & 6)) throw Error(o(331));
          var w = St;
          for (St |= 4, Ie = c.current; Ie !== null; ) {
            var b = Ie,
              H = b.child;
            if (Ie.flags & 16) {
              var $ = b.deletions;
              if ($ !== null) {
                for (var le = 0; le < $.length; le++) {
                  var Ee = $[le];
                  for (Ie = Ee; Ie !== null; ) {
                    var He = Ie;
                    switch (He.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Oa(8, He, b);
                    }
                    var ct = He.child;
                    if (ct !== null) (ct.return = He), (Ie = ct);
                    else
                      for (; Ie !== null; ) {
                        He = Ie;
                        var et = He.sibling,
                          zt = He.return;
                        if ((gE(He), He === Ee)) {
                          Ie = null;
                          break;
                        }
                        if (et !== null) {
                          (et.return = zt), (Ie = et);
                          break;
                        }
                        Ie = zt;
                      }
                  }
                }
                var Ye = b.alternate;
                if (Ye !== null) {
                  var lr = Ye.child;
                  if (lr !== null) {
                    Ye.child = null;
                    do {
                      var Mi = lr.sibling;
                      (lr.sibling = null), (lr = Mi);
                    } while (lr !== null);
                  }
                }
                Ie = b;
              }
            }
            if (b.subtreeFlags & 2064 && H !== null) (H.return = b), (Ie = H);
            else
              e: for (; Ie !== null; ) {
                if (((b = Ie), b.flags & 2048))
                  switch (b.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Oa(9, b, b.return);
                  }
                var re = b.sibling;
                if (re !== null) {
                  (re.return = b.return), (Ie = re);
                  break e;
                }
                Ie = b.return;
              }
          }
          var ee = c.current;
          for (Ie = ee; Ie !== null; ) {
            H = Ie;
            var se = H.child;
            if (H.subtreeFlags & 2064 && se !== null)
              (se.return = H), (Ie = se);
            else
              e: for (H = ee; Ie !== null; ) {
                if ((($ = Ie), $.flags & 2048))
                  try {
                    switch ($.tag) {
                      case 0:
                      case 11:
                      case 15:
                        uf(9, $);
                    }
                  } catch (Ke) {
                    Lr($, $.return, Ke);
                  }
                if ($ === H) {
                  Ie = null;
                  break e;
                }
                var Fe = $.sibling;
                if (Fe !== null) {
                  (Fe.return = $.return), (Ie = Fe);
                  break e;
                }
                Ie = $.return;
              }
          }
          if (
            ((St = w),
            gs(),
            ps && typeof ps.onPostCommitFiberRoot == "function")
          )
            try {
              ps.onPostCommitFiberRoot(Rd, c);
            } catch {}
          M = !0;
        }
        return M;
      } finally {
        (Bt = v), (yn.transition = f);
      }
    }
    return !1;
  }
  function IE(c, f, v) {
    (f = T_(v, f)),
      (f = JM(c, f, 1)),
      To(c, f),
      (f = Ar()),
      (c = pp(c, 1)),
      c !== null && (Yc(c, 1, f), Br(c, f));
  }
  function Lr(c, f, v) {
    if (c.tag === 3) IE(c, c, v);
    else
      for (; f !== null; ) {
        if (f.tag === 3) {
          IE(f, c, v);
          break;
        } else if (f.tag === 1) {
          var M = f.stateNode;
          if (
            typeof f.type.getDerivedStateFromError == "function" ||
            (typeof M.componentDidCatch == "function" &&
              (bo === null || !bo.has(M)))
          ) {
            (c = T_(v, c)),
              (c = KM(f, c, 1)),
              To(f, c),
              (c = Ar()),
              (f = pp(f, 1)),
              f !== null && (Yc(f, 1, c), Br(f, c));
            break;
          }
        }
        f = f.return;
      }
  }
  function WD(c, f, v) {
    var M = c.pingCache;
    M !== null && M.delete(f),
      (f = Ar()),
      (c.pingedLanes |= c.suspendedLanes & v),
      Cn === c &&
        (qn & v) === v &&
        (Fn === 4 || (Fn === 3 && (qn & 130023424) === qn && 500 > Vn() - W_)
          ? Ua(c, 0)
          : (V_ |= v)),
      Br(c, f);
  }
  function DE(c, f) {
    f === 0 &&
      (c.mode & 1
        ? ((f = Td), (Td <<= 1), !(Td & 130023424) && (Td = 4194304))
        : (f = 1));
    var v = Ar();
    (c = pp(c, f)), c !== null && (Yc(c, f, v), Br(c, v));
  }
  function jD(c) {
    var f = c.memoizedState,
      v = 0;
    f !== null && (v = f.retryLane), DE(c, v);
  }
  function XD(c, f) {
    var v = 0;
    switch (c.tag) {
      case 13:
        var M = c.stateNode,
          w = c.memoizedState;
        w !== null && (v = w.retryLane);
        break;
      case 19:
        M = c.stateNode;
        break;
      default:
        throw Error(o(314));
    }
    M !== null && M.delete(f), DE(c, v);
  }
  var FE;
  FE = function (c, f, v) {
    if (c !== null)
      if (c.memoizedProps !== f.pendingProps || wn.current) $r = !0;
      else {
        if (!(c.lanes & v) && !(f.flags & 128)) return ($r = !1), ID(c, f, v);
        $r = !!(c.flags & 131072);
      }
    else ($r = !1), Zt && f.flags & 1048576 && SM(f, Ud, f.index);
    switch (((f.lanes = 0), f.tag)) {
      case 2:
        var M = f.type;
        c !== null &&
          ((c.alternate = null), (f.alternate = null), (f.flags |= 2)),
          (c = f.pendingProps);
        var w = cn(f, Dn.current);
        Kl(f, v), (w = A_(null, f, M, c, w, v));
        var b = M_();
        return (
          (f.flags |= 1),
          typeof w == "object" &&
          w !== null &&
          typeof w.render == "function" &&
          w.$$typeof === void 0
            ? ((f.tag = 1),
              (f.memoizedState = null),
              (f.updateQueue = null),
              fn(M) ? ((b = !0), Xl(f)) : (b = !1),
              (f.memoizedState =
                w.state !== null && w.state !== void 0 ? w.state : null),
              u_(f),
              (w.updater = Nd),
              (f.stateNode = w),
              (w._reactInternals = f),
              f_(f, M, c, v),
              (f = P_(null, f, M, !0, b, v)))
            : ((f.tag = 0), Zt && b && h_(f), Sr(null, f, w, v), (f = f.child)),
          f
        );
      case 16:
        M = f.elementType;
        e: {
          switch (
            (c !== null &&
              ((c.alternate = null), (f.alternate = null), (f.flags |= 2)),
            (c = f.pendingProps),
            (w = M._init),
            (M = w(M._payload)),
            (f.type = M),
            (w = f.tag = KD(M)),
            (c = ji(M, c)),
            w)
          ) {
            case 0:
              f = R_(null, f, M, c, v);
              break e;
            case 1:
              f = sE(null, f, M, c, v);
              break e;
            case 11:
              f = eE(null, f, M, c, v);
              break e;
            case 14:
              f = tE(null, f, M, ji(M.type, c), v);
              break e;
          }
          throw Error(o(306, M, ""));
        }
        return f;
      case 0:
        return (
          (M = f.type),
          (w = f.pendingProps),
          (w = f.elementType === M ? w : ji(M, w)),
          R_(c, f, M, w, v)
        );
      case 1:
        return (
          (M = f.type),
          (w = f.pendingProps),
          (w = f.elementType === M ? w : ji(M, w)),
          sE(c, f, M, w, v)
        );
      case 3:
        e: {
          if ((oE(f), c === null)) throw Error(o(387));
          (M = f.pendingProps),
            (b = f.memoizedState),
            (w = b.element),
            pM(c, f),
            Fd(f, M, null, v);
          var H = f.memoizedState;
          if (((M = H.element), _e && b.isDehydrated))
            if (
              ((b = {
                element: M,
                isDehydrated: !1,
                cache: H.cache,
                transitions: H.transitions,
              }),
              (f.updateQueue.baseState = b),
              (f.memoizedState = b),
              f.flags & 256)
            ) {
              (w = Error(o(423))), (f = aE(c, f, M, v, w));
              break e;
            } else if (M !== w) {
              (w = Error(o(424))), (f = aE(c, f, M, v, w));
              break e;
            } else
              for (
                _e &&
                  ((Zr = Y0(f.stateNode.containerInfo)),
                  (qr = f),
                  (Zt = !0),
                  (Xi = null),
                  (Qc = !1)),
                  v = TM(f, null, M, v),
                  f.child = v;
                v;

              )
                (v.flags = (v.flags & -3) | 4096), (v = v.sibling);
          else {
            if ((ql(), M === w)) {
              f = Xs(c, f, v);
              break e;
            }
            Sr(c, f, M, v);
          }
          f = f.child;
        }
        return f;
      case 5:
        return (
          bM(f),
          c === null && m_(f),
          (M = f.type),
          (w = f.pendingProps),
          (b = c !== null ? c.memoizedProps : null),
          (H = w.children),
          ye(M, w) ? (H = null) : b !== null && ye(M, b) && (f.flags |= 32),
          iE(c, f),
          Sr(c, f, H, v),
          f.child
        );
      case 6:
        return c === null && m_(f), null;
      case 13:
        return lE(c, f, v);
      case 4:
        return (
          __(f, f.stateNode.containerInfo),
          (M = f.pendingProps),
          c === null ? (f.child = Zl(f, null, M, v)) : Sr(c, f, M, v),
          f.child
        );
      case 11:
        return (
          (M = f.type),
          (w = f.pendingProps),
          (w = f.elementType === M ? w : ji(M, w)),
          eE(c, f, M, w, v)
        );
      case 7:
        return Sr(c, f, f.pendingProps, v), f.child;
      case 8:
        return Sr(c, f, f.pendingProps.children, v), f.child;
      case 12:
        return Sr(c, f, f.pendingProps.children, v), f.child;
      case 10:
        e: {
          if (
            ((M = f.type._context),
            (w = f.pendingProps),
            (b = f.memoizedProps),
            (H = w.value),
            dM(f, M, H),
            b !== null)
          )
            if (ms(b.value, H)) {
              if (b.children === w.children && !wn.current) {
                f = Xs(c, f, v);
                break e;
              }
            } else
              for (b = f.child, b !== null && (b.return = f); b !== null; ) {
                var $ = b.dependencies;
                if ($ !== null) {
                  H = b.child;
                  for (var le = $.firstContext; le !== null; ) {
                    if (le.context === M) {
                      if (b.tag === 1) {
                        (le = Gs(-1, v & -v)), (le.tag = 2);
                        var Ee = b.updateQueue;
                        if (Ee !== null) {
                          Ee = Ee.shared;
                          var He = Ee.pending;
                          He === null
                            ? (le.next = le)
                            : ((le.next = He.next), (He.next = le)),
                            (Ee.pending = le);
                        }
                      }
                      (b.lanes |= v),
                        (le = b.alternate),
                        le !== null && (le.lanes |= v),
                        l_(b.return, v, f),
                        ($.lanes |= v);
                      break;
                    }
                    le = le.next;
                  }
                } else if (b.tag === 10) H = b.type === f.type ? null : b.child;
                else if (b.tag === 18) {
                  if (((H = b.return), H === null)) throw Error(o(341));
                  (H.lanes |= v),
                    ($ = H.alternate),
                    $ !== null && ($.lanes |= v),
                    l_(H, v, f),
                    (H = b.sibling);
                } else H = b.child;
                if (H !== null) H.return = b;
                else
                  for (H = b; H !== null; ) {
                    if (H === f) {
                      H = null;
                      break;
                    }
                    if (((b = H.sibling), b !== null)) {
                      (b.return = H.return), (H = b);
                      break;
                    }
                    H = H.return;
                  }
                b = H;
              }
          Sr(c, f, w.children, v), (f = f.child);
        }
        return f;
      case 9:
        return (
          (w = f.type),
          (M = f.pendingProps.children),
          Kl(f, v),
          (w = gi(w)),
          (M = M(w)),
          (f.flags |= 1),
          Sr(c, f, M, v),
          f.child
        );
      case 14:
        return (
          (M = f.type),
          (w = ji(M, f.pendingProps)),
          (w = ji(M.type, w)),
          tE(c, f, M, w, v)
        );
      case 15:
        return nE(c, f, f.type, f.pendingProps, v);
      case 17:
        return (
          (M = f.type),
          (w = f.pendingProps),
          (w = f.elementType === M ? w : ji(M, w)),
          c !== null &&
            ((c.alternate = null), (f.alternate = null), (f.flags |= 2)),
          (f.tag = 1),
          fn(M) ? ((c = !0), Xl(f)) : (c = !1),
          Kl(f, v),
          yM(f, M, w),
          f_(f, M, w, v),
          P_(null, f, M, !0, c, v)
        );
      case 19:
        return hE(c, f, v);
      case 22:
        return rE(c, f, v);
    }
    throw Error(o(156, f.tag));
  };
  function NE(c, f) {
    return t_(c, f);
  }
  function JD(c, f, v, M) {
    (this.tag = c),
      (this.key = v),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = f),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = M),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function Ai(c, f, v, M) {
    return new JD(c, f, v, M);
  }
  function Z_(c) {
    return (c = c.prototype), !(!c || !c.isReactComponent);
  }
  function KD(c) {
    if (typeof c == "function") return Z_(c) ? 1 : 0;
    if (c != null) {
      if (((c = c.$$typeof), c === y)) return 11;
      if (c === S) return 14;
    }
    return 2;
  }
  function Lo(c, f) {
    var v = c.alternate;
    return (
      v === null
        ? ((v = Ai(c.tag, f, c.key, c.mode)),
          (v.elementType = c.elementType),
          (v.type = c.type),
          (v.stateNode = c.stateNode),
          (v.alternate = c),
          (c.alternate = v))
        : ((v.pendingProps = f),
          (v.type = c.type),
          (v.flags = 0),
          (v.subtreeFlags = 0),
          (v.deletions = null)),
      (v.flags = c.flags & 14680064),
      (v.childLanes = c.childLanes),
      (v.lanes = c.lanes),
      (v.child = c.child),
      (v.memoizedProps = c.memoizedProps),
      (v.memoizedState = c.memoizedState),
      (v.updateQueue = c.updateQueue),
      (f = c.dependencies),
      (v.dependencies =
        f === null ? null : { lanes: f.lanes, firstContext: f.firstContext }),
      (v.sibling = c.sibling),
      (v.index = c.index),
      (v.ref = c.ref),
      v
    );
  }
  function gp(c, f, v, M, w, b) {
    var H = 2;
    if (((M = c), typeof c == "function")) Z_(c) && (H = 1);
    else if (typeof c == "string") H = 5;
    else
      e: switch (c) {
        case h:
          return Ha(v.children, w, b, f);
        case d:
          (H = 8), (w |= 8);
          break;
        case p:
          return (
            (c = Ai(12, v, f, w | 2)), (c.elementType = p), (c.lanes = b), c
          );
        case x:
          return (c = Ai(13, v, f, w)), (c.elementType = x), (c.lanes = b), c;
        case g:
          return (c = Ai(19, v, f, w)), (c.elementType = g), (c.lanes = b), c;
        case E:
          return _p(v, w, b, f);
        default:
          if (typeof c == "object" && c !== null)
            switch (c.$$typeof) {
              case m:
                H = 10;
                break e;
              case _:
                H = 9;
                break e;
              case y:
                H = 11;
                break e;
              case S:
                H = 14;
                break e;
              case A:
                (H = 16), (M = null);
                break e;
            }
          throw Error(o(130, c == null ? c : typeof c, ""));
      }
    return (
      (f = Ai(H, v, f, w)), (f.elementType = c), (f.type = M), (f.lanes = b), f
    );
  }
  function Ha(c, f, v, M) {
    return (c = Ai(7, c, M, f)), (c.lanes = v), c;
  }
  function _p(c, f, v, M) {
    return (
      (c = Ai(22, c, M, f)),
      (c.elementType = E),
      (c.lanes = v),
      (c.stateNode = {}),
      c
    );
  }
  function $_(c, f, v) {
    return (c = Ai(6, c, null, f)), (c.lanes = v), c;
  }
  function ev(c, f, v) {
    return (
      (f = Ai(4, c.children !== null ? c.children : [], c.key, f)),
      (f.lanes = v),
      (f.stateNode = {
        containerInfo: c.containerInfo,
        pendingChildren: null,
        implementation: c.implementation,
      }),
      f
    );
  }
  function YD(c, f, v, M, w) {
    (this.tag = f),
      (this.containerInfo = c),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = At),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = $0(0)),
      (this.expirationTimes = $0(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = $0(0)),
      (this.identifierPrefix = M),
      (this.onRecoverableError = w),
      _e && (this.mutableSourceEagerHydrationData = null);
  }
  function OE(c, f, v, M, w, b, H, $, le) {
    return (
      (c = new YD(c, f, v, $, le)),
      f === 1 ? ((f = 1), b === !0 && (f |= 8)) : (f = 0),
      (b = Ai(3, null, null, f)),
      (c.current = b),
      (b.stateNode = c),
      (b.memoizedState = {
        element: M,
        isDehydrated: v,
        cache: null,
        transitions: null,
      }),
      u_(b),
      c
    );
  }
  function UE(c) {
    if (!c) return rr;
    c = c._reactInternals;
    e: {
      if (T(c) !== c || c.tag !== 1) throw Error(o(170));
      var f = c;
      do {
        switch (f.tag) {
          case 3:
            f = f.stateNode.context;
            break e;
          case 1:
            if (fn(f.type)) {
              f = f.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        f = f.return;
      } while (f !== null);
      throw Error(o(171));
    }
    if (c.tag === 1) {
      var v = c.type;
      if (fn(v)) return jl(c, v, f);
    }
    return f;
  }
  function kE(c) {
    var f = c._reactInternals;
    if (f === void 0)
      throw typeof c.render == "function"
        ? Error(o(188))
        : ((c = Object.keys(c).join(",")), Error(o(268, c)));
    return (c = I(f)), c === null ? null : c.stateNode;
  }
  function zE(c, f) {
    if (((c = c.memoizedState), c !== null && c.dehydrated !== null)) {
      var v = c.retryLane;
      c.retryLane = v !== 0 && v < f ? v : f;
    }
  }
  function tv(c, f) {
    zE(c, f), (c = c.alternate) && zE(c, f);
  }
  function QD(c) {
    return (c = I(c)), c === null ? null : c.stateNode;
  }
  function qD() {
    return null;
  }
  return (
    (t.attemptContinuousHydration = function (c) {
      if (c.tag === 13) {
        var f = Ar();
        Si(c, 134217728, f), tv(c, 134217728);
      }
    }),
    (t.attemptHydrationAtCurrentPriority = function (c) {
      if (c.tag === 13) {
        var f = Ar(),
          v = Po(c);
        Si(c, v, f), tv(c, v);
      }
    }),
    (t.attemptSynchronousHydration = function (c) {
      switch (c.tag) {
        case 3:
          var f = c.stateNode;
          if (f.current.memoizedState.isDehydrated) {
            var v = Kc(f.pendingLanes);
            v !== 0 && (e_(f, v | 1), Br(f, Vn()), !(St & 6) && (iu(), gs()));
          }
          break;
        case 13:
          var M = Ar();
          bE(function () {
            return Si(c, 1, M);
          }),
            tv(c, 1);
      }
    }),
    (t.batchedUpdates = function (c, f) {
      var v = St;
      St |= 1;
      try {
        return c(f);
      } finally {
        (St = v), St === 0 && (iu(), Pd && gs());
      }
    }),
    (t.createComponentSelector = function (c) {
      return { $$typeof: np, value: c };
    }),
    (t.createContainer = function (c, f, v, M, w, b, H) {
      return OE(c, f, !1, null, v, M, w, b, H);
    }),
    (t.createHasPseudoClassSelector = function (c) {
      return { $$typeof: rp, value: c };
    }),
    (t.createHydrationContainer = function (c, f, v, M, w, b, H, $, le) {
      return (
        (c = OE(v, M, !0, c, w, b, H, $, le)),
        (c.context = UE(null)),
        (v = c.current),
        (M = Ar()),
        (w = Po(v)),
        (b = Gs(M, w)),
        (b.callback = f ?? null),
        To(v, b),
        (c.current.lanes = w),
        Yc(c, w, M),
        Br(c, M),
        c
      );
    }),
    (t.createPortal = function (c, f, v) {
      var M =
        3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: u,
        key: M == null ? null : "" + M,
        children: c,
        containerInfo: f,
        implementation: v,
      };
    }),
    (t.createRoleSelector = function (c) {
      return { $$typeof: ip, value: c };
    }),
    (t.createTestNameSelector = function (c) {
      return { $$typeof: sp, value: c };
    }),
    (t.createTextSelector = function (c) {
      return { $$typeof: op, value: c };
    }),
    (t.deferredUpdates = function (c) {
      var f = Bt,
        v = yn.transition;
      try {
        return (yn.transition = null), (Bt = 16), c();
      } finally {
        (Bt = f), (yn.transition = v);
      }
    }),
    (t.discreteUpdates = function (c, f, v, M, w) {
      var b = Bt,
        H = yn.transition;
      try {
        return (yn.transition = null), (Bt = 1), c(f, v, M, w);
      } finally {
        (Bt = b), (yn.transition = H), St === 0 && iu();
      }
    }),
    (t.findAllNodes = H_),
    (t.findBoundingRects = function (c, f) {
      if (!Qe) throw Error(o(363));
      (f = H_(c, f)), (c = []);
      for (var v = 0; v < f.length; v++) c.push(Vt(f[v]));
      for (f = c.length - 1; 0 < f; f--) {
        v = c[f];
        for (
          var M = v.x, w = M + v.width, b = v.y, H = b + v.height, $ = f - 1;
          0 <= $;
          $--
        )
          if (f !== $) {
            var le = c[$],
              Ee = le.x,
              He = Ee + le.width,
              ct = le.y,
              et = ct + le.height;
            if (M >= Ee && b >= ct && w <= He && H <= et) {
              c.splice(f, 1);
              break;
            } else if (M !== Ee || v.width !== le.width || et < b || ct > H) {
              if (!(b !== ct || v.height !== le.height || He < M || Ee > w)) {
                Ee > M && ((le.width += Ee - M), (le.x = M)),
                  He < w && (le.width = w - Ee),
                  c.splice(f, 1);
                break;
              }
            } else {
              ct > b && ((le.height += ct - b), (le.y = b)),
                et < H && (le.height = H - ct),
                c.splice(f, 1);
              break;
            }
          }
      }
      return c;
    }),
    (t.findHostInstance = kE),
    (t.findHostInstanceWithNoPortals = function (c) {
      return (
        (c = D(c)),
        (c = c !== null ? k(c) : null),
        c === null ? null : c.stateNode
      );
    }),
    (t.findHostInstanceWithWarning = function (c) {
      return kE(c);
    }),
    (t.flushControlled = function (c) {
      var f = St;
      St |= 1;
      var v = yn.transition,
        M = Bt;
      try {
        (yn.transition = null), (Bt = 1), c();
      } finally {
        (Bt = M), (yn.transition = v), (St = f), St === 0 && (iu(), gs());
      }
    }),
    (t.flushPassiveEffects = za),
    (t.flushSync = bE),
    (t.focusWithin = function (c, f) {
      if (!Qe) throw Error(o(363));
      for (c = U_(c), f = wE(c, f), f = Array.from(f), c = 0; c < f.length; ) {
        var v = f[c++];
        if (!O(v)) {
          if (v.tag === 5 && Me(v.stateNode)) return !0;
          for (v = v.child; v !== null; ) f.push(v), (v = v.sibling);
        }
      }
      return !1;
    }),
    (t.getCurrentUpdatePriority = function () {
      return Bt;
    }),
    (t.getFindAllNodesFailureDescription = function (c, f) {
      if (!Qe) throw Error(o(363));
      var v = 0,
        M = [];
      c = [U_(c), 0];
      for (var w = 0; w < c.length; ) {
        var b = c[w++],
          H = c[w++],
          $ = f[H];
        if (
          (b.tag !== 5 || !O(b)) &&
          (k_(b, $) && (M.push(z_($)), H++, H > v && (v = H)), H < f.length)
        )
          for (b = b.child; b !== null; ) c.push(b, H), (b = b.sibling);
      }
      if (v < f.length) {
        for (c = []; v < f.length; v++) c.push(z_(f[v]));
        return (
          `findAllNodes was able to match part of the selector:
  ` +
          (M.join(" > ") +
            `

No matching component was found for:
  `) +
          c.join(" > ")
        );
      }
      return null;
    }),
    (t.getPublicRootInstance = function (c) {
      if (((c = c.current), !c.child)) return null;
      switch (c.child.tag) {
        case 5:
          return Z(c.child.stateNode);
        default:
          return c.child.stateNode;
      }
    }),
    (t.injectIntoDevTools = function (c) {
      if (
        ((c = {
          bundleType: c.bundleType,
          version: c.version,
          rendererPackageName: c.rendererPackageName,
          rendererConfig: c.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: a.ReactCurrentDispatcher,
          findHostInstanceByFiber: QD,
          findFiberByHostInstance: c.findFiberByHostInstance || qD,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.0.0-fc46dba67-20220329",
        }),
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
      )
        c = !1;
      else {
        var f = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (f.isDisabled || !f.supportsFiber) c = !0;
        else {
          try {
            (Rd = f.inject(c)), (ps = f);
          } catch {}
          c = !!f.checkDCE;
        }
      }
      return c;
    }),
    (t.isAlreadyRendering = function () {
      return !1;
    }),
    (t.observeVisibleRects = function (c, f, v, M) {
      if (!Qe) throw Error(o(363));
      c = H_(c, f);
      var w = xe(c, v, M).disconnect;
      return {
        disconnect: function () {
          w();
        },
      };
    }),
    (t.registerMutableSourceForHydration = function (c, f) {
      var v = f._getVersion;
      (v = v(f._source)),
        c.mutableSourceEagerHydrationData == null
          ? (c.mutableSourceEagerHydrationData = [f, v])
          : c.mutableSourceEagerHydrationData.push(f, v);
    }),
    (t.runWithPriority = function (c, f) {
      var v = Bt;
      try {
        return (Bt = c), f();
      } finally {
        Bt = v;
      }
    }),
    (t.shouldError = function () {
      return null;
    }),
    (t.shouldSuspend = function () {
      return !1;
    }),
    (t.updateContainer = function (c, f, v, M) {
      var w = f.current,
        b = Ar(),
        H = Po(w);
      return (
        (v = UE(v)),
        f.context === null ? (f.context = v) : (f.pendingContext = v),
        (f = Gs(b, H)),
        (f.payload = { element: c }),
        (M = M === void 0 ? null : M),
        M !== null && (f.callback = M),
        To(w, f),
        (c = Si(w, H, b)),
        c !== null && Dd(c, w, H),
        H
      );
    }),
    t
  );
};
BL.exports = _V;
var vV = BL.exports;
const yV = Nc(vV);
var LL = { exports: {} },
  IL = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(N, W) {
    var G = N.length;
    N.push(W);
    e: for (; 0 < G; ) {
      var X = (G - 1) >>> 1,
        Y = N[X];
      if (0 < i(Y, W)) (N[X] = W), (N[G] = Y), (G = X);
      else break e;
    }
  }
  function t(N) {
    return N.length === 0 ? null : N[0];
  }
  function r(N) {
    if (N.length === 0) return null;
    var W = N[0],
      G = N.pop();
    if (G !== W) {
      N[0] = G;
      e: for (var X = 0, Y = N.length, de = Y >>> 1; X < de; ) {
        var ae = 2 * (X + 1) - 1,
          ye = N[ae],
          we = ae + 1,
          Ne = N[we];
        if (0 > i(ye, G))
          we < Y && 0 > i(Ne, ye)
            ? ((N[X] = Ne), (N[we] = G), (X = we))
            : ((N[X] = ye), (N[ae] = G), (X = ae));
        else if (we < Y && 0 > i(Ne, G)) (N[X] = Ne), (N[we] = G), (X = we);
        else break e;
      }
    }
    return W;
  }
  function i(N, W) {
    var G = N.sortIndex - W.sortIndex;
    return G !== 0 ? G : N.id - W.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    u = [],
    h = 1,
    d = null,
    p = 3,
    m = !1,
    _ = !1,
    y = !1,
    x = typeof setTimeout == "function" ? setTimeout : null,
    g = typeof clearTimeout == "function" ? clearTimeout : null,
    S = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function A(N) {
    for (var W = t(u); W !== null; ) {
      if (W.callback === null) r(u);
      else if (W.startTime <= N)
        r(u), (W.sortIndex = W.expirationTime), e(l, W);
      else break;
      W = t(u);
    }
  }
  function E(N) {
    if (((y = !1), A(N), !_))
      if (t(l) !== null) (_ = !0), Z(C);
      else {
        var W = t(u);
        W !== null && Q(E, W.startTime - N);
      }
  }
  function C(N, W) {
    (_ = !1), y && ((y = !1), g(L), (L = -1)), (m = !0);
    var G = p;
    try {
      for (
        A(W), d = t(l);
        d !== null && (!(d.expirationTime > W) || (N && !D()));

      ) {
        var X = d.callback;
        if (typeof X == "function") {
          (d.callback = null), (p = d.priorityLevel);
          var Y = X(d.expirationTime <= W);
          (W = n.unstable_now()),
            typeof Y == "function" ? (d.callback = Y) : d === t(l) && r(l),
            A(W);
        } else r(l);
        d = t(l);
      }
      if (d !== null) var de = !0;
      else {
        var ae = t(u);
        ae !== null && Q(E, ae.startTime - W), (de = !1);
      }
      return de;
    } finally {
      (d = null), (p = G), (m = !1);
    }
  }
  var R = !1,
    P = null,
    L = -1,
    T = 5,
    B = -1;
  function D() {
    return !(n.unstable_now() - B < T);
  }
  function I() {
    if (P !== null) {
      var N = n.unstable_now();
      B = N;
      var W = !0;
      try {
        W = P(!0, N);
      } finally {
        W ? F() : ((R = !1), (P = null));
      }
    } else R = !1;
  }
  var F;
  if (typeof S == "function")
    F = function () {
      S(I);
    };
  else if (typeof MessageChannel < "u") {
    var k = new MessageChannel(),
      j = k.port2;
    (k.port1.onmessage = I),
      (F = function () {
        j.postMessage(null);
      });
  } else
    F = function () {
      x(I, 0);
    };
  function Z(N) {
    (P = N), R || ((R = !0), F());
  }
  function Q(N, W) {
    L = x(function () {
      N(n.unstable_now());
    }, W);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (N) {
      N.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      _ || m || ((_ = !0), Z(C));
    }),
    (n.unstable_forceFrameRate = function (N) {
      0 > N || 125 < N
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (T = 0 < N ? Math.floor(1e3 / N) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(l);
    }),
    (n.unstable_next = function (N) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var W = 3;
          break;
        default:
          W = p;
      }
      var G = p;
      p = W;
      try {
        return N();
      } finally {
        p = G;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (N, W) {
      switch (N) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          N = 3;
      }
      var G = p;
      p = N;
      try {
        return W();
      } finally {
        p = G;
      }
    }),
    (n.unstable_scheduleCallback = function (N, W, G) {
      var X = n.unstable_now();
      switch (
        (typeof G == "object" && G !== null
          ? ((G = G.delay), (G = typeof G == "number" && 0 < G ? X + G : X))
          : (G = X),
        N)
      ) {
        case 1:
          var Y = -1;
          break;
        case 2:
          Y = 250;
          break;
        case 5:
          Y = 1073741823;
          break;
        case 4:
          Y = 1e4;
          break;
        default:
          Y = 5e3;
      }
      return (
        (Y = G + Y),
        (N = {
          id: h++,
          callback: W,
          priorityLevel: N,
          startTime: G,
          expirationTime: Y,
          sortIndex: -1,
        }),
        G > X
          ? ((N.sortIndex = G),
            e(u, N),
            t(l) === null &&
              N === t(u) &&
              (y ? (g(L), (L = -1)) : (y = !0), Q(E, G - X)))
          : ((N.sortIndex = Y), e(l, N), _ || m || ((_ = !0), Z(C))),
        N
      );
    }),
    (n.unstable_shouldYield = D),
    (n.unstable_wrapCallback = function (N) {
      var W = p;
      return function () {
        var G = p;
        p = W;
        try {
          return N.apply(this, arguments);
        } finally {
          p = G;
        }
      };
    });
})(IL);
LL.exports = IL;
var jT = LL.exports;
const xV = (n) => typeof n == "object" && typeof n.then == "function",
  ml = [];
function DL(n, e, t = (r, i) => r === i) {
  if (n === e) return !0;
  if (!n || !e) return !1;
  const r = n.length;
  if (e.length !== r) return !1;
  for (let i = 0; i < r; i++) if (!t(n[i], e[i])) return !1;
  return !0;
}
function FL(n, e = null, t = !1, r = {}) {
  e === null && (e = [n]);
  for (const s of ml)
    if (DL(e, s.keys, s.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error;
      if (Object.prototype.hasOwnProperty.call(s, "response"))
        return (
          r.lifespan &&
            r.lifespan > 0 &&
            (s.timeout && clearTimeout(s.timeout),
            (s.timeout = setTimeout(s.remove, r.lifespan))),
          s.response
        );
      if (!t) throw s.promise;
    }
  const i = {
    keys: e,
    equal: r.equal,
    remove: () => {
      const s = ml.indexOf(i);
      s !== -1 && ml.splice(s, 1);
    },
    promise: (xV(n) ? n : n(...e))
      .then((s) => {
        (i.response = s),
          r.lifespan &&
            r.lifespan > 0 &&
            (i.timeout = setTimeout(i.remove, r.lifespan));
      })
      .catch((s) => (i.error = s)),
  };
  if ((ml.push(i), !t)) throw i.promise;
}
const SV = (n, e, t) => FL(n, e, !1, t),
  AV = (n, e, t) => void FL(n, e, !0, t),
  MV = (n) => {
    if (n === void 0 || n.length === 0) ml.splice(0, ml.length);
    else {
      const e = ml.find((t) => DL(n, t.keys, t.equal));
      e && e.remove();
    }
  },
  G1 = {},
  EV = (n) => void Object.assign(G1, n);
function wV(n, e) {
  function t(h, { args: d = [], attach: p, ...m }, _) {
    let y = `${h[0].toUpperCase()}${h.slice(1)}`,
      x;
    if (h === "primitive") {
      if (m.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const g = m.object;
      x = Iu(g, { type: h, root: _, attach: p, primitive: !0 });
    } else {
      const g = G1[y];
      if (!g)
        throw new Error(
          `R3F: ${y} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(d))
        throw new Error("R3F: The args prop must be an array!");
      x = Iu(new g(...d), {
        type: h,
        root: _,
        attach: p,
        memoizedProps: { args: d },
      });
    }
    return (
      x.__r3f.attach === void 0 &&
        (x instanceof dt
          ? (x.__r3f.attach = "geometry")
          : x instanceof In && (x.__r3f.attach = "material")),
      y !== "inject" && _y(x, m),
      x
    );
  }
  function r(h, d) {
    let p = !1;
    if (d) {
      var m, _;
      (m = d.__r3f) != null && m.attach
        ? gy(h, d, d.__r3f.attach)
        : d.isObject3D && h.isObject3D && (h.add(d), (p = !0)),
        p || (_ = h.__r3f) == null || _.objects.push(d),
        d.__r3f || Iu(d, {}),
        (d.__r3f.parent = h),
        wS(d),
        Du(d);
    }
  }
  function i(h, d, p) {
    let m = !1;
    if (d) {
      var _, y;
      if ((_ = d.__r3f) != null && _.attach) gy(h, d, d.__r3f.attach);
      else if (d.isObject3D && h.isObject3D) {
        (d.parent = h), d.dispatchEvent({ type: "added" });
        const x = h.children.filter((S) => S !== d),
          g = x.indexOf(p);
        (h.children = [...x.slice(0, g), d, ...x.slice(g)]), (m = !0);
      }
      m || (y = h.__r3f) == null || y.objects.push(d),
        d.__r3f || Iu(d, {}),
        (d.__r3f.parent = h),
        wS(d),
        Du(d);
    }
  }
  function s(h, d, p = !1) {
    h && [...h].forEach((m) => o(d, m, p));
  }
  function o(h, d, p) {
    if (d) {
      var m, _, y;
      if (
        (d.__r3f && (d.__r3f.parent = null),
        (m = h.__r3f) != null &&
          m.objects &&
          (h.__r3f.objects = h.__r3f.objects.filter((E) => E !== d)),
        (_ = d.__r3f) != null && _.attach)
      )
        QT(h, d, d.__r3f.attach);
      else if (d.isObject3D && h.isObject3D) {
        var x;
        h.remove(d), (x = d.__r3f) != null && x.root && IV(d.__r3f.root, d);
      }
      const S = (y = d.__r3f) == null ? void 0 : y.primitive,
        A = p === void 0 ? d.dispose !== null && !S : p;
      if (!S) {
        var g;
        s((g = d.__r3f) == null ? void 0 : g.objects, d, A),
          s(d.children, d, A);
      }
      delete d.__r3f,
        A &&
          d.dispose &&
          d.type !== "Scene" &&
          jT.unstable_scheduleCallback(jT.unstable_IdlePriority, () => {
            try {
              d.dispose();
            } catch {}
          }),
        Du(h);
    }
  }
  function a(h, d, p, m) {
    var _;
    const y = (_ = h.__r3f) == null ? void 0 : _.parent;
    if (!y) return;
    const x = t(d, p, h.__r3f.root);
    if (h.children) {
      for (const g of h.children) g.__r3f && r(x, g);
      h.children = h.children.filter((g) => !g.__r3f);
    }
    h.__r3f.objects.forEach((g) => r(x, g)),
      (h.__r3f.objects = []),
      h.__r3f.autoRemovedBeforeAppend || o(y, h),
      x.parent && (x.__r3f.autoRemovedBeforeAppend = !0),
      r(y, x),
      x.raycast &&
        x.__r3f.eventCount &&
        x.__r3f.root.getState().internal.interaction.push(x),
      [m, m.alternate].forEach((g) => {
        g !== null &&
          ((g.stateNode = x),
          g.ref &&
            (typeof g.ref == "function" ? g.ref(x) : (g.ref.current = x)));
      });
  }
  const l = () =>
    console.warn(
      "Text is not allowed in the R3F tree! This could be stray whitespace or characters."
    );
  return {
    reconciler: yV({
      createInstance: t,
      removeChild: o,
      appendChild: r,
      appendInitialChild: r,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (h, d) => {
        if (!d) return;
        const p = h.getState().scene;
        p.__r3f && ((p.__r3f.root = h), r(p, d));
      },
      removeChildFromContainer: (h, d) => {
        d && o(h.getState().scene, d);
      },
      insertInContainerBefore: (h, d, p) => {
        if (!d || !p) return;
        const m = h.getState().scene;
        m.__r3f && i(m, d, p);
      },
      getRootHostContext: () => null,
      getChildHostContext: (h) => h,
      finalizeInitialChildren(h) {
        var d;
        return !!((d = h == null ? void 0 : h.__r3f) != null ? d : {}).handlers;
      },
      prepareUpdate(h, d, p, m) {
        var _;
        if (
          ((_ = h == null ? void 0 : h.__r3f) != null ? _ : {}).primitive &&
          m.object &&
          m.object !== h
        )
          return [!0];
        {
          const { args: x = [], children: g, ...S } = m,
            { args: A = [], children: E, ...C } = p;
          if (!Array.isArray(x))
            throw new Error("R3F: the args prop must be an array!");
          if (x.some((P, L) => P !== A[L])) return [!0];
          const R = GL(h, S, C, !0);
          return R.changes.length ? [!1, R] : null;
        }
      },
      commitUpdate(h, [d, p], m, _, y, x) {
        d ? a(h, m, y, x) : _y(h, p);
      },
      commitMount(h, d, p, m) {
        var _;
        const y = (_ = h.__r3f) != null ? _ : {};
        h.raycast &&
          y.handlers &&
          y.eventCount &&
          h.__r3f.root.getState().internal.interaction.push(h);
      },
      getPublicInstance: (h) => h,
      prepareForCommit: () => null,
      preparePortalMount: (h) => Iu(h.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(h) {
        var d;
        const { attach: p, parent: m } = (d = h.__r3f) != null ? d : {};
        p && m && QT(m, h, p), h.isObject3D && (h.visible = !1), Du(h);
      },
      unhideInstance(h, d) {
        var p;
        const { attach: m, parent: _ } = (p = h.__r3f) != null ? p : {};
        m && _ && gy(_, h, m),
          ((h.isObject3D && d.visible == null) || d.visible) &&
            (h.visible = !0),
          Du(h);
      },
      createTextInstance: l,
      hideTextInstance: l,
      unhideTextInstance: l,
      getCurrentEventPriority: () => (e ? e() : Qu.DefaultEventPriority),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && Qt.fun(performance.now)
          ? performance.now
          : Qt.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: Qt.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Qt.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: _y,
  };
}
var XT, JT;
const my = (n) => "colorSpace" in n || "outputColorSpace" in n,
  NL = () => {
    var n;
    return (n = G1.ColorManagement) != null ? n : null;
  },
  OL = (n) => n && n.isOrthographicCamera,
  CV = (n) => n && n.hasOwnProperty("current"),
  _d =
    typeof window < "u" &&
    (((XT = window.document) != null && XT.createElement) ||
      ((JT = window.navigator) == null ? void 0 : JT.product) === "ReactNative")
      ? te.useLayoutEffect
      : te.useEffect;
function UL(n) {
  const e = te.useRef(n);
  return _d(() => void (e.current = n), [n]), e;
}
function TV({ set: n }) {
  return _d(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
class kL extends te.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
kL.getDerivedStateFromError = () => ({ error: !0 });
const zL = "__default",
  KT = new Map(),
  bV = (n) => n && !!n.memoized && !!n.changes;
function HL(n) {
  var e;
  const t =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n;
}
const If = (n) => {
    var e;
    return (e = n.__r3f) == null ? void 0 : e.root.getState();
  },
  Qt = {
    obj: (n) => n === Object(n) && !Qt.arr(n) && typeof n != "function",
    fun: (n) => typeof n == "function",
    str: (n) => typeof n == "string",
    num: (n) => typeof n == "number",
    boo: (n) => typeof n == "boolean",
    und: (n) => n === void 0,
    arr: (n) => Array.isArray(n),
    equ(
      n,
      e,
      { arrays: t = "shallow", objects: r = "reference", strict: i = !0 } = {}
    ) {
      if (typeof n != typeof e || !!n != !!e) return !1;
      if (Qt.str(n) || Qt.num(n)) return n === e;
      const s = Qt.obj(n);
      if (s && r === "reference") return n === e;
      const o = Qt.arr(n);
      if (o && t === "reference") return n === e;
      if ((o || s) && n === e) return !0;
      let a;
      for (a in n) if (!(a in e)) return !1;
      if (s && t === "shallow" && r === "shallow") {
        for (a in i ? e : n)
          if (!Qt.equ(n[a], e[a], { strict: i, objects: "reference" }))
            return !1;
      } else for (a in i ? e : n) if (n[a] !== e[a]) return !1;
      if (Qt.und(a)) {
        if (
          (o && n.length === 0 && e.length === 0) ||
          (s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
        )
          return !0;
        if (n !== e) return !1;
      }
      return !0;
    },
  };
function RV(n) {
  const e = { nodes: {}, materials: {} };
  return (
    n &&
      n.traverse((t) => {
        t.name && (e.nodes[t.name] = t),
          t.material &&
            !e.materials[t.material.name] &&
            (e.materials[t.material.name] = t.material);
      }),
    e
  );
}
function PV(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n) e.dispose == null || e.dispose(), delete n[e];
}
function Iu(n, e) {
  const t = n;
  return (
    (t.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    n
  );
}
function ES(n, e) {
  let t = n;
  if (e.includes("-")) {
    const r = e.split("-"),
      i = r.pop();
    return (t = r.reduce((s, o) => s[o], n)), { target: t, key: i };
  } else return { target: t, key: e };
}
const YT = /-\d+$/;
function gy(n, e, t) {
  if (Qt.str(t)) {
    if (YT.test(t)) {
      const s = t.replace(YT, ""),
        { target: o, key: a } = ES(n, s);
      Array.isArray(o[a]) || (o[a] = []);
    }
    const { target: r, key: i } = ES(n, t);
    (e.__r3f.previousAttach = r[i]), (r[i] = e);
  } else e.__r3f.previousAttach = t(n, e);
}
function QT(n, e, t) {
  var r, i;
  if (Qt.str(t)) {
    const { target: s, key: o } = ES(n, t),
      a = e.__r3f.previousAttach;
    a === void 0 ? delete s[o] : (s[o] = a);
  } else
    (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(n, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function GL(
  n,
  { children: e, key: t, ref: r, ...i },
  { children: s, key: o, ref: a, ...l } = {},
  u = !1
) {
  var h;
  const d = (h = n == null ? void 0 : n.__r3f) != null ? h : {},
    p = Object.entries(i),
    m = [];
  if (u) {
    const y = Object.keys(l);
    for (let x = 0; x < y.length; x++)
      i.hasOwnProperty(y[x]) || p.unshift([y[x], zL + "remove"]);
  }
  p.forEach(([y, x]) => {
    var g;
    if (
      ((g = n.__r3f) != null && g.primitive && y === "object") ||
      Qt.equ(x, l[y])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(y))
      return m.push([y, x, !0, []]);
    let S = [];
    y.includes("-") && (S = y.split("-")), m.push([y, x, !1, S]);
    for (const A in i) {
      const E = i[A];
      A.startsWith(`${y}-`) && m.push([A, E, !1, A.split("-")]);
    }
  });
  const _ = { ...i };
  return (
    d.memoizedProps && d.memoizedProps.args && (_.args = d.memoizedProps.args),
    d.memoizedProps &&
      d.memoizedProps.attach &&
      (_.attach = d.memoizedProps.attach),
    { memoized: _, changes: m }
  );
}
function _y(n, e) {
  var t, r, i;
  const s = (t = n.__r3f) != null ? t : {},
    o = s.root,
    a =
      (r = o == null || o.getState == null ? void 0 : o.getState()) != null
        ? r
        : {},
    { memoized: l, changes: u } = bV(e) ? e : GL(n, e),
    h = s.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = l);
  for (let p = 0; p < u.length; p++) {
    let [m, _, y, x] = u[p];
    if (my(n)) {
      const E = "srgb",
        C = "srgb-linear";
      m === "encoding"
        ? ((m = "colorSpace"), (_ = _ === 3001 ? E : C))
        : m === "outputEncoding" &&
          ((m = "outputColorSpace"), (_ = _ === 3001 ? E : C));
    }
    let g = n,
      S = g[m];
    if (x.length && ((S = x.reduce((A, E) => A[E], n)), !(S && S.set))) {
      const [A, ...E] = x.reverse();
      (g = E.reverse().reduce((C, R) => C[R], n)), (m = A);
    }
    if (_ === zL + "remove")
      if (g.constructor) {
        let A = KT.get(g.constructor);
        A || ((A = new g.constructor()), KT.set(g.constructor, A)), (_ = A[m]);
      } else _ = 0;
    if (y)
      _ ? (s.handlers[m] = _) : delete s.handlers[m],
        (s.eventCount = Object.keys(s.handlers).length);
    else if (S && S.set && (S.copy || S instanceof Sl)) {
      if (Array.isArray(_)) S.fromArray ? S.fromArray(_) : S.set(..._);
      else if (S.copy && _ && _.constructor && S.constructor === _.constructor)
        S.copy(_);
      else if (_ !== void 0) {
        const A = S instanceof Be;
        !A && S.setScalar
          ? S.setScalar(_)
          : S instanceof Sl && _ instanceof Sl
          ? (S.mask = _.mask)
          : S.set(_),
          !NL() && !a.linear && A && S.convertSRGBToLinear();
      }
    } else if (
      ((g[m] = _), g[m] instanceof en && g[m].format === Nr && g[m].type === Bs)
    ) {
      const A = g[m];
      my(A) && my(a.gl)
        ? (A.colorSpace = a.gl.outputColorSpace)
        : (A.encoding = a.gl.outputEncoding);
    }
    Du(n);
  }
  if (s.parent && a.internal && n.raycast && h !== s.eventCount) {
    const p = a.internal.interaction.indexOf(n);
    p > -1 && a.internal.interaction.splice(p, 1),
      s.eventCount && a.internal.interaction.push(n);
  }
  return (
    !(u.length === 1 && u[0][0] === "onUpdate") &&
      u.length &&
      (i = n.__r3f) != null &&
      i.parent &&
      wS(n),
    n
  );
}
function Du(n) {
  var e, t;
  const r =
    (e = n.__r3f) == null || (t = e.root) == null || t.getState == null
      ? void 0
      : t.getState();
  r && r.internal.frames === 0 && r.invalidate();
}
function wS(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function BV(n, e) {
  n.manual ||
    (OL(n)
      ? ((n.left = e.width / -2),
        (n.right = e.width / 2),
        (n.top = e.height / 2),
        (n.bottom = e.height / -2))
      : (n.aspect = e.width / e.height),
    n.updateProjectionMatrix(),
    n.updateMatrixWorld());
}
function Am(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function LV() {
  var n;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return Qu.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return Qu.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return Qu.ContinuousEventPriority;
    default:
      return Qu.DefaultEventPriority;
  }
}
function VL(n, e, t, r) {
  const i = t.get(e);
  i &&
    (t.delete(e),
    t.size === 0 && (n.delete(r), i.target.releasePointerCapture(r)));
}
function IV(n, e) {
  const { internal: t } = n.getState();
  (t.interaction = t.interaction.filter((r) => r !== e)),
    (t.initialHits = t.initialHits.filter((r) => r !== e)),
    t.hovered.forEach((r, i) => {
      (r.eventObject === e || r.object === e) && t.hovered.delete(i);
    }),
    t.capturedMap.forEach((r, i) => {
      VL(t.capturedMap, e, r, i);
    });
}
function DV(n) {
  function e(l) {
    const { internal: u } = n.getState(),
      h = l.offsetX - u.initialClick[0],
      d = l.offsetY - u.initialClick[1];
    return Math.round(Math.sqrt(h * h + d * d));
  }
  function t(l) {
    return l.filter((u) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((h) => {
        var d;
        return (d = u.__r3f) == null ? void 0 : d.handlers["onPointer" + h];
      })
    );
  }
  function r(l, u) {
    const h = n.getState(),
      d = new Set(),
      p = [],
      m = u ? u(h.internal.interaction) : h.internal.interaction;
    for (let g = 0; g < m.length; g++) {
      const S = If(m[g]);
      S && (S.raycaster.camera = void 0);
    }
    h.previousRoot || h.events.compute == null || h.events.compute(l, h);
    function _(g) {
      const S = If(g);
      if (!S || !S.events.enabled || S.raycaster.camera === null) return [];
      if (S.raycaster.camera === void 0) {
        var A;
        S.events.compute == null ||
          S.events.compute(
            l,
            S,
            (A = S.previousRoot) == null ? void 0 : A.getState()
          ),
          S.raycaster.camera === void 0 && (S.raycaster.camera = null);
      }
      return S.raycaster.camera ? S.raycaster.intersectObject(g, !0) : [];
    }
    let y = m
      .flatMap(_)
      .sort((g, S) => {
        const A = If(g.object),
          E = If(S.object);
        return !A || !E
          ? g.distance - S.distance
          : E.events.priority - A.events.priority || g.distance - S.distance;
      })
      .filter((g) => {
        const S = Am(g);
        return d.has(S) ? !1 : (d.add(S), !0);
      });
    h.events.filter && (y = h.events.filter(y, h));
    for (const g of y) {
      let S = g.object;
      for (; S; ) {
        var x;
        (x = S.__r3f) != null &&
          x.eventCount &&
          p.push({ ...g, eventObject: S }),
          (S = S.parent);
      }
    }
    if ("pointerId" in l && h.internal.capturedMap.has(l.pointerId))
      for (let g of h.internal.capturedMap.get(l.pointerId).values())
        d.has(Am(g.intersection)) || p.push(g.intersection);
    return p;
  }
  function i(l, u, h, d) {
    const p = n.getState();
    if (l.length) {
      const m = { stopped: !1 };
      for (const _ of l) {
        const y = If(_.object) || p,
          { raycaster: x, pointer: g, camera: S, internal: A } = y,
          E = new U(g.x, g.y, 0).unproject(S),
          C = (B) => {
            var D, I;
            return (D =
              (I = A.capturedMap.get(B)) == null
                ? void 0
                : I.has(_.eventObject)) != null
              ? D
              : !1;
          },
          R = (B) => {
            const D = { intersection: _, target: u.target };
            A.capturedMap.has(B)
              ? A.capturedMap.get(B).set(_.eventObject, D)
              : A.capturedMap.set(B, new Map([[_.eventObject, D]])),
              u.target.setPointerCapture(B);
          },
          P = (B) => {
            const D = A.capturedMap.get(B);
            D && VL(A.capturedMap, _.eventObject, D, B);
          };
        let L = {};
        for (let B in u) {
          let D = u[B];
          typeof D != "function" && (L[B] = D);
        }
        let T = {
          ..._,
          ...L,
          pointer: g,
          intersections: l,
          stopped: m.stopped,
          delta: h,
          unprojectedPoint: E,
          ray: x.ray,
          camera: S,
          stopPropagation() {
            const B = "pointerId" in u && A.capturedMap.get(u.pointerId);
            if (
              (!B || B.has(_.eventObject)) &&
              ((T.stopped = m.stopped = !0),
              A.hovered.size &&
                Array.from(A.hovered.values()).find(
                  (D) => D.eventObject === _.eventObject
                ))
            ) {
              const D = l.slice(0, l.indexOf(_));
              s([...D, _]);
            }
          },
          target: {
            hasPointerCapture: C,
            setPointerCapture: R,
            releasePointerCapture: P,
          },
          currentTarget: {
            hasPointerCapture: C,
            setPointerCapture: R,
            releasePointerCapture: P,
          },
          nativeEvent: u,
        };
        if ((d(T), m.stopped === !0)) break;
      }
    }
    return l;
  }
  function s(l) {
    const { internal: u } = n.getState();
    for (const h of u.hovered.values())
      if (
        !l.length ||
        !l.find(
          (d) =>
            d.object === h.object &&
            d.index === h.index &&
            d.instanceId === h.instanceId
        )
      ) {
        const p = h.eventObject.__r3f,
          m = p == null ? void 0 : p.handlers;
        if ((u.hovered.delete(Am(h)), p != null && p.eventCount)) {
          const _ = { ...h, intersections: l };
          m.onPointerOut == null || m.onPointerOut(_),
            m.onPointerLeave == null || m.onPointerLeave(_);
        }
      }
  }
  function o(l, u) {
    for (let h = 0; h < u.length; h++) {
      const d = u[h].__r3f;
      d == null ||
        d.handlers.onPointerMissed == null ||
        d.handlers.onPointerMissed(l);
    }
  }
  function a(l) {
    switch (l) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (u) => {
          const { internal: h } = n.getState();
          "pointerId" in u &&
            h.capturedMap.has(u.pointerId) &&
            requestAnimationFrame(() => {
              h.capturedMap.has(u.pointerId) &&
                (h.capturedMap.delete(u.pointerId), s([]));
            });
        };
    }
    return function (h) {
      const { onPointerMissed: d, internal: p } = n.getState();
      p.lastEvent.current = h;
      const m = l === "onPointerMove",
        _ = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick",
        x = r(h, m ? t : void 0),
        g = _ ? e(h) : 0;
      l === "onPointerDown" &&
        ((p.initialClick = [h.offsetX, h.offsetY]),
        (p.initialHits = x.map((A) => A.eventObject))),
        _ && !x.length && g <= 2 && (o(h, p.interaction), d && d(h)),
        m && s(x);
      function S(A) {
        const E = A.eventObject,
          C = E.__r3f,
          R = C == null ? void 0 : C.handlers;
        if (C != null && C.eventCount)
          if (m) {
            if (
              R.onPointerOver ||
              R.onPointerEnter ||
              R.onPointerOut ||
              R.onPointerLeave
            ) {
              const P = Am(A),
                L = p.hovered.get(P);
              L
                ? L.stopped && A.stopPropagation()
                : (p.hovered.set(P, A),
                  R.onPointerOver == null || R.onPointerOver(A),
                  R.onPointerEnter == null || R.onPointerEnter(A));
            }
            R.onPointerMove == null || R.onPointerMove(A);
          } else {
            const P = R[l];
            P
              ? (!_ || p.initialHits.includes(E)) &&
                (o(
                  h,
                  p.interaction.filter((L) => !p.initialHits.includes(L))
                ),
                P(A))
              : _ &&
                p.initialHits.includes(E) &&
                o(
                  h,
                  p.interaction.filter((L) => !p.initialHits.includes(L))
                );
          }
      }
      i(x, h, g, S);
    };
  }
  return { handlePointer: a };
}
const WL = (n) => !!(n != null && n.render),
  jL = te.createContext(null),
  FV = (n, e) => {
    const t = pV((a, l) => {
        const u = new U(),
          h = new U(),
          d = new U();
        function p(g = l().camera, S = h, A = l().size) {
          const { width: E, height: C, top: R, left: P } = A,
            L = E / C;
          S instanceof U ? d.copy(S) : d.set(...S);
          const T = g.getWorldPosition(u).distanceTo(d);
          if (OL(g))
            return {
              width: E / g.zoom,
              height: C / g.zoom,
              top: R,
              left: P,
              factor: 1,
              distance: T,
              aspect: L,
            };
          {
            const B = (g.fov * Math.PI) / 180,
              D = 2 * Math.tan(B / 2) * T,
              I = D * (E / C);
            return {
              width: I,
              height: D,
              top: R,
              left: P,
              factor: E / I,
              distance: T,
              aspect: L,
            };
          }
        }
        let m;
        const _ = (g) =>
            a((S) => ({ performance: { ...S.performance, current: g } })),
          y = new ge();
        return {
          set: a,
          get: l,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (g = 1) => n(l(), g),
          advance: (g, S) => e(g, S, l()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new U1(),
          pointer: y,
          mouse: y,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const g = l();
              m && clearTimeout(m),
                g.performance.current !== g.performance.min &&
                  _(g.performance.min),
                (m = setTimeout(
                  () => _(l().performance.max),
                  g.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: p,
          },
          setEvents: (g) => a((S) => ({ ...S, events: { ...S.events, ...g } })),
          setSize: (g, S, A, E, C) => {
            const R = l().camera,
              P = {
                width: g,
                height: S,
                top: E || 0,
                left: C || 0,
                updateStyle: A,
              };
            a((L) => ({ size: P, viewport: { ...L.viewport, ...p(R, h, P) } }));
          },
          setDpr: (g) =>
            a((S) => {
              const A = HL(g);
              return {
                viewport: {
                  ...S.viewport,
                  dpr: A,
                  initialDpr: S.viewport.initialDpr || A,
                },
              };
            }),
          setFrameloop: (g = "always") => {
            const S = l().clock;
            S.stop(),
              (S.elapsedTime = 0),
              g !== "never" && (S.start(), (S.elapsedTime = 0)),
              a(() => ({ frameloop: g }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: te.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (g, S, A) => {
              const E = l().internal;
              return (
                (E.priority = E.priority + (S > 0 ? 1 : 0)),
                E.subscribers.push({ ref: g, priority: S, store: A }),
                (E.subscribers = E.subscribers.sort(
                  (C, R) => C.priority - R.priority
                )),
                () => {
                  const C = l().internal;
                  C != null &&
                    C.subscribers &&
                    ((C.priority = C.priority - (S > 0 ? 1 : 0)),
                    (C.subscribers = C.subscribers.filter((R) => R.ref !== g)));
                }
              );
            },
          },
        };
      }),
      r = t.getState();
    let i = r.size,
      s = r.viewport.dpr,
      o = r.camera;
    return (
      t.subscribe(() => {
        const { camera: a, size: l, viewport: u, gl: h, set: d } = t.getState();
        if (l !== i || u.dpr !== s) {
          var p;
          (i = l), (s = u.dpr), BV(a, l), h.setPixelRatio(u.dpr);
          const m =
            (p = l.updateStyle) != null
              ? p
              : typeof HTMLCanvasElement < "u" &&
                h.domElement instanceof HTMLCanvasElement;
          h.setSize(l.width, l.height, m);
        }
        a !== o &&
          ((o = a),
          d((m) => ({
            viewport: { ...m.viewport, ...m.viewport.getCurrentViewport(a) },
          })));
      }),
      t.subscribe((a) => n(a)),
      t
    );
  };
let Mm,
  NV = new Set(),
  OV = new Set(),
  UV = new Set();
function vy(n, e) {
  if (n.size) for (const { callback: t } of n.values()) t(e);
}
function Df(n, e) {
  switch (n) {
    case "before":
      return vy(NV, e);
    case "after":
      return vy(OV, e);
    case "tail":
      return vy(UV, e);
  }
}
let yy, xy;
function Sy(n, e, t) {
  let r = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof n == "number" &&
      ((r = n - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = n)),
      yy = e.internal.subscribers,
      Mm = 0;
    Mm < yy.length;
    Mm++
  )
    (xy = yy[Mm]), xy.ref.current(xy.store.getState(), r, t);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function kV(n) {
  let e = !1,
    t,
    r,
    i;
  function s(l) {
    (r = requestAnimationFrame(s)), (e = !0), (t = 0), Df("before", l);
    for (const h of n.values()) {
      var u;
      (i = h.store.getState()),
        i.internal.active &&
          (i.frameloop === "always" || i.internal.frames > 0) &&
          !((u = i.gl.xr) != null && u.isPresenting) &&
          (t += Sy(l, i));
    }
    if ((Df("after", l), t === 0))
      return Df("tail", l), (e = !1), cancelAnimationFrame(r);
  }
  function o(l, u = 1) {
    var h;
    if (!l) return n.forEach((d) => o(d.store.getState()), u);
    ((h = l.gl.xr) != null && h.isPresenting) ||
      !l.internal.active ||
      l.frameloop === "never" ||
      ((l.internal.frames = Math.min(60, l.internal.frames + u)),
      e || ((e = !0), requestAnimationFrame(s)));
  }
  function a(l, u = !0, h, d) {
    if ((u && Df("before", l), h)) Sy(l, h, d);
    else for (const p of n.values()) Sy(l, p.store.getState());
    u && Df("after", l);
  }
  return { loop: s, invalidate: o, advance: a };
}
function XL() {
  const n = te.useContext(jL);
  if (!n)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function JL(n = (t) => t, e) {
  return XL()(n, e);
}
function zV(n, e = 0) {
  const t = XL(),
    r = t.getState().internal.subscribe,
    i = UL(n);
  return _d(() => r(i, e, t), [e, r, t]), null;
}
function KL(n, e) {
  return function (t, ...r) {
    const i = new t();
    return (
      n && n(i),
      Promise.all(
        r.map(
          (s) =>
            new Promise((o, a) =>
              i.load(
                s,
                (l) => {
                  l.scene && Object.assign(l, RV(l.scene)), o(l);
                },
                e,
                (l) => a(new Error(`Could not load ${s}: ${l.message})`))
              )
            )
        )
      )
    );
  };
}
function vd(n, e, t, r) {
  const i = Array.isArray(e) ? e : [e],
    s = SV(KL(t, r), [n, ...i], { equal: Qt.equ });
  return Array.isArray(e) ? s : s[0];
}
vd.preload = function (n, e, t) {
  const r = Array.isArray(e) ? e : [e];
  return AV(KL(t), [n, ...r]);
};
vd.clear = function (n, e) {
  const t = Array.isArray(e) ? e : [e];
  return MV([n, ...t]);
};
const Pc = new Map(),
  { invalidate: qT, advance: ZT } = kV(Pc),
  { reconciler: Dg, applyProps: Ru } = wV(Pc, LV),
  Pu = { objects: "shallow", strict: !1 },
  HV = (n, e) => {
    const t = typeof n == "function" ? n(e) : n;
    return WL(t)
      ? t
      : new m1({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...n,
        });
  };
function GV(n, e) {
  if (e) return e;
  if (
    typeof HTMLCanvasElement < "u" &&
    n instanceof HTMLCanvasElement &&
    n.parentElement
  ) {
    const {
      width: t,
      height: r,
      top: i,
      left: s,
    } = n.parentElement.getBoundingClientRect();
    return { width: t, height: r, top: i, left: s };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return { width: n.width, height: n.height, top: 0, left: 0 };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function VV(n) {
  const e = Pc.get(n),
    t = e == null ? void 0 : e.fiber,
    r = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? reportError : console.error,
    s = r || FV(qT, ZT),
    o =
      t ||
      Dg.createContainer(s, Qu.ConcurrentRoot, null, !1, null, "", i, null);
  e || Pc.set(n, { fiber: o, store: s });
  let a,
    l = !1,
    u;
  return {
    configure(h = {}) {
      let {
          gl: d,
          size: p,
          scene: m,
          events: _,
          onCreated: y,
          shadows: x = !1,
          linear: g = !1,
          flat: S = !1,
          legacy: A = !1,
          orthographic: E = !1,
          frameloop: C = "always",
          dpr: R = [1, 2],
          performance: P,
          raycaster: L,
          camera: T,
          onPointerMissed: B,
        } = h,
        D = s.getState(),
        I = D.gl;
      D.gl || D.set({ gl: (I = HV(d, n)) });
      let F = D.raycaster;
      F || D.set({ raycaster: (F = new bL()) });
      const { params: k, ...j } = L || {};
      if (
        (Qt.equ(j, F, Pu) || Ru(F, { ...j }),
        Qt.equ(k, F.params, Pu) || Ru(F, { params: { ...F.params, ...k } }),
        !D.camera || (D.camera === u && !Qt.equ(u, T, Pu)))
      ) {
        u = T;
        const X = T instanceof ld,
          Y = X
            ? T
            : E
            ? new Ra(0, 0, 0, 0, 0.1, 1e3)
            : new Mn(75, 0, 0.1, 1e3);
        X ||
          ((Y.position.z = 5),
          T && Ru(Y, T),
          !D.camera && !(T != null && T.rotation) && Y.lookAt(0, 0, 0)),
          D.set({ camera: Y });
      }
      if (!D.scene) {
        let X;
        m instanceof Ig ? (X = m) : ((X = new Ig()), m && Ru(X, m)),
          D.set({ scene: Iu(X) });
      }
      if (!D.xr) {
        const X = (ae, ye) => {
            const we = s.getState();
            we.frameloop !== "never" && ZT(ae, !0, we, ye);
          },
          Y = () => {
            const ae = s.getState();
            (ae.gl.xr.enabled = ae.gl.xr.isPresenting),
              ae.gl.xr.setAnimationLoop(ae.gl.xr.isPresenting ? X : null),
              ae.gl.xr.isPresenting || qT(ae);
          },
          de = {
            connect() {
              const ae = s.getState().gl;
              ae.xr.addEventListener("sessionstart", Y),
                ae.xr.addEventListener("sessionend", Y);
            },
            disconnect() {
              const ae = s.getState().gl;
              ae.xr.removeEventListener("sessionstart", Y),
                ae.xr.removeEventListener("sessionend", Y);
            },
          };
        I.xr && de.connect(), D.set({ xr: de });
      }
      if (I.shadowMap) {
        const X = I.shadowMap.enabled,
          Y = I.shadowMap.type;
        if (((I.shadowMap.enabled = !!x), Qt.boo(x))) I.shadowMap.type = nh;
        else if (Qt.str(x)) {
          var Z;
          const de = { basic: BB, percentage: _0, soft: nh, variance: Zi };
          I.shadowMap.type = (Z = de[x]) != null ? Z : nh;
        } else Qt.obj(x) && Object.assign(I.shadowMap, x);
        (X !== I.shadowMap.enabled || Y !== I.shadowMap.type) &&
          (I.shadowMap.needsUpdate = !0);
      }
      const Q = NL();
      Q &&
        ("enabled" in Q
          ? (Q.enabled = !A)
          : "legacyMode" in Q && (Q.legacyMode = A)),
        Ru(I, { outputEncoding: g ? 3e3 : 3001, toneMapping: S ? is : QA }),
        D.legacy !== A && D.set(() => ({ legacy: A })),
        D.linear !== g && D.set(() => ({ linear: g })),
        D.flat !== S && D.set(() => ({ flat: S })),
        d && !Qt.fun(d) && !WL(d) && !Qt.equ(d, I, Pu) && Ru(I, d),
        _ && !D.events.handlers && D.set({ events: _(s) });
      const G = GV(n, p);
      return (
        Qt.equ(G, D.size, Pu) ||
          D.setSize(G.width, G.height, G.updateStyle, G.top, G.left),
        R && D.viewport.dpr !== HL(R) && D.setDpr(R),
        D.frameloop !== C && D.setFrameloop(C),
        D.onPointerMissed || D.set({ onPointerMissed: B }),
        P &&
          !Qt.equ(P, D.performance, Pu) &&
          D.set((X) => ({ performance: { ...X.performance, ...P } })),
        (a = y),
        (l = !0),
        this
      );
    },
    render(h) {
      return (
        l || this.configure(),
        Dg.updateContainer(
          te.createElement(WV, {
            store: s,
            children: h,
            onCreated: a,
            rootElement: n,
          }),
          o,
          null,
          () => {}
        ),
        s
      );
    },
    unmount() {
      YL(n);
    },
  };
}
function WV({ store: n, children: e, onCreated: t, rootElement: r }) {
  return (
    _d(() => {
      const i = n.getState();
      i.set((s) => ({ internal: { ...s.internal, active: !0 } })),
        t && t(i),
        n.getState().events.connected ||
          i.events.connect == null ||
          i.events.connect(r);
    }, []),
    te.createElement(jL.Provider, { value: n }, e)
  );
}
function YL(n, e) {
  const t = Pc.get(n),
    r = t == null ? void 0 : t.fiber;
  if (r) {
    const i = t == null ? void 0 : t.store.getState();
    i && (i.internal.active = !1),
      Dg.updateContainer(null, r, null, () => {
        i &&
          setTimeout(() => {
            try {
              var s, o, a, l;
              i.events.disconnect == null || i.events.disconnect(),
                (s = i.gl) == null ||
                  (o = s.renderLists) == null ||
                  o.dispose == null ||
                  o.dispose(),
                (a = i.gl) == null ||
                  a.forceContextLoss == null ||
                  a.forceContextLoss(),
                (l = i.gl) != null && l.xr && i.xr.disconnect(),
                PV(i),
                Pc.delete(n),
                e && e(n);
            } catch {}
          }, 500);
      });
  }
}
Dg.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: te.version,
});
function Gh() {
  return (
    (Gh = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)
              Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }),
    Gh.apply(this, arguments)
  );
}
function CS(n, e, t) {
  var r, i, s, o, a;
  e == null && (e = 100);
  function l() {
    var h = Date.now() - o;
    h < e && h >= 0
      ? (r = setTimeout(l, e - h))
      : ((r = null), t || ((a = n.apply(s, i)), (s = i = null)));
  }
  var u = function () {
    (s = this), (i = arguments), (o = Date.now());
    var h = t && !r;
    return (
      r || (r = setTimeout(l, e)), h && ((a = n.apply(s, i)), (s = i = null)), a
    );
  };
  return (
    (u.clear = function () {
      r && (clearTimeout(r), (r = null));
    }),
    (u.flush = function () {
      r && ((a = n.apply(s, i)), (s = i = null), clearTimeout(r), (r = null));
    }),
    u
  );
}
CS.debounce = CS;
var jV = CS;
const $T = Nc(jV);
function XV(n) {
  let {
    debounce: e,
    scroll: t,
    polyfill: r,
    offsetSize: i,
  } = n === void 0 ? { debounce: 0, scroll: !1, offsetSize: !1 } : n;
  const s = r || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!s)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [o, a] = te.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    l = te.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: o,
    }),
    u = e ? (typeof e == "number" ? e : e.scroll) : null,
    h = e ? (typeof e == "number" ? e : e.resize) : null,
    d = te.useRef(!1);
  te.useEffect(() => ((d.current = !0), () => void (d.current = !1)));
  const [p, m, _] = te.useMemo(() => {
    const S = () => {
      if (!l.current.element) return;
      const {
          left: A,
          top: E,
          width: C,
          height: R,
          bottom: P,
          right: L,
          x: T,
          y: B,
        } = l.current.element.getBoundingClientRect(),
        D = {
          left: A,
          top: E,
          width: C,
          height: R,
          bottom: P,
          right: L,
          x: T,
          y: B,
        };
      l.current.element instanceof HTMLElement &&
        i &&
        ((D.height = l.current.element.offsetHeight),
        (D.width = l.current.element.offsetWidth)),
        Object.freeze(D),
        d.current &&
          !QV(l.current.lastBounds, D) &&
          a((l.current.lastBounds = D));
    };
    return [S, h ? $T(S, h) : S, u ? $T(S, u) : S];
  }, [a, i, u, h]);
  function y() {
    l.current.scrollContainers &&
      (l.current.scrollContainers.forEach((S) =>
        S.removeEventListener("scroll", _, !0)
      ),
      (l.current.scrollContainers = null)),
      l.current.resizeObserver &&
        (l.current.resizeObserver.disconnect(),
        (l.current.resizeObserver = null));
  }
  function x() {
    l.current.element &&
      ((l.current.resizeObserver = new s(_)),
      l.current.resizeObserver.observe(l.current.element),
      t &&
        l.current.scrollContainers &&
        l.current.scrollContainers.forEach((S) =>
          S.addEventListener("scroll", _, { capture: !0, passive: !0 })
        ));
  }
  const g = (S) => {
    !S ||
      S === l.current.element ||
      (y(), (l.current.element = S), (l.current.scrollContainers = QL(S)), x());
  };
  return (
    KV(_, !!t),
    JV(m),
    te.useEffect(() => {
      y(), x();
    }, [t, _, m]),
    te.useEffect(() => y, []),
    [g, o, p]
  );
}
function JV(n) {
  te.useEffect(() => {
    const e = n;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [n]);
}
function KV(n, e) {
  te.useEffect(() => {
    if (e) {
      const t = n;
      return (
        window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0)
      );
    }
  }, [n, e]);
}
function QL(n) {
  const e = [];
  if (!n || n === document.body) return e;
  const {
    overflow: t,
    overflowX: r,
    overflowY: i,
  } = window.getComputedStyle(n);
  return (
    [t, r, i].some((s) => s === "auto" || s === "scroll") && e.push(n),
    [...e, ...QL(n.parentElement)]
  );
}
const YV = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  QV = (n, e) => YV.every((t) => n[t] === e[t]);
var qV = Object.defineProperty,
  ZV = Object.defineProperties,
  $V = Object.getOwnPropertyDescriptors,
  eb = Object.getOwnPropertySymbols,
  e6 = Object.prototype.hasOwnProperty,
  t6 = Object.prototype.propertyIsEnumerable,
  tb = (n, e, t) =>
    e in n
      ? qV(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  nb = (n, e) => {
    for (var t in e || (e = {})) e6.call(e, t) && tb(n, t, e[t]);
    if (eb) for (var t of eb(e)) t6.call(e, t) && tb(n, t, e[t]);
    return n;
  },
  n6 = (n, e) => ZV(n, $V(e));
function qL(n, e, t) {
  if (!n) return;
  if (t(n) === !0) return n;
  let r = e ? n.return : n.child;
  for (; r; ) {
    const i = qL(r, e, t);
    if (i) return i;
    r = e ? null : r.sibling;
  }
}
function ZL(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return n;
  }
}
const V1 = ZL(te.createContext(null));
class $L extends te.Component {
  render() {
    return te.createElement(
      V1.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
const { ReactCurrentOwner: rb, ReactCurrentDispatcher: ib } =
  te.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function r6() {
  const n = te.useContext(V1);
  if (n === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = te.useId();
  return te.useMemo(() => {
    for (const r of [
      rb == null ? void 0 : rb.current,
      n,
      n == null ? void 0 : n.alternate,
    ]) {
      if (!r) continue;
      const i = qL(r, !1, (s) => {
        let o = s.memoizedState;
        for (; o; ) {
          if (o.memoizedState === e) return !0;
          o = o.next;
        }
      });
      if (i) return i;
    }
  }, [n, e]);
}
function i6() {
  var n, e;
  const t = r6(),
    [r] = te.useState(() => new Map());
  r.clear();
  let i = t;
  for (; i; ) {
    const s = (n = i.type) == null ? void 0 : n._context;
    s &&
      s !== V1 &&
      !r.has(s) &&
      r.set(
        s,
        (e = ib == null ? void 0 : ib.current) == null
          ? void 0
          : e.readContext(ZL(s))
      ),
      (i = i.return);
  }
  return r;
}
function s6() {
  const n = i6();
  return te.useMemo(
    () =>
      Array.from(n.keys()).reduce(
        (e, t) => (r) =>
          te.createElement(
            e,
            null,
            te.createElement(t.Provider, n6(nb({}, r), { value: n.get(t) }))
          ),
        (e) => te.createElement($L, nb({}, e))
      ),
    [n]
  );
}
const Ay = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function o6(n) {
  const { handlePointer: e } = DV(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, r, i) {
      r.pointer.set(
        (t.offsetX / r.size.width) * 2 - 1,
        -(t.offsetY / r.size.height) * 2 + 1
      ),
        r.raycaster.setFromCamera(r.pointer, r.camera);
    },
    connected: void 0,
    handlers: Object.keys(Ay).reduce((t, r) => ({ ...t, [r]: e(r) }), {}),
    update: () => {
      var t;
      const { events: r, internal: i } = n.getState();
      (t = i.lastEvent) != null &&
        t.current &&
        r.handlers &&
        r.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (t) => {
      var r;
      const { set: i, events: s } = n.getState();
      s.disconnect == null || s.disconnect(),
        i((o) => ({ events: { ...o.events, connected: t } })),
        Object.entries((r = s.handlers) != null ? r : []).forEach(([o, a]) => {
          const [l, u] = Ay[o];
          t.addEventListener(l, a, { passive: u });
        });
    },
    disconnect: () => {
      const { set: t, events: r } = n.getState();
      if (r.connected) {
        var i;
        Object.entries((i = r.handlers) != null ? i : []).forEach(([s, o]) => {
          if (r && r.connected instanceof HTMLElement) {
            const [a] = Ay[s];
            r.connected.removeEventListener(a, o);
          }
        }),
          t((s) => ({ events: { ...s.events, connected: void 0 } }));
      }
    },
  };
}
const a6 = te.forwardRef(function (
    {
      children: e,
      fallback: t,
      resize: r,
      style: i,
      gl: s,
      events: o = o6,
      eventSource: a,
      eventPrefix: l,
      shadows: u,
      linear: h,
      flat: d,
      legacy: p,
      orthographic: m,
      frameloop: _,
      dpr: y,
      performance: x,
      raycaster: g,
      camera: S,
      onPointerMissed: A,
      onCreated: E,
      ...C
    },
    R
  ) {
    te.useMemo(() => EV(fV), []);
    const P = s6(),
      [L, T] = XV({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...r }),
      B = te.useRef(null),
      D = te.useRef(null);
    te.useImperativeHandle(R, () => B.current);
    const I = UL(A),
      [F, k] = te.useState(!1),
      [j, Z] = te.useState(!1);
    if (F) throw F;
    if (j) throw j;
    const Q = te.useRef(null);
    _d(() => {
      const W = B.current;
      T.width > 0 &&
        T.height > 0 &&
        W &&
        (Q.current || (Q.current = VV(W)),
        Q.current.configure({
          gl: s,
          events: o,
          shadows: u,
          linear: h,
          flat: d,
          legacy: p,
          orthographic: m,
          frameloop: _,
          dpr: y,
          performance: x,
          raycaster: g,
          camera: S,
          size: T,
          onPointerMissed: (...G) =>
            I.current == null ? void 0 : I.current(...G),
          onCreated: (G) => {
            G.events.connect == null ||
              G.events.connect(a ? (CV(a) ? a.current : a) : D.current),
              l &&
                G.setEvents({
                  compute: (X, Y) => {
                    const de = X[l + "X"],
                      ae = X[l + "Y"];
                    Y.pointer.set(
                      (de / Y.size.width) * 2 - 1,
                      -(ae / Y.size.height) * 2 + 1
                    ),
                      Y.raycaster.setFromCamera(Y.pointer, Y.camera);
                  },
                }),
              E == null || E(G);
          },
        }),
        Q.current.render(
          te.createElement(
            P,
            null,
            te.createElement(
              kL,
              { set: Z },
              te.createElement(
                te.Suspense,
                { fallback: te.createElement(TV, { set: k }) },
                e
              )
            )
          )
        ));
    }),
      te.useEffect(() => {
        const W = B.current;
        if (W) return () => YL(W);
      }, []);
    const N = a ? "none" : "auto";
    return te.createElement(
      "div",
      Gh(
        {
          ref: D,
          style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            pointerEvents: N,
            ...i,
          },
        },
        C
      ),
      te.createElement(
        "div",
        { ref: L, style: { width: "100%", height: "100%" } },
        te.createElement("canvas", { ref: B, style: { display: "block" } }, t)
      )
    );
  }),
  l6 = te.forwardRef(function (e, t) {
    return te.createElement(
      $L,
      null,
      te.createElement(a6, Gh({}, e, { ref: t }))
    );
  }),
  yd = new U(),
  W1 = new U(),
  u6 = new U();
function c6(n, e, t) {
  const r = yd.setFromMatrixPosition(n.matrixWorld);
  r.project(e);
  const i = t.width / 2,
    s = t.height / 2;
  return [r.x * i + i, -(r.y * s) + s];
}
function f6(n, e) {
  const t = yd.setFromMatrixPosition(n.matrixWorld),
    r = W1.setFromMatrixPosition(e.matrixWorld),
    i = t.sub(r),
    s = e.getWorldDirection(u6);
  return i.angleTo(s) > Math.PI / 2;
}
function h6(n, e, t, r) {
  const i = yd.setFromMatrixPosition(n.matrixWorld),
    s = i.clone();
  s.project(e), t.setFromCamera(s, e);
  const o = t.intersectObjects(r, !0);
  if (o.length) {
    const a = o[0].distance;
    return i.distanceTo(t.ray.origin) < a;
  }
  return !0;
}
function d6(n, e) {
  if (e instanceof Ra) return e.zoom;
  if (e instanceof Mn) {
    const t = yd.setFromMatrixPosition(n.matrixWorld),
      r = W1.setFromMatrixPosition(e.matrixWorld),
      i = (e.fov * Math.PI) / 180,
      s = t.distanceTo(r);
    return 1 / (2 * Math.tan(i / 2) * s);
  } else return 1;
}
function p6(n, e, t) {
  if (e instanceof Mn || e instanceof Ra) {
    const r = yd.setFromMatrixPosition(n.matrixWorld),
      i = W1.setFromMatrixPosition(e.matrixWorld),
      s = r.distanceTo(i),
      o = (t[1] - t[0]) / (e.far - e.near),
      a = t[1] - o * e.far;
    return Math.round(o * s + a);
  }
}
const TS = (n) => (Math.abs(n) < 1e-10 ? 0 : n);
function eI(n, e, t = "") {
  let r = "matrix3d(";
  for (let i = 0; i !== 16; i++)
    r += TS(e[i] * n.elements[i]) + (i !== 15 ? "," : ")");
  return t + r;
}
const m6 = (
    (n) => (e) =>
      eI(e, n)
  )([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]),
  g6 = (
    (n) => (e, t) =>
      eI(e, n(t), "translate(-50%,-50%)")
  )((n) => [
    1 / n,
    1 / n,
    1 / n,
    1,
    -1 / n,
    -1 / n,
    -1 / n,
    -1,
    1 / n,
    1 / n,
    1 / n,
    1,
    1,
    1,
    1,
    1,
  ]);
function _6(n) {
  return n && typeof n == "object" && "current" in n;
}
const sb = te.forwardRef(
  (
    {
      children: n,
      eps: e = 0.001,
      style: t,
      className: r,
      prepend: i,
      center: s,
      fullscreen: o,
      portal: a,
      distanceFactor: l,
      sprite: u = !1,
      transform: h = !1,
      occlude: d,
      onOcclude: p,
      castShadow: m,
      receiveShadow: _,
      material: y,
      geometry: x,
      zIndexRange: g = [16777271, 0],
      calculatePosition: S = c6,
      as: A = "div",
      wrapperClass: E,
      pointerEvents: C = "auto",
      ...R
    },
    P
  ) => {
    const {
        gl: L,
        camera: T,
        scene: B,
        size: D,
        raycaster: I,
        events: F,
        viewport: k,
      } = JL(),
      [j] = te.useState(() => document.createElement(A)),
      Z = te.useRef(),
      Q = te.useRef(null),
      N = te.useRef(0),
      W = te.useRef([0, 0]),
      G = te.useRef(null),
      X = te.useRef(null),
      Y =
        (a == null ? void 0 : a.current) ||
        F.connected ||
        L.domElement.parentNode,
      de = te.useRef(null),
      ae = te.useRef(!1),
      ye = te.useMemo(
        () =>
          (d && d !== "blending") || (Array.isArray(d) && d.length && _6(d[0])),
        [d]
      );
    te.useLayoutEffect(() => {
      const lt = L.domElement;
      d && d === "blending"
        ? ((lt.style.zIndex = `${Math.floor(g[0] / 2)}`),
          (lt.style.position = "absolute"),
          (lt.style.pointerEvents = "none"))
        : ((lt.style.zIndex = null),
          (lt.style.position = null),
          (lt.style.pointerEvents = null));
    }, [d]),
      te.useLayoutEffect(() => {
        if (Q.current) {
          const lt = (Z.current = JP(j));
          if ((B.updateMatrixWorld(), h))
            j.style.cssText =
              "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
          else {
            const Ce = S(Q.current, T, D);
            j.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${Ce[0]}px,${Ce[1]}px,0);transform-origin:0 0;`;
          }
          return (
            Y && (i ? Y.prepend(j) : Y.appendChild(j)),
            () => {
              Y && Y.removeChild(j), lt.unmount();
            }
          );
        }
      }, [Y, h]),
      te.useLayoutEffect(() => {
        E && (j.className = E);
      }, [E]);
    const we = te.useMemo(
        () =>
          h
            ? {
                position: "absolute",
                top: 0,
                left: 0,
                width: D.width,
                height: D.height,
                transformStyle: "preserve-3d",
                pointerEvents: "none",
              }
            : {
                position: "absolute",
                transform: s ? "translate3d(-50%,-50%,0)" : "none",
                ...(o && {
                  top: -D.height / 2,
                  left: -D.width / 2,
                  width: D.width,
                  height: D.height,
                }),
                ...t,
              },
        [t, s, o, D, h]
      ),
      Ne = te.useMemo(() => ({ position: "absolute", pointerEvents: C }), [C]);
    te.useLayoutEffect(() => {
      if (((ae.current = !1), h)) {
        var lt;
        (lt = Z.current) == null ||
          lt.render(
            te.createElement(
              "div",
              { ref: G, style: we },
              te.createElement(
                "div",
                { ref: X, style: Ne },
                te.createElement("div", {
                  ref: P,
                  className: r,
                  style: t,
                  children: n,
                })
              )
            )
          );
      } else {
        var Ce;
        (Ce = Z.current) == null ||
          Ce.render(
            te.createElement("div", {
              ref: P,
              style: we,
              className: r,
              children: n,
            })
          );
      }
    });
    const je = te.useRef(!0);
    zV((lt) => {
      if (Q.current) {
        T.updateMatrixWorld(), Q.current.updateWorldMatrix(!0, !1);
        const Ce = h ? W.current : S(Q.current, T, D);
        if (
          h ||
          Math.abs(N.current - T.zoom) > e ||
          Math.abs(W.current[0] - Ce[0]) > e ||
          Math.abs(W.current[1] - Ce[1]) > e
        ) {
          const K = f6(Q.current, T);
          let _e = !1;
          ye &&
            (d !== "blending"
              ? (_e = [B])
              : Array.isArray(d) && (_e = d.map((Ge) => Ge.current)));
          const pe = je.current;
          if (_e) {
            const Ge = h6(Q.current, T, I, _e);
            je.current = Ge && !K;
          } else je.current = !K;
          pe !== je.current &&
            (p
              ? p(!je.current)
              : (j.style.display = je.current ? "block" : "none"));
          const Ae = Math.floor(g[0] / 2),
            ve = d ? (ye ? [g[0], Ae] : [Ae - 1, 0]) : g;
          if (((j.style.zIndex = `${p6(Q.current, T, ve)}`), h)) {
            const [Ge, Oe] = [D.width / 2, D.height / 2],
              Ue = T.projectionMatrix.elements[5] * Oe,
              {
                isOrthographicCamera: Qe,
                top: yt,
                left: Vt,
                bottom: V,
                right: O,
              } = T,
              ue = m6(T.matrixWorldInverse),
              Me = Qe
                ? `scale(${Ue})translate(${TS(-(O + Vt) / 2)}px,${TS(
                    (yt + V) / 2
                  )}px)`
                : `translateZ(${Ue}px)`;
            let xe = Q.current.matrixWorld;
            u &&
              ((xe = T.matrixWorldInverse
                .clone()
                .transpose()
                .copyPosition(xe)
                .scale(Q.current.scale)),
              (xe.elements[3] = xe.elements[7] = xe.elements[11] = 0),
              (xe.elements[15] = 1)),
              (j.style.width = D.width + "px"),
              (j.style.height = D.height + "px"),
              (j.style.perspective = Qe ? "" : `${Ue}px`),
              G.current &&
                X.current &&
                ((G.current.style.transform = `${Me}${ue}translate(${Ge}px,${Oe}px)`),
                (X.current.style.transform = g6(xe, 1 / ((l || 10) / 400))));
          } else {
            const Ge = l === void 0 ? 1 : d6(Q.current, T) * l;
            j.style.transform = `translate3d(${Ce[0]}px,${Ce[1]}px,0) scale(${Ge})`;
          }
          (W.current = Ce), (N.current = T.zoom);
        }
      }
      if (!ye && de.current && !ae.current)
        if (h) {
          if (G.current) {
            const Ce = G.current.children[0];
            if (Ce != null && Ce.clientWidth && Ce != null && Ce.clientHeight) {
              const { isOrthographicCamera: K } = T;
              if (K || x)
                R.scale &&
                  (Array.isArray(R.scale)
                    ? R.scale instanceof U
                      ? de.current.scale.copy(R.scale.clone().divideScalar(1))
                      : de.current.scale.set(
                          1 / R.scale[0],
                          1 / R.scale[1],
                          1 / R.scale[2]
                        )
                    : de.current.scale.setScalar(1 / R.scale));
              else {
                const _e = (l || 10) / 400,
                  pe = Ce.clientWidth * _e,
                  Ae = Ce.clientHeight * _e;
                de.current.scale.set(pe, Ae, 1);
              }
              ae.current = !0;
            }
          }
        } else {
          const Ce = j.children[0];
          if (Ce != null && Ce.clientWidth && Ce != null && Ce.clientHeight) {
            const K = 1 / k.factor,
              _e = Ce.clientWidth * K,
              pe = Ce.clientHeight * K;
            de.current.scale.set(_e, pe, 1), (ae.current = !0);
          }
          de.current.lookAt(lt.camera.position);
        }
    });
    const At = te.useMemo(
      () => ({
        vertexShader: h
          ? void 0
          : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
        fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `,
      }),
      [h]
    );
    return te.createElement(
      "group",
      Gh({}, R, { ref: Q }),
      d &&
        !ye &&
        te.createElement(
          "mesh",
          { castShadow: m, receiveShadow: _, ref: de },
          x || te.createElement("planeGeometry", null),
          y ||
            te.createElement("shaderMaterial", {
              side: Li,
              vertexShader: At.vertexShader,
              fragmentShader: At.fragmentShader,
            })
        )
    );
  }
);
function ob(n, e) {
  if (e === m2)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      n
    );
  if (e === Pg || e === i1) {
    let t = n.getIndex();
    if (t === null) {
      const o = [],
        a = n.getAttribute("position");
      if (a !== void 0) {
        for (let l = 0; l < a.count; l++) o.push(l);
        n.setIndex(o), (t = n.getIndex());
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          n
        );
    }
    const r = t.count - 2,
      i = [];
    if (t)
      if (e === Pg)
        for (let o = 1; o <= r; o++)
          i.push(t.getX(0)), i.push(t.getX(o)), i.push(t.getX(o + 1));
      else
        for (let o = 0; o < r; o++)
          o % 2 === 0
            ? (i.push(t.getX(o)), i.push(t.getX(o + 1)), i.push(t.getX(o + 2)))
            : (i.push(t.getX(o + 2)), i.push(t.getX(o + 1)), i.push(t.getX(o)));
    i.length / 3 !== r &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const s = n.clone();
    return s.setIndex(i), s.clearGroups(), s;
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e
      ),
      n
    );
}
class j1 extends xr {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new A6(t);
      }),
      this.register(function (t) {
        return new P6(t);
      }),
      this.register(function (t) {
        return new B6(t);
      }),
      this.register(function (t) {
        return new L6(t);
      }),
      this.register(function (t) {
        return new E6(t);
      }),
      this.register(function (t) {
        return new w6(t);
      }),
      this.register(function (t) {
        return new C6(t);
      }),
      this.register(function (t) {
        return new T6(t);
      }),
      this.register(function (t) {
        return new S6(t);
      }),
      this.register(function (t) {
        return new b6(t);
      }),
      this.register(function (t) {
        return new M6(t);
      }),
      this.register(function (t) {
        return new R6(t);
      }),
      this.register(function (t) {
        return new y6(t);
      }),
      this.register(function (t) {
        return new I6(t);
      }),
      this.register(function (t) {
        return new D6(t);
      });
  }
  load(e, t, r, i) {
    const s = this;
    let o;
    this.resourcePath !== ""
      ? (o = this.resourcePath)
      : this.path !== ""
      ? (o = this.path)
      : (o = Is.extractUrlBase(e)),
      this.manager.itemStart(e);
    const a = function (u) {
        i ? i(u) : console.error(u),
          s.manager.itemError(e),
          s.manager.itemEnd(e);
      },
      l = new hi(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (u) {
          try {
            s.parse(
              u,
              o,
              function (h) {
                t(h), s.manager.itemEnd(e);
              },
              a
            );
          } catch (h) {
            a(h);
          }
        },
        r,
        a
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, r, i) {
    let s;
    const o = {},
      a = {};
    if (typeof e == "string") s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (Is.decodeText(new Uint8Array(e.slice(0, 4))) === tI) {
        try {
          o[wt.KHR_BINARY_GLTF] = new F6(e);
        } catch (h) {
          i && i(h);
          return;
        }
        s = JSON.parse(o[wt.KHR_BINARY_GLTF].content);
      } else s = JSON.parse(Is.decodeText(new Uint8Array(e)));
    else s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      i &&
        i(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const l = new K6(s, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const h = this.pluginCallbacks[u](l);
      (a[h.name] = h), (o[h.name] = !0);
    }
    if (s.extensionsUsed)
      for (let u = 0; u < s.extensionsUsed.length; ++u) {
        const h = s.extensionsUsed[u],
          d = s.extensionsRequired || [];
        switch (h) {
          case wt.KHR_MATERIALS_UNLIT:
            o[h] = new x6();
            break;
          case wt.KHR_DRACO_MESH_COMPRESSION:
            o[h] = new N6(s, this.dracoLoader);
            break;
          case wt.KHR_TEXTURE_TRANSFORM:
            o[h] = new O6();
            break;
          case wt.KHR_MESH_QUANTIZATION:
            o[h] = new U6();
            break;
          default:
            d.indexOf(h) >= 0 &&
              a[h] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
        }
      }
    l.setExtensions(o), l.setPlugins(a), l.parse(r, i);
  }
  parseAsync(e, t) {
    const r = this;
    return new Promise(function (i, s) {
      r.parse(e, t, i, s);
    });
  }
}
function v6() {
  let n = {};
  return {
    get: function (e) {
      return n[e];
    },
    add: function (e, t) {
      n[e] = t;
    },
    remove: function (e) {
      delete n[e];
    },
    removeAll: function () {
      n = {};
    },
  };
}
const wt = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class y6 {
  constructor(e) {
    (this.parser = e),
      (this.name = wt.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let r = 0, i = t.length; r < i; r++) {
      const s = t[r];
      s.extensions &&
        s.extensions[this.name] &&
        s.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      r = "light:" + e;
    let i = t.cache.get(r);
    if (i) return i;
    const s = t.json,
      l = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e];
    let u;
    const h = new Be(16777215);
    l.color !== void 0 && h.fromArray(l.color);
    const d = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        (u = new N1(h)), u.target.position.set(0, 0, -1), u.add(u.target);
        break;
      case "point":
        (u = new F1(h)), (u.distance = d);
        break;
      case "spot":
        (u = new D1(h)),
          (u.distance = d),
          (l.spot = l.spot || {}),
          (l.spot.innerConeAngle =
            l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
          (l.spot.outerConeAngle =
            l.spot.outerConeAngle !== void 0
              ? l.spot.outerConeAngle
              : Math.PI / 4),
          (u.angle = l.spot.outerConeAngle),
          (u.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
          u.target.position.set(0, 0, -1),
          u.add(u.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return (
      u.position.set(0, 0, 0),
      (u.decay = 2),
      jo(u, l),
      l.intensity !== void 0 && (u.intensity = l.intensity),
      (u.name = t.createUniqueName(l.name || "light_" + e)),
      (i = Promise.resolve(u)),
      t.cache.add(r, i),
      i
    );
  }
  getDependency(e, t) {
    if (e === "light") return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      r = this.parser,
      s = r.json.nodes[e],
      a = ((s.extensions && s.extensions[this.name]) || {}).light;
    return a === void 0
      ? null
      : this._loadLight(a).then(function (l) {
          return r._getNodeRef(t.cache, a, l);
        });
  }
}
class x6 {
  constructor() {
    this.name = wt.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return kr;
  }
  extendParams(e, t, r) {
    const i = [];
    (e.color = new Be(1, 1, 1)), (e.opacity = 1);
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const o = s.baseColorFactor;
        e.color.fromArray(o), (e.opacity = o[3]);
      }
      s.baseColorTexture !== void 0 &&
        i.push(r.assignTexture(e, "map", s.baseColorTexture, 3001));
    }
    return Promise.all(i);
  }
}
class S6 {
  constructor(e) {
    (this.parser = e), (this.name = wt.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = i.extensions[this.name].emissiveStrength;
    return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
  }
}
class A6 {
  constructor(e) {
    (this.parser = e), (this.name = wt.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : zs;
  }
  extendMaterialParams(e, t) {
    const r = this.parser,
      i = r.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = i.extensions[this.name];
    if (
      (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
      o.clearcoatTexture !== void 0 &&
        s.push(r.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
      o.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
      o.clearcoatRoughnessTexture !== void 0 &&
        s.push(
          r.assignTexture(
            t,
            "clearcoatRoughnessMap",
            o.clearcoatRoughnessTexture
          )
        ),
      o.clearcoatNormalTexture !== void 0 &&
        (s.push(
          r.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)
        ),
        o.clearcoatNormalTexture.scale !== void 0))
    ) {
      const a = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new ge(a, a);
    }
    return Promise.all(s);
  }
}
class M6 {
  constructor(e) {
    (this.parser = e), (this.name = wt.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : zs;
  }
  extendMaterialParams(e, t) {
    const r = this.parser,
      i = r.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = i.extensions[this.name];
    return (
      o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
      o.iridescenceTexture !== void 0 &&
        s.push(r.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
      o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      o.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
      o.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
      o.iridescenceThicknessTexture !== void 0 &&
        s.push(
          r.assignTexture(
            t,
            "iridescenceThicknessMap",
            o.iridescenceThicknessTexture
          )
        ),
      Promise.all(s)
    );
  }
}
class E6 {
  constructor(e) {
    (this.parser = e), (this.name = wt.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : zs;
  }
  extendMaterialParams(e, t) {
    const r = this.parser,
      i = r.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [];
    (t.sheenColor = new Be(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const o = i.extensions[this.name];
    return (
      o.sheenColorFactor !== void 0 &&
        t.sheenColor.fromArray(o.sheenColorFactor),
      o.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = o.sheenRoughnessFactor),
      o.sheenColorTexture !== void 0 &&
        s.push(r.assignTexture(t, "sheenColorMap", o.sheenColorTexture, 3001)),
      o.sheenRoughnessTexture !== void 0 &&
        s.push(
          r.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)
        ),
      Promise.all(s)
    );
  }
}
class w6 {
  constructor(e) {
    (this.parser = e), (this.name = wt.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : zs;
  }
  extendMaterialParams(e, t) {
    const r = this.parser,
      i = r.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = i.extensions[this.name];
    return (
      o.transmissionFactor !== void 0 &&
        (t.transmission = o.transmissionFactor),
      o.transmissionTexture !== void 0 &&
        s.push(r.assignTexture(t, "transmissionMap", o.transmissionTexture)),
      Promise.all(s)
    );
  }
}
class C6 {
  constructor(e) {
    (this.parser = e), (this.name = wt.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : zs;
  }
  extendMaterialParams(e, t) {
    const r = this.parser,
      i = r.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = i.extensions[this.name];
    (t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0),
      o.thicknessTexture !== void 0 &&
        s.push(r.assignTexture(t, "thicknessMap", o.thicknessTexture)),
      (t.attenuationDistance = o.attenuationDistance || 1 / 0);
    const a = o.attenuationColor || [1, 1, 1];
    return (t.attenuationColor = new Be(a[0], a[1], a[2])), Promise.all(s);
  }
}
class T6 {
  constructor(e) {
    (this.parser = e), (this.name = wt.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : zs;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = i.extensions[this.name];
    return (t.ior = s.ior !== void 0 ? s.ior : 1.5), Promise.resolve();
  }
}
class b6 {
  constructor(e) {
    (this.parser = e), (this.name = wt.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : zs;
  }
  extendMaterialParams(e, t) {
    const r = this.parser,
      i = r.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = i.extensions[this.name];
    (t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1),
      o.specularTexture !== void 0 &&
        s.push(r.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const a = o.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new Be(a[0], a[1], a[2])),
      o.specularColorTexture !== void 0 &&
        s.push(
          r.assignTexture(t, "specularColorMap", o.specularColorTexture, 3001)
        ),
      Promise.all(s)
    );
  }
}
class R6 {
  constructor(e) {
    (this.parser = e), (this.name = wt.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(e) {
    const r = this.parser.json.materials[e];
    return !r.extensions || !r.extensions[this.name] ? null : zs;
  }
  extendMaterialParams(e, t) {
    const r = this.parser,
      i = r.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = i.extensions[this.name];
    return (
      o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength),
      o.anisotropyRotation !== void 0 &&
        (t.anisotropyRotation = o.anisotropyRotation),
      o.anisotropyTexture !== void 0 &&
        s.push(r.assignTexture(t, "anisotropyMap", o.anisotropyTexture)),
      Promise.all(s)
    );
  }
}
class P6 {
  constructor(e) {
    (this.parser = e), (this.name = wt.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      r = t.json,
      i = r.textures[e];
    if (!i.extensions || !i.extensions[this.name]) return null;
    const s = i.extensions[this.name],
      o = t.options.ktx2Loader;
    if (!o) {
      if (r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, s.source, o);
  }
}
class B6 {
  constructor(e) {
    (this.parser = e),
      (this.name = wt.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      r = this.parser,
      i = r.json,
      s = i.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const o = s.extensions[t],
      a = i.images[o.source];
    let l = r.textureLoader;
    if (a.uri) {
      const u = r.options.manager.getHandler(a.uri);
      u !== null && (l = u);
    }
    return this.detectSupport().then(function (u) {
      if (u) return r.loadTextureImage(e, o.source, l);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return r.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class L6 {
  constructor(e) {
    (this.parser = e),
      (this.name = wt.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      r = this.parser,
      i = r.json,
      s = i.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const o = s.extensions[t],
      a = i.images[o.source];
    let l = r.textureLoader;
    if (a.uri) {
      const u = r.options.manager.getHandler(a.uri);
      u !== null && (l = u);
    }
    return this.detectSupport().then(function (u) {
      if (u) return r.loadTextureImage(e, o.source, l);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        );
      return r.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class I6 {
  constructor(e) {
    (this.name = wt.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      r = t.bufferViews[e];
    if (r.extensions && r.extensions[this.name]) {
      const i = r.extensions[this.name],
        s = this.parser.getDependency("buffer", i.buffer),
        o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return s.then(function (a) {
        const l = i.byteOffset || 0,
          u = i.byteLength || 0,
          h = i.count,
          d = i.byteStride,
          p = new Uint8Array(a, l, u);
        return o.decodeGltfBufferAsync
          ? o
              .decodeGltfBufferAsync(h, d, p, i.mode, i.filter)
              .then(function (m) {
                return m.buffer;
              })
          : o.ready.then(function () {
              const m = new ArrayBuffer(h * d);
              return (
                o.decodeGltfBuffer(
                  new Uint8Array(m),
                  h,
                  d,
                  p,
                  i.mode,
                  i.filter
                ),
                m
              );
            });
      });
    } else return null;
  }
}
class D6 {
  constructor(e) {
    (this.name = wt.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      r = t.nodes[e];
    if (!r.extensions || !r.extensions[this.name] || r.mesh === void 0)
      return null;
    const i = t.meshes[r.mesh];
    for (const u of i.primitives)
      if (
        u.mode !== Ti.TRIANGLES &&
        u.mode !== Ti.TRIANGLE_STRIP &&
        u.mode !== Ti.TRIANGLE_FAN &&
        u.mode !== void 0
      )
        return null;
    const o = r.extensions[this.name].attributes,
      a = [],
      l = {};
    for (const u in o)
      a.push(
        this.parser
          .getDependency("accessor", o[u])
          .then((h) => ((l[u] = h), l[u]))
      );
    return a.length < 1
      ? null
      : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then((u) => {
          const h = u.pop(),
            d = h.isGroup ? h.children : [h],
            p = u[0].count,
            m = [];
          for (const _ of d) {
            const y = new rt(),
              x = new U(),
              g = new mr(),
              S = new U(1, 1, 1),
              A = new v1(_.geometry, _.material, p);
            for (let E = 0; E < p; E++)
              l.TRANSLATION && x.fromBufferAttribute(l.TRANSLATION, E),
                l.ROTATION && g.fromBufferAttribute(l.ROTATION, E),
                l.SCALE && S.fromBufferAttribute(l.SCALE, E),
                A.setMatrixAt(E, y.compose(x, g, S));
            for (const E in l)
              E !== "TRANSLATION" &&
                E !== "ROTATION" &&
                E !== "SCALE" &&
                _.geometry.setAttribute(E, l[E]);
            bt.prototype.copy.call(A, _),
              this.parser.assignFinalMaterial(A),
              m.push(A);
          }
          return h.isGroup ? (h.clear(), h.add(...m), h) : m[0];
        }));
  }
}
const tI = "glTF",
  Ff = 12,
  ab = { JSON: 1313821514, BIN: 5130562 };
class F6 {
  constructor(e) {
    (this.name = wt.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, Ff);
    if (
      ((this.header = {
        magic: Is.decodeText(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== tI)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const r = this.header.length - Ff,
      i = new DataView(e, Ff);
    let s = 0;
    for (; s < r; ) {
      const o = i.getUint32(s, !0);
      s += 4;
      const a = i.getUint32(s, !0);
      if (((s += 4), a === ab.JSON)) {
        const l = new Uint8Array(e, Ff + s, o);
        this.content = Is.decodeText(l);
      } else if (a === ab.BIN) {
        const l = Ff + s;
        this.body = e.slice(l, l + o);
      }
      s += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class N6 {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = wt.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const r = this.json,
      i = this.dracoLoader,
      s = e.extensions[this.name].bufferView,
      o = e.extensions[this.name].attributes,
      a = {},
      l = {},
      u = {};
    for (const h in o) {
      const d = bS[h] || h.toLowerCase();
      a[d] = o[h];
    }
    for (const h in e.attributes) {
      const d = bS[h] || h.toLowerCase();
      if (o[h] !== void 0) {
        const p = r.accessors[e.attributes[h]],
          m = lc[p.componentType];
        (u[d] = m.name), (l[d] = p.normalized === !0);
      }
    }
    return t.getDependency("bufferView", s).then(function (h) {
      return new Promise(function (d) {
        i.decodeDracoFile(
          h,
          function (p) {
            for (const m in p.attributes) {
              const _ = p.attributes[m],
                y = l[m];
              y !== void 0 && (_.normalized = y);
            }
            d(p);
          },
          a,
          u
        );
      });
    });
  }
}
class O6 {
  constructor() {
    this.name = wt.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      ((t.texCoord === void 0 || t.texCoord === e.channel) &&
        t.offset === void 0 &&
        t.rotation === void 0 &&
        t.scale === void 0) ||
        ((e = e.clone()),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class U6 {
  constructor() {
    this.name = wt.KHR_MESH_QUANTIZATION;
  }
}
class nI extends Xc {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      r = this.sampleValues,
      i = this.valueSize,
      s = e * i * 3 + i;
    for (let o = 0; o !== i; o++) t[o] = r[s + o];
    return t;
  }
  interpolate_(e, t, r, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = a * 2,
      u = a * 3,
      h = i - t,
      d = (r - t) / h,
      p = d * d,
      m = p * d,
      _ = e * u,
      y = _ - u,
      x = -2 * m + 3 * p,
      g = m - p,
      S = 1 - x,
      A = g - p + d;
    for (let E = 0; E !== a; E++) {
      const C = o[y + E + a],
        R = o[y + E + l] * h,
        P = o[_ + E + a],
        L = o[_ + E] * h;
      s[E] = S * C + A * R + x * P + g * L;
    }
    return s;
  }
}
const k6 = new mr();
class z6 extends nI {
  interpolate_(e, t, r, i) {
    const s = super.interpolate_(e, t, r, i);
    return k6.fromArray(s).normalize().toArray(s), s;
  }
}
const Ti = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  lc = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  lb = { 9728: mn, 9729: sn, 9984: Lh, 9985: y0, 9986: sc, 9987: Ns },
  ub = { 33071: er, 33648: Sc, 10497: xa },
  My = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  bS = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    ...(sd.replace(/\D+/g, "") >= 152
      ? {
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv1",
          TEXCOORD_2: "uv2",
          TEXCOORD_3: "uv3",
        }
      : { TEXCOORD_0: "uv", TEXCOORD_1: "uv2" }),
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  Ho = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  H6 = { CUBICSPLINE: void 0, LINEAR: Il, STEP: Mc },
  Ey = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function G6(n) {
  return (
    n.DefaultMaterial === void 0 &&
      (n.DefaultMaterial = new da({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Fs,
      })),
    n.DefaultMaterial
  );
}
function qa(n, e, t) {
  for (const r in t.extensions)
    n[r] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[r] = t.extensions[r]));
}
function jo(n, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(n.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function V6(n, e, t) {
  let r = !1,
    i = !1,
    s = !1;
  for (let u = 0, h = e.length; u < h; u++) {
    const d = e[u];
    if (
      (d.POSITION !== void 0 && (r = !0),
      d.NORMAL !== void 0 && (i = !0),
      d.COLOR_0 !== void 0 && (s = !0),
      r && i && s)
    )
      break;
  }
  if (!r && !i && !s) return Promise.resolve(n);
  const o = [],
    a = [],
    l = [];
  for (let u = 0, h = e.length; u < h; u++) {
    const d = e[u];
    if (r) {
      const p =
        d.POSITION !== void 0
          ? t.getDependency("accessor", d.POSITION)
          : n.attributes.position;
      o.push(p);
    }
    if (i) {
      const p =
        d.NORMAL !== void 0
          ? t.getDependency("accessor", d.NORMAL)
          : n.attributes.normal;
      a.push(p);
    }
    if (s) {
      const p =
        d.COLOR_0 !== void 0
          ? t.getDependency("accessor", d.COLOR_0)
          : n.attributes.color;
      l.push(p);
    }
  }
  return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(
    function (u) {
      const h = u[0],
        d = u[1],
        p = u[2];
      return (
        r && (n.morphAttributes.position = h),
        i && (n.morphAttributes.normal = d),
        s && (n.morphAttributes.color = p),
        (n.morphTargetsRelative = !0),
        n
      );
    }
  );
}
function W6(n, e) {
  if ((n.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, r = e.weights.length; t < r; t++)
      n.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (n.morphTargetInfluences.length === t.length) {
      n.morphTargetDictionary = {};
      for (let r = 0, i = t.length; r < i; r++)
        n.morphTargetDictionary[t[r]] = r;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function j6(n) {
  let e;
  const t = n.extensions && n.extensions[wt.KHR_DRACO_MESH_COMPRESSION];
  if (
    (t
      ? (e = "draco:" + t.bufferView + ":" + t.indices + ":" + wy(t.attributes))
      : (e = n.indices + ":" + wy(n.attributes) + ":" + n.mode),
    n.targets !== void 0)
  )
    for (let r = 0, i = n.targets.length; r < i; r++)
      e += ":" + wy(n.targets[r]);
  return e;
}
function wy(n) {
  let e = "";
  const t = Object.keys(n).sort();
  for (let r = 0, i = t.length; r < i; r++) e += t[r] + ":" + n[t[r]] + ";";
  return e;
}
function RS(n) {
  switch (n) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function X6(n) {
  return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png";
}
const J6 = new rt();
class K6 {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new v6()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let r = !1,
      i = !1,
      s = -1;
    typeof navigator < "u" &&
      typeof navigator.userAgent < "u" &&
      ((r = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (i = navigator.userAgent.indexOf("Firefox") > -1),
      (s = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap > "u" || r || (i && s < 98)
        ? (this.textureLoader = new _L(this.options.manager))
        : (this.textureLoader = new EL(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new hi(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const r = this,
      i = this.json,
      s = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (o) {
        return o._markDefs && o._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (o) {
          return o.beforeRoot && o.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            r.getDependencies("scene"),
            r.getDependencies("animation"),
            r.getDependencies("camera"),
          ]);
        })
        .then(function (o) {
          const a = {
            scene: o[0][i.scene || 0],
            scenes: o[0],
            animations: o[1],
            cameras: o[2],
            asset: i.asset,
            parser: r,
            userData: {},
          };
          qa(s, a, i),
            jo(a, i),
            Promise.all(
              r._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(a);
              })
            ).then(function () {
              e(a);
            });
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      r = this.json.meshes || [];
    for (let i = 0, s = t.length; i < s; i++) {
      const o = t[i].joints;
      for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0;
    }
    for (let i = 0, s = e.length; i < s; i++) {
      const o = e[i];
      o.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, o.mesh),
        o.skin !== void 0 && (r[o.mesh].isSkinnedMesh = !0)),
        o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, r) {
    if (e.refs[t] <= 1) return r;
    const i = r.clone(),
      s = (o, a) => {
        const l = this.associations.get(o);
        l != null && this.associations.set(a, l);
        for (const [u, h] of o.children.entries()) s(h, a.children[u]);
      };
    return s(r, i), (i.name += "_instance_" + e.uses[t]++), i;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let r = 0; r < t.length; r++) {
      const i = e(t[r]);
      if (i) return i;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const r = [];
    for (let i = 0; i < t.length; i++) {
      const s = e(t[i]);
      s && r.push(s);
    }
    return r;
  }
  getDependency(e, t) {
    const r = e + ":" + t;
    let i = this.cache.get(r);
    if (!i) {
      switch (e) {
        case "scene":
          i = this.loadScene(t);
          break;
        case "node":
          i = this._invokeOne(function (s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case "mesh":
          i = this._invokeOne(function (s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          i = this.loadAccessor(t);
          break;
        case "bufferView":
          i = this._invokeOne(function (s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          i = this.loadBuffer(t);
          break;
        case "material":
          i = this._invokeOne(function (s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          i = this._invokeOne(function (s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          i = this.loadSkin(t);
          break;
        case "animation":
          i = this._invokeOne(function (s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          i = this.loadCamera(t);
          break;
        default:
          if (
            ((i = this._invokeOne(function (s) {
              return s != this && s.getDependency && s.getDependency(e, t);
            })),
            !i)
          )
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(r, i);
    }
    return i;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const r = this,
        i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (t = Promise.all(
        i.map(function (s, o) {
          return r.getDependency(e, o);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      r = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[wt.KHR_BINARY_GLTF].body);
    const i = this.options;
    return new Promise(function (s, o) {
      r.load(Is.resolveURL(t.uri, i.path), s, void 0, function () {
        o(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (r) {
      const i = t.byteLength || 0,
        s = t.byteOffset || 0;
      return r.slice(s, s + i);
    });
  }
  loadAccessor(e) {
    const t = this,
      r = this.json,
      i = this.json.accessors[e];
    if (i.bufferView === void 0 && i.sparse === void 0) {
      const o = My[i.type],
        a = lc[i.componentType],
        l = i.normalized === !0,
        u = new a(i.count * o);
      return Promise.resolve(new Dt(u, o, l));
    }
    const s = [];
    return (
      i.bufferView !== void 0
        ? s.push(this.getDependency("bufferView", i.bufferView))
        : s.push(null),
      i.sparse !== void 0 &&
        (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
      Promise.all(s).then(function (o) {
        const a = o[0],
          l = My[i.type],
          u = lc[i.componentType],
          h = u.BYTES_PER_ELEMENT,
          d = h * l,
          p = i.byteOffset || 0,
          m =
            i.bufferView !== void 0
              ? r.bufferViews[i.bufferView].byteStride
              : void 0,
          _ = i.normalized === !0;
        let y, x;
        if (m && m !== d) {
          const g = Math.floor(p / m),
            S =
              "InterleavedBuffer:" +
              i.bufferView +
              ":" +
              i.componentType +
              ":" +
              g +
              ":" +
              i.count;
          let A = t.cache.get(S);
          A ||
            ((y = new u(a, g * m, (i.count * m) / h)),
            (A = new fd(y, m / h)),
            t.cache.add(S, A)),
            (x = new Sa(A, l, (p % m) / h, _));
        } else a === null ? (y = new u(i.count * l)) : (y = new u(a, p, i.count * l)), (x = new Dt(y, l, _));
        if (i.sparse !== void 0) {
          const g = My.SCALAR,
            S = lc[i.sparse.indices.componentType],
            A = i.sparse.indices.byteOffset || 0,
            E = i.sparse.values.byteOffset || 0,
            C = new S(o[1], A, i.sparse.count * g),
            R = new u(o[2], E, i.sparse.count * l);
          a !== null && (x = new Dt(x.array.slice(), x.itemSize, x.normalized));
          for (let P = 0, L = C.length; P < L; P++) {
            const T = C[P];
            if (
              (x.setX(T, R[P * l]),
              l >= 2 && x.setY(T, R[P * l + 1]),
              l >= 3 && x.setZ(T, R[P * l + 2]),
              l >= 4 && x.setW(T, R[P * l + 3]),
              l >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return x;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      r = this.options,
      s = t.textures[e].source,
      o = t.images[s];
    let a = this.textureLoader;
    if (o.uri) {
      const l = r.manager.getHandler(o.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, s, a);
  }
  loadTextureImage(e, t, r) {
    const i = this,
      s = this.json,
      o = s.textures[e],
      a = s.images[t],
      l = (a.uri || a.bufferView) + ":" + o.sampler;
    if (this.textureCache[l]) return this.textureCache[l];
    const u = this.loadImageSource(t, r)
      .then(function (h) {
        (h.flipY = !1),
          (h.name = o.name || a.name || ""),
          h.name === "" &&
            typeof a.uri == "string" &&
            a.uri.startsWith("data:image/") === !1 &&
            (h.name = a.uri);
        const p = (s.samplers || {})[o.sampler] || {};
        return (
          (h.magFilter = lb[p.magFilter] || sn),
          (h.minFilter = lb[p.minFilter] || Ns),
          (h.wrapS = ub[p.wrapS] || xa),
          (h.wrapT = ub[p.wrapT] || xa),
          i.associations.set(h, { textures: e }),
          h
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[l] = u), u;
  }
  loadImageSource(e, t) {
    const r = this,
      i = this.json,
      s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((d) => d.clone());
    const o = i.images[e],
      a = self.URL || self.webkitURL;
    let l = o.uri || "",
      u = !1;
    if (o.bufferView !== void 0)
      l = r.getDependency("bufferView", o.bufferView).then(function (d) {
        u = !0;
        const p = new Blob([d], { type: o.mimeType });
        return (l = a.createObjectURL(p)), l;
      });
    else if (o.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const h = Promise.resolve(l)
      .then(function (d) {
        return new Promise(function (p, m) {
          let _ = p;
          t.isImageBitmapLoader === !0 &&
            (_ = function (y) {
              const x = new en(y);
              (x.needsUpdate = !0), p(x);
            }),
            t.load(Is.resolveURL(d, s.path), _, void 0, m);
        });
      })
      .then(function (d) {
        return (
          u === !0 && a.revokeObjectURL(l),
          (d.userData.mimeType = o.mimeType || X6(o.uri)),
          d
        );
      })
      .catch(function (d) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), d);
      });
    return (this.sourceCache[e] = h), h;
  }
  assignTexture(e, t, r, i) {
    const s = this;
    return this.getDependency("texture", r.index).then(function (o) {
      if (!o) return null;
      if (
        (r.texCoord !== void 0 &&
          r.texCoord > 0 &&
          ((o = o.clone()), (o.channel = r.texCoord)),
        s.extensions[wt.KHR_TEXTURE_TRANSFORM])
      ) {
        const a =
          r.extensions !== void 0
            ? r.extensions[wt.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (a) {
          const l = s.associations.get(o);
          (o = s.extensions[wt.KHR_TEXTURE_TRANSFORM].extendTexture(o, a)),
            s.associations.set(o, l);
        }
      }
      return (
        i !== void 0 &&
          ("colorSpace" in o
            ? (o.colorSpace = i === 3001 ? "srgb" : "srgb-linear")
            : (o.encoding = i)),
        (e[t] = o),
        o
      );
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let r = e.material;
    const i = t.attributes.tangent === void 0,
      s = t.attributes.color !== void 0,
      o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + r.uuid;
      let l = this.cache.get(a);
      l ||
        ((l = new b0()),
        In.prototype.copy.call(l, r),
        l.color.copy(r.color),
        (l.map = r.map),
        (l.sizeAttenuation = !1),
        this.cache.add(a, l)),
        (r = l);
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + r.uuid;
      let l = this.cache.get(a);
      l ||
        ((l = new yr()),
        In.prototype.copy.call(l, r),
        l.color.copy(r.color),
        (l.map = r.map),
        this.cache.add(a, l)),
        (r = l);
    }
    if (i || s || o) {
      let a = "ClonedMaterial:" + r.uuid + ":";
      i && (a += "derivative-tangents:"),
        s && (a += "vertex-colors:"),
        o && (a += "flat-shading:");
      let l = this.cache.get(a);
      l ||
        ((l = r.clone()),
        s && (l.vertexColors = !0),
        o && (l.flatShading = !0),
        i &&
          (l.normalScale && (l.normalScale.y *= -1),
          l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
        this.cache.add(a, l),
        this.associations.set(l, this.associations.get(r))),
        (r = l);
    }
    e.material = r;
  }
  getMaterialType() {
    return da;
  }
  loadMaterial(e) {
    const t = this,
      r = this.json,
      i = this.extensions,
      s = r.materials[e];
    let o;
    const a = {},
      l = s.extensions || {},
      u = [];
    if (l[wt.KHR_MATERIALS_UNLIT]) {
      const d = i[wt.KHR_MATERIALS_UNLIT];
      (o = d.getMaterialType()), u.push(d.extendParams(a, s, t));
    } else {
      const d = s.pbrMetallicRoughness || {};
      if (
        ((a.color = new Be(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(d.baseColorFactor))
      ) {
        const p = d.baseColorFactor;
        a.color.fromArray(p), (a.opacity = p[3]);
      }
      d.baseColorTexture !== void 0 &&
        u.push(t.assignTexture(a, "map", d.baseColorTexture, 3001)),
        (a.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1),
        (a.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1),
        d.metallicRoughnessTexture !== void 0 &&
          (u.push(
            t.assignTexture(a, "metalnessMap", d.metallicRoughnessTexture)
          ),
          u.push(
            t.assignTexture(a, "roughnessMap", d.metallicRoughnessTexture)
          )),
        (o = this._invokeOne(function (p) {
          return p.getMaterialType && p.getMaterialType(e);
        })),
        u.push(
          Promise.all(
            this._invokeAll(function (p) {
              return p.extendMaterialParams && p.extendMaterialParams(e, a);
            })
          )
        );
    }
    s.doubleSided === !0 && (a.side = Li);
    const h = s.alphaMode || Ey.OPAQUE;
    if (
      (h === Ey.BLEND
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          h === Ey.MASK &&
            (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)),
      s.normalTexture !== void 0 &&
        o !== kr &&
        (u.push(t.assignTexture(a, "normalMap", s.normalTexture)),
        (a.normalScale = new ge(1, 1)),
        s.normalTexture.scale !== void 0))
    ) {
      const d = s.normalTexture.scale;
      a.normalScale.set(d, d);
    }
    return (
      s.occlusionTexture !== void 0 &&
        o !== kr &&
        (u.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 &&
          (a.aoMapIntensity = s.occlusionTexture.strength)),
      s.emissiveFactor !== void 0 &&
        o !== kr &&
        (a.emissive = new Be().fromArray(s.emissiveFactor)),
      s.emissiveTexture !== void 0 &&
        o !== kr &&
        u.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, 3001)),
      Promise.all(u).then(function () {
        const d = new o(a);
        return (
          s.name && (d.name = s.name),
          jo(d, s),
          t.associations.set(d, { materials: e }),
          s.extensions && qa(i, d, s),
          d
        );
      })
    );
  }
  createUniqueName(e) {
    const t = Tt.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed
      ? t + "_" + ++this.nodeNamesUsed[t]
      : ((this.nodeNamesUsed[t] = 0), t);
  }
  loadGeometries(e) {
    const t = this,
      r = this.extensions,
      i = this.primitiveCache;
    function s(a) {
      return r[wt.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(a, t)
        .then(function (l) {
          return cb(l, a, t);
        });
    }
    const o = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a],
        h = j6(u),
        d = i[h];
      if (d) o.push(d.promise);
      else {
        let p;
        u.extensions && u.extensions[wt.KHR_DRACO_MESH_COMPRESSION]
          ? (p = s(u))
          : (p = cb(new dt(), u, t)),
          (i[h] = { primitive: u, promise: p }),
          o.push(p);
      }
    }
    return Promise.all(o);
  }
  loadMesh(e) {
    const t = this,
      r = this.json,
      i = this.extensions,
      s = r.meshes[e],
      o = s.primitives,
      a = [];
    for (let l = 0, u = o.length; l < u; l++) {
      const h =
        o[l].material === void 0
          ? G6(this.cache)
          : this.getDependency("material", o[l].material);
      a.push(h);
    }
    return (
      a.push(t.loadGeometries(o)),
      Promise.all(a).then(function (l) {
        const u = l.slice(0, l.length - 1),
          h = l[l.length - 1],
          d = [];
        for (let m = 0, _ = h.length; m < _; m++) {
          const y = h[m],
            x = o[m];
          let g;
          const S = u[m];
          if (
            x.mode === Ti.TRIANGLES ||
            x.mode === Ti.TRIANGLE_STRIP ||
            x.mode === Ti.TRIANGLE_FAN ||
            x.mode === void 0
          )
            (g = s.isSkinnedMesh === !0 ? new _1(y, S) : new kn(y, S)),
              g.isSkinnedMesh === !0 && g.normalizeSkinWeights(),
              x.mode === Ti.TRIANGLE_STRIP
                ? (g.geometry = ob(g.geometry, i1))
                : x.mode === Ti.TRIANGLE_FAN &&
                  (g.geometry = ob(g.geometry, Pg));
          else if (x.mode === Ti.LINES) g = new cs(y, S);
          else if (x.mode === Ti.LINE_STRIP) g = new vo(y, S);
          else if (x.mode === Ti.LINE_LOOP) g = new y1(y, S);
          else if (x.mode === Ti.POINTS) g = new x1(y, S);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + x.mode
            );
          Object.keys(g.geometry.morphAttributes).length > 0 && W6(g, s),
            (g.name = t.createUniqueName(s.name || "mesh_" + e)),
            jo(g, s),
            x.extensions && qa(i, g, x),
            t.assignFinalMaterial(g),
            d.push(g);
        }
        for (let m = 0, _ = d.length; m < _; m++)
          t.associations.set(d[m], { meshes: e, primitives: m });
        if (d.length === 1) return s.extensions && qa(i, d[0], s), d[0];
        const p = new uo();
        s.extensions && qa(i, p, s), t.associations.set(p, { meshes: e });
        for (let m = 0, _ = d.length; m < _; m++) p.add(d[m]);
        return p;
      })
    );
  }
  loadCamera(e) {
    let t;
    const r = this.json.cameras[e],
      i = r[r.type];
    if (!i) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      r.type === "perspective"
        ? (t = new Mn(
            R2.radToDeg(i.yfov),
            i.aspectRatio || 1,
            i.znear || 1,
            i.zfar || 2e6
          ))
        : r.type === "orthographic" &&
          (t = new Ra(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
      r.name && (t.name = this.createUniqueName(r.name)),
      jo(t, r),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      r = [];
    for (let i = 0, s = t.joints.length; i < s; i++)
      r.push(this._loadNodeShallow(t.joints[i]));
    return (
      t.inverseBindMatrices !== void 0
        ? r.push(this.getDependency("accessor", t.inverseBindMatrices))
        : r.push(null),
      Promise.all(r).then(function (i) {
        const s = i.pop(),
          o = i,
          a = [],
          l = [];
        for (let u = 0, h = o.length; u < h; u++) {
          const d = o[u];
          if (d) {
            a.push(d);
            const p = new rt();
            s !== null && p.fromArray(s.array, u * 16), l.push(p);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[u]
            );
        }
        return new hd(a, l);
      })
    );
  }
  loadAnimation(e) {
    const r = this.json.animations[e],
      i = r.name ? r.name : "animation_" + e,
      s = [],
      o = [],
      a = [],
      l = [],
      u = [];
    for (let h = 0, d = r.channels.length; h < d; h++) {
      const p = r.channels[h],
        m = r.samplers[p.sampler],
        _ = p.target,
        y = _.node,
        x = r.parameters !== void 0 ? r.parameters[m.input] : m.input,
        g = r.parameters !== void 0 ? r.parameters[m.output] : m.output;
      _.node !== void 0 &&
        (s.push(this.getDependency("node", y)),
        o.push(this.getDependency("accessor", x)),
        a.push(this.getDependency("accessor", g)),
        l.push(m),
        u.push(_));
    }
    return Promise.all([
      Promise.all(s),
      Promise.all(o),
      Promise.all(a),
      Promise.all(l),
      Promise.all(u),
    ]).then(function (h) {
      const d = h[0],
        p = h[1],
        m = h[2],
        _ = h[3],
        y = h[4],
        x = [];
      for (let g = 0, S = d.length; g < S; g++) {
        const A = d[g],
          E = p[g],
          C = m[g],
          R = _[g],
          P = y[g];
        if (A === void 0) continue;
        A.updateMatrix();
        let L;
        switch (Ho[P.path]) {
          case Ho.weights:
            L = Tc;
            break;
          case Ho.rotation:
            L = Aa;
            break;
          case Ho.position:
          case Ho.scale:
          default:
            L = bc;
            break;
        }
        const T = A.name ? A.name : A.uuid,
          B = R.interpolation !== void 0 ? H6[R.interpolation] : Il,
          D = [];
        Ho[P.path] === Ho.weights
          ? A.traverse(function (F) {
              F.morphTargetInfluences && D.push(F.name ? F.name : F.uuid);
            })
          : D.push(T);
        let I = C.array;
        if (C.normalized) {
          const F = RS(I.constructor),
            k = new Float32Array(I.length);
          for (let j = 0, Z = I.length; j < Z; j++) k[j] = I[j] * F;
          I = k;
        }
        for (let F = 0, k = D.length; F < k; F++) {
          const j = new L(D[F] + "." + Ho[P.path], E.array, I, B);
          R.interpolation === "CUBICSPLINE" &&
            ((j.createInterpolant = function (Q) {
              const N = this instanceof Aa ? z6 : nI;
              return new N(this.times, this.values, this.getValueSize() / 3, Q);
            }),
            (j.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0)),
            x.push(j);
        }
      }
      return new Rc(i, void 0, x);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      r = this,
      i = t.nodes[e];
    return i.mesh === void 0
      ? null
      : r.getDependency("mesh", i.mesh).then(function (s) {
          const o = r._getNodeRef(r.meshCache, i.mesh, s);
          return (
            i.weights !== void 0 &&
              o.traverse(function (a) {
                if (a.isMesh)
                  for (let l = 0, u = i.weights.length; l < u; l++)
                    a.morphTargetInfluences[l] = i.weights[l];
              }),
            o
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      r = this,
      i = t.nodes[e],
      s = r._loadNodeShallow(e),
      o = [],
      a = i.children || [];
    for (let u = 0, h = a.length; u < h; u++)
      o.push(r.getDependency("node", a[u]));
    const l =
      i.skin === void 0
        ? Promise.resolve(null)
        : r.getDependency("skin", i.skin);
    return Promise.all([s, Promise.all(o), l]).then(function (u) {
      const h = u[0],
        d = u[1],
        p = u[2];
      p !== null &&
        h.traverse(function (m) {
          m.isSkinnedMesh && m.bind(p, J6);
        });
      for (let m = 0, _ = d.length; m < _; m++) h.add(d[m]);
      return h;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json,
      r = this.extensions,
      i = this;
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
    const s = t.nodes[e],
      o = s.name ? i.createUniqueName(s.name) : "",
      a = [],
      l = i._invokeOne(function (u) {
        return u.createNodeMesh && u.createNodeMesh(e);
      });
    return (
      l && a.push(l),
      s.camera !== void 0 &&
        a.push(
          i.getDependency("camera", s.camera).then(function (u) {
            return i._getNodeRef(i.cameraCache, s.camera, u);
          })
        ),
      i
        ._invokeAll(function (u) {
          return u.createNodeAttachment && u.createNodeAttachment(e);
        })
        .forEach(function (u) {
          a.push(u);
        }),
      (this.nodeCache[e] = Promise.all(a).then(function (u) {
        let h;
        if (
          (s.isBone === !0
            ? (h = new T0())
            : u.length > 1
            ? (h = new uo())
            : u.length === 1
            ? (h = u[0])
            : (h = new bt()),
          h !== u[0])
        )
          for (let d = 0, p = u.length; d < p; d++) h.add(u[d]);
        if (
          (s.name && ((h.userData.name = s.name), (h.name = o)),
          jo(h, s),
          s.extensions && qa(r, h, s),
          s.matrix !== void 0)
        ) {
          const d = new rt();
          d.fromArray(s.matrix), h.applyMatrix4(d);
        } else s.translation !== void 0 && h.position.fromArray(s.translation), s.rotation !== void 0 && h.quaternion.fromArray(s.rotation), s.scale !== void 0 && h.scale.fromArray(s.scale);
        return (
          i.associations.has(h) || i.associations.set(h, {}),
          (i.associations.get(h).nodes = e),
          h
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const t = this.extensions,
      r = this.json.scenes[e],
      i = this,
      s = new uo();
    r.name && (s.name = i.createUniqueName(r.name)),
      jo(s, r),
      r.extensions && qa(t, s, r);
    const o = r.nodes || [],
      a = [];
    for (let l = 0, u = o.length; l < u; l++)
      a.push(i.getDependency("node", o[l]));
    return Promise.all(a).then(function (l) {
      for (let h = 0, d = l.length; h < d; h++) s.add(l[h]);
      const u = (h) => {
        const d = new Map();
        for (const [p, m] of i.associations)
          (p instanceof In || p instanceof en) && d.set(p, m);
        return (
          h.traverse((p) => {
            const m = i.associations.get(p);
            m != null && d.set(p, m);
          }),
          d
        );
      };
      return (i.associations = u(s)), s;
    });
  }
}
function Y6(n, e, t) {
  const r = e.attributes,
    i = new us();
  if (r.POSITION !== void 0) {
    const a = t.json.accessors[r.POSITION],
      l = a.min,
      u = a.max;
    if (l !== void 0 && u !== void 0) {
      if (
        (i.set(new U(l[0], l[1], l[2]), new U(u[0], u[1], u[2])), a.normalized)
      ) {
        const h = RS(lc[a.componentType]);
        i.min.multiplyScalar(h), i.max.multiplyScalar(h);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const s = e.targets;
  if (s !== void 0) {
    const a = new U(),
      l = new U();
    for (let u = 0, h = s.length; u < h; u++) {
      const d = s[u];
      if (d.POSITION !== void 0) {
        const p = t.json.accessors[d.POSITION],
          m = p.min,
          _ = p.max;
        if (m !== void 0 && _ !== void 0) {
          if (
            (l.setX(Math.max(Math.abs(m[0]), Math.abs(_[0]))),
            l.setY(Math.max(Math.abs(m[1]), Math.abs(_[1]))),
            l.setZ(Math.max(Math.abs(m[2]), Math.abs(_[2]))),
            p.normalized)
          ) {
            const y = RS(lc[p.componentType]);
            l.multiplyScalar(y);
          }
          a.max(l);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    i.expandByVector(a);
  }
  n.boundingBox = i;
  const o = new Gi();
  i.getCenter(o.center),
    (o.radius = i.min.distanceTo(i.max) / 2),
    (n.boundingSphere = o);
}
function cb(n, e, t) {
  const r = e.attributes,
    i = [];
  function s(o, a) {
    return t.getDependency("accessor", o).then(function (l) {
      n.setAttribute(a, l);
    });
  }
  for (const o in r) {
    const a = bS[o] || o.toLowerCase();
    a in n.attributes || i.push(s(r[o], a));
  }
  if (e.indices !== void 0 && !n.index) {
    const o = t.getDependency("accessor", e.indices).then(function (a) {
      n.setIndex(a);
    });
    i.push(o);
  }
  return (
    jo(n, e),
    Y6(n, e, t),
    Promise.all(i).then(function () {
      return e.targets !== void 0 ? V6(n, e.targets, t) : n;
    })
  );
}
const Cy = new WeakMap();
class Q6 extends xr {
  constructor(e) {
    super(e),
      (this.decoderPath = ""),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ""),
      (this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD",
      }),
      (this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array",
      });
  }
  setDecoderPath(e) {
    return (this.decoderPath = e), this;
  }
  setDecoderConfig(e) {
    return (this.decoderConfig = e), this;
  }
  setWorkerLimit(e) {
    return (this.workerLimit = e), this;
  }
  load(e, t, r, i) {
    const s = new hi(this.manager);
    s.setPath(this.path),
      s.setResponseType("arraybuffer"),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        (o) => {
          const a = {
            attributeIDs: this.defaultAttributeIDs,
            attributeTypes: this.defaultAttributeTypes,
            useUniqueIDs: !1,
          };
          this.decodeGeometry(o, a).then(t).catch(i);
        },
        r,
        i
      );
  }
  decodeDracoFile(e, t, r, i) {
    const s = {
      attributeIDs: r || this.defaultAttributeIDs,
      attributeTypes: i || this.defaultAttributeTypes,
      useUniqueIDs: !!r,
    };
    this.decodeGeometry(e, s).then(t);
  }
  decodeGeometry(e, t) {
    for (const l in t.attributeTypes) {
      const u = t.attributeTypes[l];
      u.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = u.name);
    }
    const r = JSON.stringify(t);
    if (Cy.has(e)) {
      const l = Cy.get(e);
      if (l.key === r) return l.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let i;
    const s = this.workerNextTaskID++,
      o = e.byteLength,
      a = this._getWorker(s, o)
        .then(
          (l) => (
            (i = l),
            new Promise((u, h) => {
              (i._callbacks[s] = { resolve: u, reject: h }),
                i.postMessage(
                  { type: "decode", id: s, taskConfig: t, buffer: e },
                  [e]
                );
            })
          )
        )
        .then((l) => this._createGeometry(l.geometry));
    return (
      a
        .catch(() => !0)
        .then(() => {
          i && s && this._releaseTask(i, s);
        }),
      Cy.set(e, { key: r, promise: a }),
      a
    );
  }
  _createGeometry(e) {
    const t = new dt();
    e.index && t.setIndex(new Dt(e.index.array, 1));
    for (let r = 0; r < e.attributes.length; r++) {
      const i = e.attributes[r],
        s = i.name,
        o = i.array,
        a = i.itemSize;
      t.setAttribute(s, new Dt(o, a));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const r = new hi(this.manager);
    return (
      r.setPath(this.decoderPath),
      r.setResponseType(t),
      r.setWithCredentials(this.withCredentials),
      new Promise((i, s) => {
        r.load(e, i, void 0, s);
      })
    );
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e =
        typeof WebAssembly != "object" || this.decoderConfig.type === "js",
      t = [];
    return (
      e
        ? t.push(this._loadLibrary("draco_decoder.js", "text"))
        : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(t).then((r) => {
        const i = r[0];
        e || (this.decoderConfig.wasmBinary = r[1]);
        const s = q6.toString(),
          o = [
            "/* draco decoder */",
            i,
            "",
            "/* worker */",
            s.substring(s.indexOf("{") + 1, s.lastIndexOf("}")),
          ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([o]));
      })),
      this.decoderPending
    );
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const i = new Worker(this.workerSourceURL);
        (i._callbacks = {}),
          (i._taskCosts = {}),
          (i._taskLoad = 0),
          i.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (i.onmessage = function (s) {
            const o = s.data;
            switch (o.type) {
              case "decode":
                i._callbacks[o.id].resolve(o);
                break;
              case "error":
                i._callbacks[o.id].reject(o);
                break;
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + o.type + '"'
                );
            }
          }),
          this.workerPool.push(i);
      } else
        this.workerPool.sort(function (i, s) {
          return i._taskLoad > s._taskLoad ? -1 : 1;
        });
      const r = this.workerPool[this.workerPool.length - 1];
      return (r._taskCosts[e] = t), (r._taskLoad += t), r;
    });
  }
  _releaseTask(e, t) {
    (e._taskLoad -= e._taskCosts[t]),
      delete e._callbacks[t],
      delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return (this.workerPool.length = 0), this;
  }
}
function q6() {
  let n, e;
  onmessage = function (o) {
    const a = o.data;
    switch (a.type) {
      case "init":
        (n = a.decoderConfig),
          (e = new Promise(function (h) {
            (n.onModuleLoaded = function (d) {
              h({ draco: d });
            }),
              DracoDecoderModule(n);
          }));
        break;
      case "decode":
        const l = a.buffer,
          u = a.taskConfig;
        e.then((h) => {
          const d = h.draco,
            p = new d.Decoder(),
            m = new d.DecoderBuffer();
          m.Init(new Int8Array(l), l.byteLength);
          try {
            const _ = t(d, p, m, u),
              y = _.attributes.map((x) => x.array.buffer);
            _.index && y.push(_.index.array.buffer),
              self.postMessage({ type: "decode", id: a.id, geometry: _ }, y);
          } catch (_) {
            console.error(_),
              self.postMessage({ type: "error", id: a.id, error: _.message });
          } finally {
            d.destroy(m), d.destroy(p);
          }
        });
        break;
    }
  };
  function t(o, a, l, u) {
    const h = u.attributeIDs,
      d = u.attributeTypes;
    let p, m;
    const _ = a.GetEncodedGeometryType(l);
    if (_ === o.TRIANGULAR_MESH)
      (p = new o.Mesh()), (m = a.DecodeBufferToMesh(l, p));
    else if (_ === o.POINT_CLOUD)
      (p = new o.PointCloud()), (m = a.DecodeBufferToPointCloud(l, p));
    else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!m.ok() || p.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg());
    const y = { index: null, attributes: [] };
    for (const x in h) {
      const g = self[d[x]];
      let S, A;
      if (u.useUniqueIDs) (A = h[x]), (S = a.GetAttributeByUniqueId(p, A));
      else {
        if (((A = a.GetAttributeId(p, o[h[x]])), A === -1)) continue;
        S = a.GetAttribute(p, A);
      }
      y.attributes.push(i(o, a, p, x, g, S));
    }
    return _ === o.TRIANGULAR_MESH && (y.index = r(o, a, p)), o.destroy(p), y;
  }
  function r(o, a, l) {
    const h = l.num_faces() * 3,
      d = h * 4,
      p = o._malloc(d);
    a.GetTrianglesUInt32Array(l, d, p);
    const m = new Uint32Array(o.HEAPF32.buffer, p, h).slice();
    return o._free(p), { array: m, itemSize: 1 };
  }
  function i(o, a, l, u, h, d) {
    const p = d.num_components(),
      _ = l.num_points() * p,
      y = _ * h.BYTES_PER_ELEMENT,
      x = s(o, h),
      g = o._malloc(y);
    a.GetAttributeDataArrayForAllPoints(l, d, x, y, g);
    const S = new h(o.HEAPF32.buffer, g, _).slice();
    return o._free(g), { name: u, array: S, itemSize: p };
  }
  function s(o, a) {
    switch (a) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
let Em;
const Ty = () => {
  if (Em) return Em;
  const n =
      "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",
    e =
      "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",
    t = new Uint8Array([
      0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0,
      1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7,
      0, 65, 0, 253, 15, 26, 11,
    ]),
    r = new Uint8Array([
      32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16,
      128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136,
      107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131,
      44, 45, 74, 156, 154, 70, 167,
    ]);
  if (typeof WebAssembly != "object") return { supported: !1 };
  let i = n;
  WebAssembly.validate(t) && (i = e);
  let s;
  const o = WebAssembly.instantiate(a(i), {}).then((d) => {
    (s = d.instance), s.exports.__wasm_call_ctors();
  });
  function a(d) {
    const p = new Uint8Array(d.length);
    for (let _ = 0; _ < d.length; ++_) {
      const y = d.charCodeAt(_);
      p[_] =
        y > 96 ? y - 71 : y > 64 ? y - 65 : y > 47 ? y + 4 : y > 46 ? 63 : 62;
    }
    let m = 0;
    for (let _ = 0; _ < d.length; ++_)
      p[m++] = p[_] < 60 ? r[p[_]] : (p[_] - 60) * 64 + p[++_];
    return p.buffer.slice(0, m);
  }
  function l(d, p, m, _, y, x) {
    const g = s.exports.sbrk,
      S = (m + 3) & -4,
      A = g(S * _),
      E = g(y.length),
      C = new Uint8Array(s.exports.memory.buffer);
    C.set(y, E);
    const R = d(A, m, _, E, y.length);
    if (
      (R === 0 && x && x(A, S, _),
      p.set(C.subarray(A, A + m * _)),
      g(A - g(0)),
      R !== 0)
    )
      throw new Error(`Malformed buffer data: ${R}`);
  }
  const u = {
      0: "",
      1: "meshopt_decodeFilterOct",
      2: "meshopt_decodeFilterQuat",
      3: "meshopt_decodeFilterExp",
      NONE: "",
      OCTAHEDRAL: "meshopt_decodeFilterOct",
      QUATERNION: "meshopt_decodeFilterQuat",
      EXPONENTIAL: "meshopt_decodeFilterExp",
    },
    h = {
      0: "meshopt_decodeVertexBuffer",
      1: "meshopt_decodeIndexBuffer",
      2: "meshopt_decodeIndexSequence",
      ATTRIBUTES: "meshopt_decodeVertexBuffer",
      TRIANGLES: "meshopt_decodeIndexBuffer",
      INDICES: "meshopt_decodeIndexSequence",
    };
  return (
    (Em = {
      ready: o,
      supported: !0,
      decodeVertexBuffer(d, p, m, _, y) {
        l(s.exports.meshopt_decodeVertexBuffer, d, p, m, _, s.exports[u[y]]);
      },
      decodeIndexBuffer(d, p, m, _) {
        l(s.exports.meshopt_decodeIndexBuffer, d, p, m, _);
      },
      decodeIndexSequence(d, p, m, _) {
        l(s.exports.meshopt_decodeIndexSequence, d, p, m, _);
      },
      decodeGltfBuffer(d, p, m, _, y, x) {
        l(s.exports[h[y]], d, p, m, _, s.exports[u[x]]);
      },
    }),
    Em
  );
};
let wm = null;
function rI(n, e, t) {
  return (r) => {
    t && t(r),
      n &&
        (wm || (wm = new Q6()),
        wm.setDecoderPath(
          typeof n == "string"
            ? n
            : "https://www.gstatic.com/draco/versioned/decoders/1.5.5/"
        ),
        r.setDRACOLoader(wm)),
      e && r.setMeshoptDecoder(typeof Ty == "function" ? Ty() : Ty);
  };
}
function j0(n, e = !0, t = !0, r) {
  return vd(j1, n, rI(e, t, r));
}
j0.preload = (n, e = !0, t = !0, r) => vd.preload(j1, n, rI(e, t, r));
j0.clear = (n) => vd.clear(j1, n);
var iI = { exports: {} },
  Z6 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  $6 = Z6,
  eW = $6;
function sI() {}
function oI() {}
oI.resetWarningCache = sI;
var tW = function () {
  function n(r, i, s, o, a, l) {
    if (l !== eW) {
      var u = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw ((u.name = "Invariant Violation"), u);
    }
  }
  n.isRequired = n;
  function e() {
    return n;
  }
  var t = {
    array: n,
    bigint: n,
    bool: n,
    func: n,
    number: n,
    object: n,
    string: n,
    symbol: n,
    any: n,
    arrayOf: e,
    element: n,
    elementType: n,
    instanceOf: e,
    node: n,
    objectOf: e,
    oneOf: e,
    oneOfType: e,
    shape: e,
    exact: e,
    checkPropTypes: oI,
    resetWarningCache: sI,
  };
  return (t.PropTypes = t), t;
};
iI.exports = tW();
var nW = iI.exports;
const Nn = Nc(nW);
function no(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return n;
}
function aI(n, e) {
  (n.prototype = Object.create(e.prototype)),
    (n.prototype.constructor = n),
    (n.__proto__ = e);
}
/*!
 * GSAP 3.12.2
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var ci = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: { lineHeight: "" },
  },
  Bc = { duration: 0.5, overwrite: !1, delay: 0 },
  X1,
  gr,
  _n,
  Di = 1e8,
  Gt = 1 / Di,
  PS = Math.PI * 2,
  rW = PS / 4,
  iW = 0,
  lI = Math.sqrt,
  sW = Math.cos,
  oW = Math.sin,
  Yn = function (e) {
    return typeof e == "string";
  },
  vn = function (e) {
    return typeof e == "function";
  },
  yo = function (e) {
    return typeof e == "number";
  },
  J1 = function (e) {
    return typeof e > "u";
  },
  Us = function (e) {
    return typeof e == "object";
  },
  Vr = function (e) {
    return e !== !1;
  },
  K1 = function () {
    return typeof window < "u";
  },
  Cm = function (e) {
    return vn(e) || Yn(e);
  },
  uI =
    (typeof ArrayBuffer == "function" && ArrayBuffer.isView) || function () {},
  _r = Array.isArray,
  BS = /(?:-?\.?\d|\.)+/gi,
  cI = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
  qu = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
  by = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
  fI = /[+-]=-?[.\d]+/,
  hI = /[^,'"\[\]\s]+/gi,
  aW = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
  rn,
  bi,
  LS,
  Y1,
  di = {},
  Fg = {},
  dI,
  pI = function (e) {
    return (Fg = Nl(e, di)) && Xr;
  },
  Q1 = function (e, t) {
    return console.warn(
      "Invalid property",
      e,
      "set to",
      t,
      "Missing plugin? gsap.registerPlugin()"
    );
  },
  Ng = function (e, t) {
    return !t && console.warn(e);
  },
  mI = function (e, t) {
    return (e && (di[e] = t) && Fg && (Fg[e] = t)) || di;
  },
  Vh = function () {
    return 0;
  },
  lW = { suppressEvents: !0, isStart: !0, kill: !1 },
  qm = { suppressEvents: !0, kill: !1 },
  uW = { suppressEvents: !0 },
  q1 = {},
  pa = [],
  IS = {},
  gI,
  ii = {},
  Ry = {},
  fb = 30,
  Zm = [],
  Z1 = "",
  $1 = function (e) {
    var t = e[0],
      r,
      i;
    if ((Us(t) || vn(t) || (e = [e]), !(r = (t._gsap || {}).harness))) {
      for (i = Zm.length; i-- && !Zm[i].targetTest(t); );
      r = Zm[i];
    }
    for (i = e.length; i--; )
      (e[i] && (e[i]._gsap || (e[i]._gsap = new zI(e[i], r)))) ||
        e.splice(i, 1);
    return e;
  },
  Ml = function (e) {
    return e._gsap || $1(Fi(e))[0]._gsap;
  },
  _I = function (e, t, r) {
    return (r = e[t]) && vn(r)
      ? e[t]()
      : (J1(r) && e.getAttribute && e.getAttribute(t)) || r;
  },
  Wr = function (e, t) {
    return (e = e.split(",")).forEach(t) || e;
  },
  Sn = function (e) {
    return Math.round(e * 1e5) / 1e5 || 0;
  },
  $n = function (e) {
    return Math.round(e * 1e7) / 1e7 || 0;
  },
  uc = function (e, t) {
    var r = t.charAt(0),
      i = parseFloat(t.substr(2));
    return (
      (e = parseFloat(e)),
      r === "+" ? e + i : r === "-" ? e - i : r === "*" ? e * i : e / i
    );
  },
  cW = function (e, t) {
    for (var r = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < r; );
    return i < r;
  },
  Og = function () {
    var e = pa.length,
      t = pa.slice(0),
      r,
      i;
    for (IS = {}, pa.length = 0, r = 0; r < e; r++)
      (i = t[r]),
        i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0);
  },
  vI = function (e, t, r, i) {
    pa.length && !gr && Og(),
      e.render(t, r, i || (gr && t < 0 && (e._initted || e._startAt))),
      pa.length && !gr && Og();
  },
  yI = function (e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(hI).length < 2
      ? t
      : Yn(e)
      ? e.trim()
      : e;
  },
  xI = function (e) {
    return e;
  },
  Hi = function (e, t) {
    for (var r in t) r in e || (e[r] = t[r]);
    return e;
  },
  fW = function (e) {
    return function (t, r) {
      for (var i in r)
        i in t || (i === "duration" && e) || i === "ease" || (t[i] = r[i]);
    };
  },
  Nl = function (e, t) {
    for (var r in t) e[r] = t[r];
    return e;
  },
  hb = function n(e, t) {
    for (var r in t)
      r !== "__proto__" &&
        r !== "constructor" &&
        r !== "prototype" &&
        (e[r] = Us(t[r]) ? n(e[r] || (e[r] = {}), t[r]) : t[r]);
    return e;
  },
  Ug = function (e, t) {
    var r = {},
      i;
    for (i in e) i in t || (r[i] = e[i]);
    return r;
  },
  ah = function (e) {
    var t = e.parent || rn,
      r = e.keyframes ? fW(_r(e.keyframes)) : Hi;
    if (Vr(e.inherit))
      for (; t; ) r(e, t.vars.defaults), (t = t.parent || t._dp);
    return e;
  },
  hW = function (e, t) {
    for (var r = e.length, i = r === t.length; i && r-- && e[r] === t[r]; );
    return r < 0;
  },
  SI = function (e, t, r, i, s) {
    r === void 0 && (r = "_first"), i === void 0 && (i = "_last");
    var o = e[i],
      a;
    if (s) for (a = t[s]; o && o[s] > a; ) o = o._prev;
    return (
      o ? ((t._next = o._next), (o._next = t)) : ((t._next = e[r]), (e[r] = t)),
      t._next ? (t._next._prev = t) : (e[i] = t),
      (t._prev = o),
      (t.parent = t._dp = e),
      t
    );
  },
  X0 = function (e, t, r, i) {
    r === void 0 && (r = "_first"), i === void 0 && (i = "_last");
    var s = t._prev,
      o = t._next;
    s ? (s._next = o) : e[r] === t && (e[r] = o),
      o ? (o._prev = s) : e[i] === t && (e[i] = s),
      (t._next = t._prev = t.parent = null);
  },
  Ma = function (e, t) {
    e.parent &&
      (!t || e.parent.autoRemoveChildren) &&
      e.parent.remove &&
      e.parent.remove(e),
      (e._act = 0);
  },
  El = function (e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
      for (var r = e; r; ) (r._dirty = 1), (r = r.parent);
    return e;
  },
  dW = function (e) {
    for (var t = e.parent; t && t.parent; )
      (t._dirty = 1), t.totalDuration(), (t = t.parent);
    return e;
  },
  DS = function (e, t, r, i) {
    return (
      e._startAt &&
      (gr
        ? e._startAt.revert(qm)
        : (e.vars.immediateRender && !e.vars.autoRevert) ||
          e._startAt.render(t, !0, i))
    );
  },
  pW = function n(e) {
    return !e || (e._ts && n(e.parent));
  },
  db = function (e) {
    return e._repeat ? Lc(e._tTime, (e = e.duration() + e._rDelay)) * e : 0;
  },
  Lc = function (e, t) {
    var r = Math.floor((e /= t));
    return e && r === e ? r - 1 : r;
  },
  kg = function (e, t) {
    return (
      (e - t._start) * t._ts +
      (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
    );
  },
  J0 = function (e) {
    return (e._end = $n(
      e._start + (e._tDur / Math.abs(e._ts || e._rts || Gt) || 0)
    ));
  },
  K0 = function (e, t) {
    var r = e._dp;
    return (
      r &&
        r.smoothChildTiming &&
        e._ts &&
        ((e._start = $n(
          r._time -
            (e._ts > 0
              ? t / e._ts
              : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)
        )),
        J0(e),
        r._dirty || El(r, e)),
      e
    );
  },
  AI = function (e, t) {
    var r;
    if (
      ((t._time ||
        (!t._dur && t._initted) ||
        (t._start < e._time && (t._dur || !t.add))) &&
        ((r = kg(e.rawTime(), t)),
        (!t._dur || xd(0, t.totalDuration(), r) - t._tTime > Gt) &&
          t.render(r, !0)),
      El(e, t)._dp && e._initted && e._time >= e._dur && e._ts)
    ) {
      if (e._dur < e.duration())
        for (r = e; r._dp; )
          r.rawTime() >= 0 && r.totalTime(r._tTime), (r = r._dp);
      e._zTime = -Gt;
    }
  },
  Es = function (e, t, r, i) {
    return (
      t.parent && Ma(t),
      (t._start = $n(
        (yo(r) ? r : r || e !== rn ? Ci(e, r, t) : e._time) + t._delay
      )),
      (t._end = $n(
        t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)
      )),
      SI(e, t, "_first", "_last", e._sort ? "_start" : 0),
      FS(t) || (e._recent = t),
      i || AI(e, t),
      e._ts < 0 && K0(e, e._tTime),
      e
    );
  },
  MI = function (e, t) {
    return (
      (di.ScrollTrigger || Q1("scrollTrigger", t)) &&
      di.ScrollTrigger.create(t, e)
    );
  },
  EI = function (e, t, r, i, s) {
    if ((tM(e, t, s), !e._initted)) return 1;
    if (
      !r &&
      e._pt &&
      !gr &&
      ((e._dur && e.vars.lazy !== !1) || (!e._dur && e.vars.lazy)) &&
      gI !== si.frame
    )
      return pa.push(e), (e._lazy = [s, i]), 1;
  },
  mW = function n(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n(t));
  },
  FS = function (e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart";
  },
  gW = function (e, t, r, i) {
    var s = e.ratio,
      o =
        t < 0 ||
        (!t &&
          ((!e._start && mW(e) && !(!e._initted && FS(e))) ||
            ((e._ts < 0 || e._dp._ts < 0) && !FS(e))))
          ? 0
          : 1,
      a = e._rDelay,
      l = 0,
      u,
      h,
      d;
    if (
      (a &&
        e._repeat &&
        ((l = xd(0, e._tDur, t)),
        (h = Lc(l, a)),
        e._yoyo && h & 1 && (o = 1 - o),
        h !== Lc(e._tTime, a) &&
          ((s = 1 - o), e.vars.repeatRefresh && e._initted && e.invalidate())),
      o !== s || gr || i || e._zTime === Gt || (!t && e._zTime))
    ) {
      if (!e._initted && EI(e, t, i, r, l)) return;
      for (
        d = e._zTime,
          e._zTime = t || (r ? Gt : 0),
          r || (r = t && !d),
          e.ratio = o,
          e._from && (o = 1 - o),
          e._time = 0,
          e._tTime = l,
          u = e._pt;
        u;

      )
        u.r(o, u.d), (u = u._next);
      t < 0 && DS(e, t, r, !0),
        e._onUpdate && !r && Ni(e, "onUpdate"),
        l && e._repeat && !r && e.parent && Ni(e, "onRepeat"),
        (t >= e._tDur || t < 0) &&
          e.ratio === o &&
          (o && Ma(e, 1),
          !r &&
            !gr &&
            (Ni(e, o ? "onComplete" : "onReverseComplete", !0),
            e._prom && e._prom()));
    } else e._zTime || (e._zTime = t);
  },
  _W = function (e, t, r) {
    var i;
    if (r > t)
      for (i = e._first; i && i._start <= r; ) {
        if (i.data === "isPause" && i._start > t) return i;
        i = i._next;
      }
    else
      for (i = e._last; i && i._start >= r; ) {
        if (i.data === "isPause" && i._start < t) return i;
        i = i._prev;
      }
  },
  Ic = function (e, t, r, i) {
    var s = e._repeat,
      o = $n(t) || 0,
      a = e._tTime / e._tDur;
    return (
      a && !i && (e._time *= o / e._dur),
      (e._dur = o),
      (e._tDur = s ? (s < 0 ? 1e10 : $n(o * (s + 1) + e._rDelay * s)) : o),
      a > 0 && !i && K0(e, (e._tTime = e._tDur * a)),
      e.parent && J0(e),
      r || El(e.parent, e),
      e
    );
  },
  pb = function (e) {
    return e instanceof Or ? El(e) : Ic(e, e._dur);
  },
  vW = { _start: 0, endTime: Vh, totalDuration: Vh },
  Ci = function n(e, t, r) {
    var i = e.labels,
      s = e._recent || vW,
      o = e.duration() >= Di ? s.endTime(!1) : e._dur,
      a,
      l,
      u;
    return Yn(t) && (isNaN(t) || t in i)
      ? ((l = t.charAt(0)),
        (u = t.substr(-1) === "%"),
        (a = t.indexOf("=")),
        l === "<" || l === ">"
          ? (a >= 0 && (t = t.replace(/=/, "")),
            (l === "<" ? s._start : s.endTime(s._repeat >= 0)) +
              (parseFloat(t.substr(1)) || 0) *
                (u ? (a < 0 ? s : r).totalDuration() / 100 : 1))
          : a < 0
          ? (t in i || (i[t] = o), i[t])
          : ((l = parseFloat(t.charAt(a - 1) + t.substr(a + 1))),
            u && r && (l = (l / 100) * (_r(r) ? r[0] : r).totalDuration()),
            a > 1 ? n(e, t.substr(0, a - 1), r) + l : o + l))
      : t == null
      ? o
      : +t;
  },
  lh = function (e, t, r) {
    var i = yo(t[1]),
      s = (i ? 2 : 1) + (e < 2 ? 0 : 1),
      o = t[s],
      a,
      l;
    if ((i && (o.duration = t[1]), (o.parent = r), e)) {
      for (a = o, l = r; l && !("immediateRender" in a); )
        (a = l.vars.defaults || {}), (l = Vr(l.vars.inherit) && l.parent);
      (o.immediateRender = Vr(a.immediateRender)),
        e < 2 ? (o.runBackwards = 1) : (o.startAt = t[s - 1]);
    }
    return new Pn(t[0], o, t[s + 1]);
  },
  La = function (e, t) {
    return e || e === 0 ? t(e) : t;
  },
  xd = function (e, t, r) {
    return r < e ? e : r > t ? t : r;
  },
  pr = function (e, t) {
    return !Yn(e) || !(t = aW.exec(e)) ? "" : t[1];
  },
  yW = function (e, t, r) {
    return La(r, function (i) {
      return xd(e, t, i);
    });
  },
  NS = [].slice,
  wI = function (e, t) {
    return (
      e &&
      Us(e) &&
      "length" in e &&
      ((!t && !e.length) || (e.length - 1 in e && Us(e[0]))) &&
      !e.nodeType &&
      e !== bi
    );
  },
  xW = function (e, t, r) {
    return (
      r === void 0 && (r = []),
      e.forEach(function (i) {
        var s;
        return (Yn(i) && !t) || wI(i, 1)
          ? (s = r).push.apply(s, Fi(i))
          : r.push(i);
      }) || r
    );
  },
  Fi = function (e, t, r) {
    return _n && !t && _n.selector
      ? _n.selector(e)
      : Yn(e) && !r && (LS || !Dc())
      ? NS.call((t || Y1).querySelectorAll(e), 0)
      : _r(e)
      ? xW(e, r)
      : wI(e)
      ? NS.call(e, 0)
      : e
      ? [e]
      : [];
  },
  OS = function (e) {
    return (
      (e = Fi(e)[0] || Ng("Invalid scope") || {}),
      function (t) {
        var r = e.current || e.nativeElement || e;
        return Fi(
          t,
          r.querySelectorAll
            ? r
            : r === e
            ? Ng("Invalid scope") || Y1.createElement("div")
            : e
        );
      }
    );
  },
  CI = function (e) {
    return e.sort(function () {
      return 0.5 - Math.random();
    });
  },
  TI = function (e) {
    if (vn(e)) return e;
    var t = Us(e) ? e : { each: e },
      r = wl(t.ease),
      i = t.from || 0,
      s = parseFloat(t.base) || 0,
      o = {},
      a = i > 0 && i < 1,
      l = isNaN(i) || a,
      u = t.axis,
      h = i,
      d = i;
    return (
      Yn(i)
        ? (h = d = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
        : !a && l && ((h = i[0]), (d = i[1])),
      function (p, m, _) {
        var y = (_ || t).length,
          x = o[y],
          g,
          S,
          A,
          E,
          C,
          R,
          P,
          L,
          T;
        if (!x) {
          if (((T = t.grid === "auto" ? 0 : (t.grid || [1, Di])[1]), !T)) {
            for (
              P = -Di;
              P < (P = _[T++].getBoundingClientRect().left) && T < y;

            );
            T--;
          }
          for (
            x = o[y] = [],
              g = l ? Math.min(T, y) * h - 0.5 : i % T,
              S = T === Di ? 0 : l ? (y * d) / T - 0.5 : (i / T) | 0,
              P = 0,
              L = Di,
              R = 0;
            R < y;
            R++
          )
            (A = (R % T) - g),
              (E = S - ((R / T) | 0)),
              (x[R] = C = u ? Math.abs(u === "y" ? E : A) : lI(A * A + E * E)),
              C > P && (P = C),
              C < L && (L = C);
          i === "random" && CI(x),
            (x.max = P - L),
            (x.min = L),
            (x.v = y =
              (parseFloat(t.amount) ||
                parseFloat(t.each) *
                  (T > y
                    ? y - 1
                    : u
                    ? u === "y"
                      ? y / T
                      : T
                    : Math.max(T, y / T)) ||
                0) * (i === "edges" ? -1 : 1)),
            (x.b = y < 0 ? s - y : s),
            (x.u = pr(t.amount || t.each) || 0),
            (r = r && y < 0 ? OI(r) : r);
        }
        return (
          (y = (x[p] - x.min) / x.max || 0),
          $n(x.b + (r ? r(y) : y) * x.v) + x.u
        );
      }
    );
  },
  US = function (e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function (r) {
      var i = $n(Math.round(parseFloat(r) / e) * e * t);
      return (i - (i % 1)) / t + (yo(r) ? 0 : pr(r));
    };
  },
  bI = function (e, t) {
    var r = _r(e),
      i,
      s;
    return (
      !r &&
        Us(e) &&
        ((i = r = e.radius || Di),
        e.values
          ? ((e = Fi(e.values)), (s = !yo(e[0])) && (i *= i))
          : (e = US(e.increment))),
      La(
        t,
        r
          ? vn(e)
            ? function (o) {
                return (s = e(o)), Math.abs(s - o) <= i ? s : o;
              }
            : function (o) {
                for (
                  var a = parseFloat(s ? o.x : o),
                    l = parseFloat(s ? o.y : 0),
                    u = Di,
                    h = 0,
                    d = e.length,
                    p,
                    m;
                  d--;

                )
                  s
                    ? ((p = e[d].x - a), (m = e[d].y - l), (p = p * p + m * m))
                    : (p = Math.abs(e[d] - a)),
                    p < u && ((u = p), (h = d));
                return (
                  (h = !i || u <= i ? e[h] : o),
                  s || h === o || yo(o) ? h : h + pr(o)
                );
              }
          : US(e)
      )
    );
  },
  RI = function (e, t, r, i) {
    return La(_r(e) ? !t : r === !0 ? !!(r = 0) : !i, function () {
      return _r(e)
        ? e[~~(Math.random() * e.length)]
        : (r = r || 1e-5) &&
            (i = r < 1 ? Math.pow(10, (r + "").length - 2) : 1) &&
            Math.floor(
              Math.round((e - r / 2 + Math.random() * (t - e + r * 0.99)) / r) *
                r *
                i
            ) / i;
    });
  },
  SW = function () {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return function (i) {
      return t.reduce(function (s, o) {
        return o(s);
      }, i);
    };
  },
  AW = function (e, t) {
    return function (r) {
      return e(parseFloat(r)) + (t || pr(r));
    };
  },
  MW = function (e, t, r) {
    return BI(e, t, 0, 1, r);
  },
  PI = function (e, t, r) {
    return La(r, function (i) {
      return e[~~t(i)];
    });
  },
  EW = function n(e, t, r) {
    var i = t - e;
    return _r(e)
      ? PI(e, n(0, e.length), t)
      : La(r, function (s) {
          return ((i + ((s - e) % i)) % i) + e;
        });
  },
  wW = function n(e, t, r) {
    var i = t - e,
      s = i * 2;
    return _r(e)
      ? PI(e, n(0, e.length - 1), t)
      : La(r, function (o) {
          return (o = (s + ((o - e) % s)) % s || 0), e + (o > i ? s - o : o);
        });
  },
  Wh = function (e) {
    for (var t = 0, r = "", i, s, o, a; ~(i = e.indexOf("random(", t)); )
      (o = e.indexOf(")", i)),
        (a = e.charAt(i + 7) === "["),
        (s = e.substr(i + 7, o - i - 7).match(a ? hI : BS)),
        (r +=
          e.substr(t, i - t) + RI(a ? s : +s[0], a ? 0 : +s[1], +s[2] || 1e-5)),
        (t = o + 1);
    return r + e.substr(t, e.length - t);
  },
  BI = function (e, t, r, i, s) {
    var o = t - e,
      a = i - r;
    return La(s, function (l) {
      return r + (((l - e) / o) * a || 0);
    });
  },
  CW = function n(e, t, r, i) {
    var s = isNaN(e + t)
      ? 0
      : function (m) {
          return (1 - m) * e + m * t;
        };
    if (!s) {
      var o = Yn(e),
        a = {},
        l,
        u,
        h,
        d,
        p;
      if ((r === !0 && (i = 1) && (r = null), o))
        (e = { p: e }), (t = { p: t });
      else if (_r(e) && !_r(t)) {
        for (h = [], d = e.length, p = d - 2, u = 1; u < d; u++)
          h.push(n(e[u - 1], e[u]));
        d--,
          (s = function (_) {
            _ *= d;
            var y = Math.min(p, ~~_);
            return h[y](_ - y);
          }),
          (r = t);
      } else i || (e = Nl(_r(e) ? [] : {}, e));
      if (!h) {
        for (l in t) eM.call(a, e, l, "get", t[l]);
        s = function (_) {
          return iM(_, a) || (o ? e.p : e);
        };
      }
    }
    return La(r, s);
  },
  mb = function (e, t, r) {
    var i = e.labels,
      s = Di,
      o,
      a,
      l;
    for (o in i)
      (a = i[o] - t),
        a < 0 == !!r && a && s > (a = Math.abs(a)) && ((l = o), (s = a));
    return l;
  },
  Ni = function (e, t, r) {
    var i = e.vars,
      s = i[t],
      o = _n,
      a = e._ctx,
      l,
      u,
      h;
    if (s)
      return (
        (l = i[t + "Params"]),
        (u = i.callbackScope || e),
        r && pa.length && Og(),
        a && (_n = a),
        (h = l ? s.apply(u, l) : s.call(u)),
        (_n = o),
        h
      );
  },
  jf = function (e) {
    return (
      Ma(e),
      e.scrollTrigger && e.scrollTrigger.kill(!!gr),
      e.progress() < 1 && Ni(e, "onInterrupt"),
      e
    );
  },
  Zu,
  LI = [],
  II = function (e) {
    if (K1() && e) {
      e = (!e.name && e.default) || e;
      var t = e.name,
        r = vn(e),
        i =
          t && !r && e.init
            ? function () {
                this._props = [];
              }
            : e,
        s = {
          init: Vh,
          render: iM,
          add: eM,
          kill: GW,
          modifier: HW,
          rawVars: 0,
        },
        o = { targetTest: 0, get: 0, getSetter: rM, aliases: {}, register: 0 };
      if ((Dc(), e !== i)) {
        if (ii[t]) return;
        Hi(i, Hi(Ug(e, s), o)),
          Nl(i.prototype, Nl(s, Ug(e, o))),
          (ii[(i.prop = t)] = i),
          e.targetTest && (Zm.push(i), (q1[t] = 1)),
          (t =
            (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) +
            "Plugin");
      }
      mI(t, i), e.register && e.register(Xr, i, jr);
    } else e && LI.push(e);
  },
  Ht = 255,
  Xf = {
    aqua: [0, Ht, Ht],
    lime: [0, Ht, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, Ht],
    navy: [0, 0, 128],
    white: [Ht, Ht, Ht],
    olive: [128, 128, 0],
    yellow: [Ht, Ht, 0],
    orange: [Ht, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [Ht, 0, 0],
    pink: [Ht, 192, 203],
    cyan: [0, Ht, Ht],
    transparent: [Ht, Ht, Ht, 0],
  },
  Py = function (e, t, r) {
    return (
      (e += e < 0 ? 1 : e > 1 ? -1 : 0),
      ((e * 6 < 1
        ? t + (r - t) * e * 6
        : e < 0.5
        ? r
        : e * 3 < 2
        ? t + (r - t) * (2 / 3 - e) * 6
        : t) *
        Ht +
        0.5) |
        0
    );
  },
  DI = function (e, t, r) {
    var i = e ? (yo(e) ? [e >> 16, (e >> 8) & Ht, e & Ht] : 0) : Xf.black,
      s,
      o,
      a,
      l,
      u,
      h,
      d,
      p,
      m,
      _;
    if (!i) {
      if ((e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Xf[e]))
        i = Xf[e];
      else if (e.charAt(0) === "#") {
        if (
          (e.length < 6 &&
            ((s = e.charAt(1)),
            (o = e.charAt(2)),
            (a = e.charAt(3)),
            (e =
              "#" +
              s +
              s +
              o +
              o +
              a +
              a +
              (e.length === 5 ? e.charAt(4) + e.charAt(4) : ""))),
          e.length === 9)
        )
          return (
            (i = parseInt(e.substr(1, 6), 16)),
            [i >> 16, (i >> 8) & Ht, i & Ht, parseInt(e.substr(7), 16) / 255]
          );
        (e = parseInt(e.substr(1), 16)), (i = [e >> 16, (e >> 8) & Ht, e & Ht]);
      } else if (e.substr(0, 3) === "hsl") {
        if (((i = _ = e.match(BS)), !t))
          (l = (+i[0] % 360) / 360),
            (u = +i[1] / 100),
            (h = +i[2] / 100),
            (o = h <= 0.5 ? h * (u + 1) : h + u - h * u),
            (s = h * 2 - o),
            i.length > 3 && (i[3] *= 1),
            (i[0] = Py(l + 1 / 3, s, o)),
            (i[1] = Py(l, s, o)),
            (i[2] = Py(l - 1 / 3, s, o));
        else if (~e.indexOf("="))
          return (i = e.match(cI)), r && i.length < 4 && (i[3] = 1), i;
      } else i = e.match(BS) || Xf.transparent;
      i = i.map(Number);
    }
    return (
      t &&
        !_ &&
        ((s = i[0] / Ht),
        (o = i[1] / Ht),
        (a = i[2] / Ht),
        (d = Math.max(s, o, a)),
        (p = Math.min(s, o, a)),
        (h = (d + p) / 2),
        d === p
          ? (l = u = 0)
          : ((m = d - p),
            (u = h > 0.5 ? m / (2 - d - p) : m / (d + p)),
            (l =
              d === s
                ? (o - a) / m + (o < a ? 6 : 0)
                : d === o
                ? (a - s) / m + 2
                : (s - o) / m + 4),
            (l *= 60)),
        (i[0] = ~~(l + 0.5)),
        (i[1] = ~~(u * 100 + 0.5)),
        (i[2] = ~~(h * 100 + 0.5))),
      r && i.length < 4 && (i[3] = 1),
      i
    );
  },
  FI = function (e) {
    var t = [],
      r = [],
      i = -1;
    return (
      e.split(ma).forEach(function (s) {
        var o = s.match(qu) || [];
        t.push.apply(t, o), r.push((i += o.length + 1));
      }),
      (t.c = r),
      t
    );
  },
  gb = function (e, t, r) {
    var i = "",
      s = (e + i).match(ma),
      o = t ? "hsla(" : "rgba(",
      a = 0,
      l,
      u,
      h,
      d;
    if (!s) return e;
    if (
      ((s = s.map(function (p) {
        return (
          (p = DI(p, t, 1)) &&
          o +
            (t ? p[0] + "," + p[1] + "%," + p[2] + "%," + p[3] : p.join(",")) +
            ")"
        );
      })),
      r && ((h = FI(e)), (l = r.c), l.join(i) !== h.c.join(i)))
    )
      for (u = e.replace(ma, "1").split(qu), d = u.length - 1; a < d; a++)
        i +=
          u[a] +
          (~l.indexOf(a)
            ? s.shift() || o + "0,0,0,0)"
            : (h.length ? h : s.length ? s : r).shift());
    if (!u)
      for (u = e.split(ma), d = u.length - 1; a < d; a++) i += u[a] + s[a];
    return i + u[d];
  },
  ma = (function () {
    var n =
        "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      e;
    for (e in Xf) n += "|" + e + "\\b";
    return new RegExp(n + ")", "gi");
  })(),
  TW = /hsl[a]?\(/,
  NI = function (e) {
    var t = e.join(" "),
      r;
    if (((ma.lastIndex = 0), ma.test(t)))
      return (
        (r = TW.test(t)),
        (e[1] = gb(e[1], r)),
        (e[0] = gb(e[0], r, FI(e[1]))),
        !0
      );
  },
  jh,
  si = (function () {
    var n = Date.now,
      e = 500,
      t = 33,
      r = n(),
      i = r,
      s = 1e3 / 240,
      o = s,
      a = [],
      l,
      u,
      h,
      d,
      p,
      m,
      _ = function y(x) {
        var g = n() - i,
          S = x === !0,
          A,
          E,
          C,
          R;
        if (
          (g > e && (r += g - t),
          (i += g),
          (C = i - r),
          (A = C - o),
          (A > 0 || S) &&
            ((R = ++d.frame),
            (p = C - d.time * 1e3),
            (d.time = C = C / 1e3),
            (o += A + (A >= s ? 4 : s - A)),
            (E = 1)),
          S || (l = u(y)),
          E)
        )
          for (m = 0; m < a.length; m++) a[m](C, p, R, x);
      };
    return (
      (d = {
        time: 0,
        frame: 0,
        tick: function () {
          _(!0);
        },
        deltaRatio: function (x) {
          return p / (1e3 / (x || 60));
        },
        wake: function () {
          dI &&
            (!LS &&
              K1() &&
              ((bi = LS = window),
              (Y1 = bi.document || {}),
              (di.gsap = Xr),
              (bi.gsapVersions || (bi.gsapVersions = [])).push(Xr.version),
              pI(Fg || bi.GreenSockGlobals || (!bi.gsap && bi) || {}),
              (h = bi.requestAnimationFrame),
              LI.forEach(II)),
            l && d.sleep(),
            (u =
              h ||
              function (x) {
                return setTimeout(x, (o - d.time * 1e3 + 1) | 0);
              }),
            (jh = 1),
            _(2));
        },
        sleep: function () {
          (h ? bi.cancelAnimationFrame : clearTimeout)(l), (jh = 0), (u = Vh);
        },
        lagSmoothing: function (x, g) {
          (e = x || 1 / 0), (t = Math.min(g || 33, e));
        },
        fps: function (x) {
          (s = 1e3 / (x || 240)), (o = d.time * 1e3 + s);
        },
        add: function (x, g, S) {
          var A = g
            ? function (E, C, R, P) {
                x(E, C, R, P), d.remove(A);
              }
            : x;
          return d.remove(x), a[S ? "unshift" : "push"](A), Dc(), A;
        },
        remove: function (x, g) {
          ~(g = a.indexOf(x)) && a.splice(g, 1) && m >= g && m--;
        },
        _listeners: a,
      }),
      d
    );
  })(),
  Dc = function () {
    return !jh && si.wake();
  },
  Ct = {},
  bW = /^[\d.\-M][\d.\-,\s]/,
  RW = /["']/g,
  PW = function (e) {
    for (
      var t = {},
        r = e.substr(1, e.length - 3).split(":"),
        i = r[0],
        s = 1,
        o = r.length,
        a,
        l,
        u;
      s < o;
      s++
    )
      (l = r[s]),
        (a = s !== o - 1 ? l.lastIndexOf(",") : l.length),
        (u = l.substr(0, a)),
        (t[i] = isNaN(u) ? u.replace(RW, "").trim() : +u),
        (i = l.substr(a + 1).trim());
    return t;
  },
  BW = function (e) {
    var t = e.indexOf("(") + 1,
      r = e.indexOf(")"),
      i = e.indexOf("(", t);
    return e.substring(t, ~i && i < r ? e.indexOf(")", r + 1) : r);
  },
  LW = function (e) {
    var t = (e + "").split("("),
      r = Ct[t[0]];
    return r && t.length > 1 && r.config
      ? r.config.apply(
          null,
          ~e.indexOf("{") ? [PW(t[1])] : BW(e).split(",").map(yI)
        )
      : Ct._CE && bW.test(e)
      ? Ct._CE("", e)
      : r;
  },
  OI = function (e) {
    return function (t) {
      return 1 - e(1 - t);
    };
  },
  UI = function n(e, t) {
    for (var r = e._first, i; r; )
      r instanceof Or
        ? n(r, t)
        : r.vars.yoyoEase &&
          (!r._yoyo || !r._repeat) &&
          r._yoyo !== t &&
          (r.timeline
            ? n(r.timeline, t)
            : ((i = r._ease),
              (r._ease = r._yEase),
              (r._yEase = i),
              (r._yoyo = t))),
        (r = r._next);
  },
  wl = function (e, t) {
    return (e && (vn(e) ? e : Ct[e] || LW(e))) || t;
  },
  Wl = function (e, t, r, i) {
    r === void 0 &&
      (r = function (l) {
        return 1 - t(1 - l);
      }),
      i === void 0 &&
        (i = function (l) {
          return l < 0.5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2;
        });
    var s = { easeIn: t, easeOut: r, easeInOut: i },
      o;
    return (
      Wr(e, function (a) {
        (Ct[a] = di[a] = s), (Ct[(o = a.toLowerCase())] = r);
        for (var l in s)
          Ct[
            o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")
          ] = Ct[a + "." + l] = s[l];
      }),
      s
    );
  },
  kI = function (e) {
    return function (t) {
      return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
    };
  },
  By = function n(e, t, r) {
    var i = t >= 1 ? t : 1,
      s = (r || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1),
      o = (s / PS) * (Math.asin(1 / i) || 0),
      a = function (h) {
        return h === 1 ? 1 : i * Math.pow(2, -10 * h) * oW((h - o) * s) + 1;
      },
      l =
        e === "out"
          ? a
          : e === "in"
          ? function (u) {
              return 1 - a(1 - u);
            }
          : kI(a);
    return (
      (s = PS / s),
      (l.config = function (u, h) {
        return n(e, u, h);
      }),
      l
    );
  },
  Ly = function n(e, t) {
    t === void 0 && (t = 1.70158);
    var r = function (o) {
        return o ? --o * o * ((t + 1) * o + t) + 1 : 0;
      },
      i =
        e === "out"
          ? r
          : e === "in"
          ? function (s) {
              return 1 - r(1 - s);
            }
          : kI(r);
    return (
      (i.config = function (s) {
        return n(e, s);
      }),
      i
    );
  };
Wr("Linear,Quad,Cubic,Quart,Quint,Strong", function (n, e) {
  var t = e < 5 ? e + 1 : e;
  Wl(
    n + ",Power" + (t - 1),
    e
      ? function (r) {
          return Math.pow(r, t);
        }
      : function (r) {
          return r;
        },
    function (r) {
      return 1 - Math.pow(1 - r, t);
    },
    function (r) {
      return r < 0.5
        ? Math.pow(r * 2, t) / 2
        : 1 - Math.pow((1 - r) * 2, t) / 2;
    }
  );
});
Ct.Linear.easeNone = Ct.none = Ct.Linear.easeIn;
Wl("Elastic", By("in"), By("out"), By());
(function (n, e) {
  var t = 1 / e,
    r = 2 * t,
    i = 2.5 * t,
    s = function (a) {
      return a < t
        ? n * a * a
        : a < r
        ? n * Math.pow(a - 1.5 / e, 2) + 0.75
        : a < i
        ? n * (a -= 2.25 / e) * a + 0.9375
        : n * Math.pow(a - 2.625 / e, 2) + 0.984375;
    };
  Wl(
    "Bounce",
    function (o) {
      return 1 - s(1 - o);
    },
    s
  );
})(7.5625, 2.75);
Wl("Expo", function (n) {
  return n ? Math.pow(2, 10 * (n - 1)) : 0;
});
Wl("Circ", function (n) {
  return -(lI(1 - n * n) - 1);
});
Wl("Sine", function (n) {
  return n === 1 ? 1 : -sW(n * rW) + 1;
});
Wl("Back", Ly("in"), Ly("out"), Ly());
Ct.SteppedEase =
  Ct.steps =
  di.SteppedEase =
    {
      config: function (e, t) {
        e === void 0 && (e = 1);
        var r = 1 / e,
          i = e + (t ? 0 : 1),
          s = t ? 1 : 0,
          o = 1 - Gt;
        return function (a) {
          return (((i * xd(0, o, a)) | 0) + s) * r;
        };
      },
    };
Bc.ease = Ct["quad.out"];
Wr(
  "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
  function (n) {
    return (Z1 += n + "," + n + "Params,");
  }
);
var zI = function (e, t) {
    (this.id = iW++),
      (e._gsap = this),
      (this.target = e),
      (this.harness = t),
      (this.get = t ? t.get : _I),
      (this.set = t ? t.getSetter : rM);
  },
  Xh = (function () {
    function n(t) {
      (this.vars = t),
        (this._delay = +t.delay || 0),
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
          ((this._rDelay = t.repeatDelay || 0),
          (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
        (this._ts = 1),
        Ic(this, +t.duration, 1, 1),
        (this.data = t.data),
        _n && ((this._ctx = _n), _n.data.push(this)),
        jh || si.wake();
    }
    var e = n.prototype;
    return (
      (e.delay = function (r) {
        return r || r === 0
          ? (this.parent &&
              this.parent.smoothChildTiming &&
              this.startTime(this._start + r - this._delay),
            (this._delay = r),
            this)
          : this._delay;
      }),
      (e.duration = function (r) {
        return arguments.length
          ? this.totalDuration(
              this._repeat > 0 ? r + (r + this._rDelay) * this._repeat : r
            )
          : this.totalDuration() && this._dur;
      }),
      (e.totalDuration = function (r) {
        return arguments.length
          ? ((this._dirty = 0),
            Ic(
              this,
              this._repeat < 0
                ? r
                : (r - this._repeat * this._rDelay) / (this._repeat + 1)
            ))
          : this._tDur;
      }),
      (e.totalTime = function (r, i) {
        if ((Dc(), !arguments.length)) return this._tTime;
        var s = this._dp;
        if (s && s.smoothChildTiming && this._ts) {
          for (K0(this, r), !s._dp || s.parent || AI(s, this); s && s.parent; )
            s.parent._time !==
              s._start +
                (s._ts >= 0
                  ? s._tTime / s._ts
                  : (s.totalDuration() - s._tTime) / -s._ts) &&
              s.totalTime(s._tTime, !0),
              (s = s.parent);
          !this.parent &&
            this._dp.autoRemoveChildren &&
            ((this._ts > 0 && r < this._tDur) ||
              (this._ts < 0 && r > 0) ||
              (!this._tDur && !r)) &&
            Es(this._dp, this, this._start - this._delay);
        }
        return (
          (this._tTime !== r ||
            (!this._dur && !i) ||
            (this._initted && Math.abs(this._zTime) === Gt) ||
            (!r && !this._initted && (this.add || this._ptLookup))) &&
            (this._ts || (this._pTime = r), vI(this, r, i)),
          this
        );
      }),
      (e.time = function (r, i) {
        return arguments.length
          ? this.totalTime(
              Math.min(this.totalDuration(), r + db(this)) %
                (this._dur + this._rDelay) || (r ? this._dur : 0),
              i
            )
          : this._time;
      }),
      (e.totalProgress = function (r, i) {
        return arguments.length
          ? this.totalTime(this.totalDuration() * r, i)
          : this.totalDuration()
          ? Math.min(1, this._tTime / this._tDur)
          : this.ratio;
      }),
      (e.progress = function (r, i) {
        return arguments.length
          ? this.totalTime(
              this.duration() *
                (this._yoyo && !(this.iteration() & 1) ? 1 - r : r) +
                db(this),
              i
            )
          : this.duration()
          ? Math.min(1, this._time / this._dur)
          : this.ratio;
      }),
      (e.iteration = function (r, i) {
        var s = this.duration() + this._rDelay;
        return arguments.length
          ? this.totalTime(this._time + (r - 1) * s, i)
          : this._repeat
          ? Lc(this._tTime, s) + 1
          : 1;
      }),
      (e.timeScale = function (r) {
        if (!arguments.length) return this._rts === -Gt ? 0 : this._rts;
        if (this._rts === r) return this;
        var i =
          this.parent && this._ts ? kg(this.parent._time, this) : this._tTime;
        return (
          (this._rts = +r || 0),
          (this._ts = this._ps || r === -Gt ? 0 : this._rts),
          this.totalTime(xd(-Math.abs(this._delay), this._tDur, i), !0),
          J0(this),
          dW(this)
        );
      }),
      (e.paused = function (r) {
        return arguments.length
          ? (this._ps !== r &&
              ((this._ps = r),
              r
                ? ((this._pTime =
                    this._tTime || Math.max(-this._delay, this.rawTime())),
                  (this._ts = this._act = 0))
                : (Dc(),
                  (this._ts = this._rts),
                  this.totalTime(
                    this.parent && !this.parent.smoothChildTiming
                      ? this.rawTime()
                      : this._tTime || this._pTime,
                    this.progress() === 1 &&
                      Math.abs(this._zTime) !== Gt &&
                      (this._tTime -= Gt)
                  ))),
            this)
          : this._ps;
      }),
      (e.startTime = function (r) {
        if (arguments.length) {
          this._start = r;
          var i = this.parent || this._dp;
          return (
            i && (i._sort || !this.parent) && Es(i, this, r - this._delay), this
          );
        }
        return this._start;
      }),
      (e.endTime = function (r) {
        return (
          this._start +
          (Vr(r) ? this.totalDuration() : this.duration()) /
            Math.abs(this._ts || 1)
        );
      }),
      (e.rawTime = function (r) {
        var i = this.parent || this._dp;
        return i
          ? r &&
            (!this._ts ||
              (this._repeat && this._time && this.totalProgress() < 1))
            ? this._tTime % (this._dur + this._rDelay)
            : this._ts
            ? kg(i.rawTime(r), this)
            : this._tTime
          : this._tTime;
      }),
      (e.revert = function (r) {
        r === void 0 && (r = uW);
        var i = gr;
        return (
          (gr = r),
          (this._initted || this._startAt) &&
            (this.timeline && this.timeline.revert(r),
            this.totalTime(-0.01, r.suppressEvents)),
          this.data !== "nested" && r.kill !== !1 && this.kill(),
          (gr = i),
          this
        );
      }),
      (e.globalTime = function (r) {
        for (var i = this, s = arguments.length ? r : i.rawTime(); i; )
          (s = i._start + s / (i._ts || 1)), (i = i._dp);
        return !this.parent && this._sat
          ? this._sat.vars.immediateRender
            ? -1 / 0
            : this._sat.globalTime(r)
          : s;
      }),
      (e.repeat = function (r) {
        return arguments.length
          ? ((this._repeat = r === 1 / 0 ? -2 : r), pb(this))
          : this._repeat === -2
          ? 1 / 0
          : this._repeat;
      }),
      (e.repeatDelay = function (r) {
        if (arguments.length) {
          var i = this._time;
          return (this._rDelay = r), pb(this), i ? this.time(i) : this;
        }
        return this._rDelay;
      }),
      (e.yoyo = function (r) {
        return arguments.length ? ((this._yoyo = r), this) : this._yoyo;
      }),
      (e.seek = function (r, i) {
        return this.totalTime(Ci(this, r), Vr(i));
      }),
      (e.restart = function (r, i) {
        return this.play().totalTime(r ? -this._delay : 0, Vr(i));
      }),
      (e.play = function (r, i) {
        return r != null && this.seek(r, i), this.reversed(!1).paused(!1);
      }),
      (e.reverse = function (r, i) {
        return (
          r != null && this.seek(r || this.totalDuration(), i),
          this.reversed(!0).paused(!1)
        );
      }),
      (e.pause = function (r, i) {
        return r != null && this.seek(r, i), this.paused(!0);
      }),
      (e.resume = function () {
        return this.paused(!1);
      }),
      (e.reversed = function (r) {
        return arguments.length
          ? (!!r !== this.reversed() &&
              this.timeScale(-this._rts || (r ? -Gt : 0)),
            this)
          : this._rts < 0;
      }),
      (e.invalidate = function () {
        return (this._initted = this._act = 0), (this._zTime = -Gt), this;
      }),
      (e.isActive = function () {
        var r = this.parent || this._dp,
          i = this._start,
          s;
        return !!(
          !r ||
          (this._ts &&
            this._initted &&
            r.isActive() &&
            (s = r.rawTime(!0)) >= i &&
            s < this.endTime(!0) - Gt)
        );
      }),
      (e.eventCallback = function (r, i, s) {
        var o = this.vars;
        return arguments.length > 1
          ? (i
              ? ((o[r] = i),
                s && (o[r + "Params"] = s),
                r === "onUpdate" && (this._onUpdate = i))
              : delete o[r],
            this)
          : o[r];
      }),
      (e.then = function (r) {
        var i = this;
        return new Promise(function (s) {
          var o = vn(r) ? r : xI,
            a = function () {
              var u = i.then;
              (i.then = null),
                vn(o) && (o = o(i)) && (o.then || o === i) && (i.then = u),
                s(o),
                (i.then = u);
            };
          (i._initted && i.totalProgress() === 1 && i._ts >= 0) ||
          (!i._tTime && i._ts < 0)
            ? a()
            : (i._prom = a);
        });
      }),
      (e.kill = function () {
        jf(this);
      }),
      n
    );
  })();
Hi(Xh.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -Gt,
  _prom: 0,
  _ps: !1,
  _rts: 1,
});
var Or = (function (n) {
  aI(e, n);
  function e(r, i) {
    var s;
    return (
      r === void 0 && (r = {}),
      (s = n.call(this, r) || this),
      (s.labels = {}),
      (s.smoothChildTiming = !!r.smoothChildTiming),
      (s.autoRemoveChildren = !!r.autoRemoveChildren),
      (s._sort = Vr(r.sortChildren)),
      rn && Es(r.parent || rn, no(s), i),
      r.reversed && s.reverse(),
      r.paused && s.paused(!0),
      r.scrollTrigger && MI(no(s), r.scrollTrigger),
      s
    );
  }
  var t = e.prototype;
  return (
    (t.to = function (i, s, o) {
      return lh(0, arguments, this), this;
    }),
    (t.from = function (i, s, o) {
      return lh(1, arguments, this), this;
    }),
    (t.fromTo = function (i, s, o, a) {
      return lh(2, arguments, this), this;
    }),
    (t.set = function (i, s, o) {
      return (
        (s.duration = 0),
        (s.parent = this),
        ah(s).repeatDelay || (s.repeat = 0),
        (s.immediateRender = !!s.immediateRender),
        new Pn(i, s, Ci(this, o), 1),
        this
      );
    }),
    (t.call = function (i, s, o) {
      return Es(this, Pn.delayedCall(0, i, s), o);
    }),
    (t.staggerTo = function (i, s, o, a, l, u, h) {
      return (
        (o.duration = s),
        (o.stagger = o.stagger || a),
        (o.onComplete = u),
        (o.onCompleteParams = h),
        (o.parent = this),
        new Pn(i, o, Ci(this, l)),
        this
      );
    }),
    (t.staggerFrom = function (i, s, o, a, l, u, h) {
      return (
        (o.runBackwards = 1),
        (ah(o).immediateRender = Vr(o.immediateRender)),
        this.staggerTo(i, s, o, a, l, u, h)
      );
    }),
    (t.staggerFromTo = function (i, s, o, a, l, u, h, d) {
      return (
        (a.startAt = o),
        (ah(a).immediateRender = Vr(a.immediateRender)),
        this.staggerTo(i, s, a, l, u, h, d)
      );
    }),
    (t.render = function (i, s, o) {
      var a = this._time,
        l = this._dirty ? this.totalDuration() : this._tDur,
        u = this._dur,
        h = i <= 0 ? 0 : $n(i),
        d = this._zTime < 0 != i < 0 && (this._initted || !u),
        p,
        m,
        _,
        y,
        x,
        g,
        S,
        A,
        E,
        C,
        R,
        P;
      if (
        (this !== rn && h > l && i >= 0 && (h = l), h !== this._tTime || o || d)
      ) {
        if (
          (a !== this._time &&
            u &&
            ((h += this._time - a), (i += this._time - a)),
          (p = h),
          (E = this._start),
          (A = this._ts),
          (g = !A),
          d && (u || (a = this._zTime), (i || !s) && (this._zTime = i)),
          this._repeat)
        ) {
          if (
            ((R = this._yoyo),
            (x = u + this._rDelay),
            this._repeat < -1 && i < 0)
          )
            return this.totalTime(x * 100 + i, s, o);
          if (
            ((p = $n(h % x)),
            h === l
              ? ((y = this._repeat), (p = u))
              : ((y = ~~(h / x)),
                y && y === h / x && ((p = u), y--),
                p > u && (p = u)),
            (C = Lc(this._tTime, x)),
            !a &&
              this._tTime &&
              C !== y &&
              this._tTime - C * x - this._dur <= 0 &&
              (C = y),
            R && y & 1 && ((p = u - p), (P = 1)),
            y !== C && !this._lock)
          ) {
            var L = R && C & 1,
              T = L === (R && y & 1);
            if (
              (y < C && (L = !L),
              (a = L ? 0 : h % u ? u : h),
              (this._lock = 1),
              (this.render(a || (P ? 0 : $n(y * x)), s, !u)._lock = 0),
              (this._tTime = h),
              !s && this.parent && Ni(this, "onRepeat"),
              this.vars.repeatRefresh && !P && (this.invalidate()._lock = 1),
              (a && a !== this._time) ||
                g !== !this._ts ||
                (this.vars.onRepeat && !this.parent && !this._act))
            )
              return this;
            if (
              ((u = this._dur),
              (l = this._tDur),
              T &&
                ((this._lock = 2),
                (a = L ? u : -1e-4),
                this.render(a, !0),
                this.vars.repeatRefresh && !P && this.invalidate()),
              (this._lock = 0),
              !this._ts && !g)
            )
              return this;
            UI(this, P);
          }
        }
        if (
          (this._hasPause &&
            !this._forcing &&
            this._lock < 2 &&
            ((S = _W(this, $n(a), $n(p))), S && (h -= p - (p = S._start))),
          (this._tTime = h),
          (this._time = p),
          (this._act = !A),
          this._initted ||
            ((this._onUpdate = this.vars.onUpdate),
            (this._initted = 1),
            (this._zTime = i),
            (a = 0)),
          !a && p && !s && !y && (Ni(this, "onStart"), this._tTime !== h))
        )
          return this;
        if (p >= a && i >= 0)
          for (m = this._first; m; ) {
            if (
              ((_ = m._next), (m._act || p >= m._start) && m._ts && S !== m)
            ) {
              if (m.parent !== this) return this.render(i, s, o);
              if (
                (m.render(
                  m._ts > 0
                    ? (p - m._start) * m._ts
                    : (m._dirty ? m.totalDuration() : m._tDur) +
                        (p - m._start) * m._ts,
                  s,
                  o
                ),
                p !== this._time || (!this._ts && !g))
              ) {
                (S = 0), _ && (h += this._zTime = -Gt);
                break;
              }
            }
            m = _;
          }
        else {
          m = this._last;
          for (var B = i < 0 ? i : p; m; ) {
            if (((_ = m._prev), (m._act || B <= m._end) && m._ts && S !== m)) {
              if (m.parent !== this) return this.render(i, s, o);
              if (
                (m.render(
                  m._ts > 0
                    ? (B - m._start) * m._ts
                    : (m._dirty ? m.totalDuration() : m._tDur) +
                        (B - m._start) * m._ts,
                  s,
                  o || (gr && (m._initted || m._startAt))
                ),
                p !== this._time || (!this._ts && !g))
              ) {
                (S = 0), _ && (h += this._zTime = B ? -Gt : Gt);
                break;
              }
            }
            m = _;
          }
        }
        if (
          S &&
          !s &&
          (this.pause(),
          (S.render(p >= a ? 0 : -Gt)._zTime = p >= a ? 1 : -1),
          this._ts)
        )
          return (this._start = E), J0(this), this.render(i, s, o);
        this._onUpdate && !s && Ni(this, "onUpdate", !0),
          ((h === l && this._tTime >= this.totalDuration()) || (!h && a)) &&
            (E === this._start || Math.abs(A) !== Math.abs(this._ts)) &&
            (this._lock ||
              ((i || !u) &&
                ((h === l && this._ts > 0) || (!h && this._ts < 0)) &&
                Ma(this, 1),
              !s &&
                !(i < 0 && !a) &&
                (h || a || !l) &&
                (Ni(
                  this,
                  h === l && i >= 0 ? "onComplete" : "onReverseComplete",
                  !0
                ),
                this._prom &&
                  !(h < l && this.timeScale() > 0) &&
                  this._prom())));
      }
      return this;
    }),
    (t.add = function (i, s) {
      var o = this;
      if ((yo(s) || (s = Ci(this, s, i)), !(i instanceof Xh))) {
        if (_r(i))
          return (
            i.forEach(function (a) {
              return o.add(a, s);
            }),
            this
          );
        if (Yn(i)) return this.addLabel(i, s);
        if (vn(i)) i = Pn.delayedCall(0, i);
        else return this;
      }
      return this !== i ? Es(this, i, s) : this;
    }),
    (t.getChildren = function (i, s, o, a) {
      i === void 0 && (i = !0),
        s === void 0 && (s = !0),
        o === void 0 && (o = !0),
        a === void 0 && (a = -Di);
      for (var l = [], u = this._first; u; )
        u._start >= a &&
          (u instanceof Pn
            ? s && l.push(u)
            : (o && l.push(u), i && l.push.apply(l, u.getChildren(!0, s, o)))),
          (u = u._next);
      return l;
    }),
    (t.getById = function (i) {
      for (var s = this.getChildren(1, 1, 1), o = s.length; o--; )
        if (s[o].vars.id === i) return s[o];
    }),
    (t.remove = function (i) {
      return Yn(i)
        ? this.removeLabel(i)
        : vn(i)
        ? this.killTweensOf(i)
        : (X0(this, i),
          i === this._recent && (this._recent = this._last),
          El(this));
    }),
    (t.totalTime = function (i, s) {
      return arguments.length
        ? ((this._forcing = 1),
          !this._dp &&
            this._ts &&
            (this._start = $n(
              si.time -
                (this._ts > 0
                  ? i / this._ts
                  : (this.totalDuration() - i) / -this._ts)
            )),
          n.prototype.totalTime.call(this, i, s),
          (this._forcing = 0),
          this)
        : this._tTime;
    }),
    (t.addLabel = function (i, s) {
      return (this.labels[i] = Ci(this, s)), this;
    }),
    (t.removeLabel = function (i) {
      return delete this.labels[i], this;
    }),
    (t.addPause = function (i, s, o) {
      var a = Pn.delayedCall(0, s || Vh, o);
      return (
        (a.data = "isPause"), (this._hasPause = 1), Es(this, a, Ci(this, i))
      );
    }),
    (t.removePause = function (i) {
      var s = this._first;
      for (i = Ci(this, i); s; )
        s._start === i && s.data === "isPause" && Ma(s), (s = s._next);
    }),
    (t.killTweensOf = function (i, s, o) {
      for (var a = this.getTweensOf(i, o), l = a.length; l--; )
        qo !== a[l] && a[l].kill(i, s);
      return this;
    }),
    (t.getTweensOf = function (i, s) {
      for (var o = [], a = Fi(i), l = this._first, u = yo(s), h; l; )
        l instanceof Pn
          ? cW(l._targets, a) &&
            (u
              ? (!qo || (l._initted && l._ts)) &&
                l.globalTime(0) <= s &&
                l.globalTime(l.totalDuration()) > s
              : !s || l.isActive()) &&
            o.push(l)
          : (h = l.getTweensOf(a, s)).length && o.push.apply(o, h),
          (l = l._next);
      return o;
    }),
    (t.tweenTo = function (i, s) {
      s = s || {};
      var o = this,
        a = Ci(o, i),
        l = s,
        u = l.startAt,
        h = l.onStart,
        d = l.onStartParams,
        p = l.immediateRender,
        m,
        _ = Pn.to(
          o,
          Hi(
            {
              ease: s.ease || "none",
              lazy: !1,
              immediateRender: !1,
              time: a,
              overwrite: "auto",
              duration:
                s.duration ||
                Math.abs(
                  (a - (u && "time" in u ? u.time : o._time)) / o.timeScale()
                ) ||
                Gt,
              onStart: function () {
                if ((o.pause(), !m)) {
                  var x =
                    s.duration ||
                    Math.abs(
                      (a - (u && "time" in u ? u.time : o._time)) /
                        o.timeScale()
                    );
                  _._dur !== x && Ic(_, x, 0, 1).render(_._time, !0, !0),
                    (m = 1);
                }
                h && h.apply(_, d || []);
              },
            },
            s
          )
        );
      return p ? _.render(0) : _;
    }),
    (t.tweenFromTo = function (i, s, o) {
      return this.tweenTo(s, Hi({ startAt: { time: Ci(this, i) } }, o));
    }),
    (t.recent = function () {
      return this._recent;
    }),
    (t.nextLabel = function (i) {
      return i === void 0 && (i = this._time), mb(this, Ci(this, i));
    }),
    (t.previousLabel = function (i) {
      return i === void 0 && (i = this._time), mb(this, Ci(this, i), 1);
    }),
    (t.currentLabel = function (i) {
      return arguments.length
        ? this.seek(i, !0)
        : this.previousLabel(this._time + Gt);
    }),
    (t.shiftChildren = function (i, s, o) {
      o === void 0 && (o = 0);
      for (var a = this._first, l = this.labels, u; a; )
        a._start >= o && ((a._start += i), (a._end += i)), (a = a._next);
      if (s) for (u in l) l[u] >= o && (l[u] += i);
      return El(this);
    }),
    (t.invalidate = function (i) {
      var s = this._first;
      for (this._lock = 0; s; ) s.invalidate(i), (s = s._next);
      return n.prototype.invalidate.call(this, i);
    }),
    (t.clear = function (i) {
      i === void 0 && (i = !0);
      for (var s = this._first, o; s; ) (o = s._next), this.remove(s), (s = o);
      return (
        this._dp && (this._time = this._tTime = this._pTime = 0),
        i && (this.labels = {}),
        El(this)
      );
    }),
    (t.totalDuration = function (i) {
      var s = 0,
        o = this,
        a = o._last,
        l = Di,
        u,
        h,
        d;
      if (arguments.length)
        return o.timeScale(
          (o._repeat < 0 ? o.duration() : o.totalDuration()) /
            (o.reversed() ? -i : i)
        );
      if (o._dirty) {
        for (d = o.parent; a; )
          (u = a._prev),
            a._dirty && a.totalDuration(),
            (h = a._start),
            h > l && o._sort && a._ts && !o._lock
              ? ((o._lock = 1), (Es(o, a, h - a._delay, 1)._lock = 0))
              : (l = h),
            h < 0 &&
              a._ts &&
              ((s -= h),
              ((!d && !o._dp) || (d && d.smoothChildTiming)) &&
                ((o._start += h / o._ts), (o._time -= h), (o._tTime -= h)),
              o.shiftChildren(-h, !1, -1 / 0),
              (l = 0)),
            a._end > s && a._ts && (s = a._end),
            (a = u);
        Ic(o, o === rn && o._time > s ? o._time : s, 1, 1), (o._dirty = 0);
      }
      return o._tDur;
    }),
    (e.updateRoot = function (i) {
      if ((rn._ts && (vI(rn, kg(i, rn)), (gI = si.frame)), si.frame >= fb)) {
        fb += ci.autoSleep || 120;
        var s = rn._first;
        if ((!s || !s._ts) && ci.autoSleep && si._listeners.length < 2) {
          for (; s && !s._ts; ) s = s._next;
          s || si.sleep();
        }
      }
    }),
    e
  );
})(Xh);
Hi(Or.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var IW = function (e, t, r, i, s, o, a) {
    var l = new jr(this._pt, e, t, 0, 1, XI, null, s),
      u = 0,
      h = 0,
      d,
      p,
      m,
      _,
      y,
      x,
      g,
      S;
    for (
      l.b = r,
        l.e = i,
        r += "",
        i += "",
        (g = ~i.indexOf("random(")) && (i = Wh(i)),
        o && ((S = [r, i]), o(S, e, t), (r = S[0]), (i = S[1])),
        p = r.match(by) || [];
      (d = by.exec(i));

    )
      (_ = d[0]),
        (y = i.substring(u, d.index)),
        m ? (m = (m + 1) % 5) : y.substr(-5) === "rgba(" && (m = 1),
        _ !== p[h++] &&
          ((x = parseFloat(p[h - 1]) || 0),
          (l._pt = {
            _next: l._pt,
            p: y || h === 1 ? y : ",",
            s: x,
            c: _.charAt(1) === "=" ? uc(x, _) - x : parseFloat(_) - x,
            m: m && m < 4 ? Math.round : 0,
          }),
          (u = by.lastIndex));
    return (
      (l.c = u < i.length ? i.substring(u, i.length) : ""),
      (l.fp = a),
      (fI.test(i) || g) && (l.e = 0),
      (this._pt = l),
      l
    );
  },
  eM = function (e, t, r, i, s, o, a, l, u, h) {
    vn(i) && (i = i(s || 0, e, o));
    var d = e[t],
      p =
        r !== "get"
          ? r
          : vn(d)
          ? u
            ? e[
                t.indexOf("set") || !vn(e["get" + t.substr(3)])
                  ? t
                  : "get" + t.substr(3)
              ](u)
            : e[t]()
          : d,
      m = vn(d) ? (u ? UW : WI) : nM,
      _;
    if (
      (Yn(i) &&
        (~i.indexOf("random(") && (i = Wh(i)),
        i.charAt(1) === "=" &&
          ((_ = uc(p, i) + (pr(p) || 0)), (_ || _ === 0) && (i = _))),
      !h || p !== i || kS)
    )
      return !isNaN(p * i) && i !== ""
        ? ((_ = new jr(
            this._pt,
            e,
            t,
            +p || 0,
            i - (p || 0),
            typeof d == "boolean" ? zW : jI,
            0,
            m
          )),
          u && (_.fp = u),
          a && _.modifier(a, this, e),
          (this._pt = _))
        : (!d && !(t in e) && Q1(t, i),
          IW.call(this, e, t, p, i, m, l || ci.stringFilter, u));
  },
  DW = function (e, t, r, i, s) {
    if (
      (vn(e) && (e = uh(e, s, t, r, i)),
      !Us(e) || (e.style && e.nodeType) || _r(e) || uI(e))
    )
      return Yn(e) ? uh(e, s, t, r, i) : e;
    var o = {},
      a;
    for (a in e) o[a] = uh(e[a], s, t, r, i);
    return o;
  },
  HI = function (e, t, r, i, s, o) {
    var a, l, u, h;
    if (
      ii[e] &&
      (a = new ii[e]()).init(
        s,
        a.rawVars ? t[e] : DW(t[e], i, s, o, r),
        r,
        i,
        o
      ) !== !1 &&
      ((r._pt = l = new jr(r._pt, s, e, 0, 1, a.render, a, 0, a.priority)),
      r !== Zu)
    )
      for (u = r._ptLookup[r._targets.indexOf(s)], h = a._props.length; h--; )
        u[a._props[h]] = l;
    return a;
  },
  qo,
  kS,
  tM = function n(e, t, r) {
    var i = e.vars,
      s = i.ease,
      o = i.startAt,
      a = i.immediateRender,
      l = i.lazy,
      u = i.onUpdate,
      h = i.onUpdateParams,
      d = i.callbackScope,
      p = i.runBackwards,
      m = i.yoyoEase,
      _ = i.keyframes,
      y = i.autoRevert,
      x = e._dur,
      g = e._startAt,
      S = e._targets,
      A = e.parent,
      E = A && A.data === "nested" ? A.vars.targets : S,
      C = e._overwrite === "auto" && !X1,
      R = e.timeline,
      P,
      L,
      T,
      B,
      D,
      I,
      F,
      k,
      j,
      Z,
      Q,
      N,
      W;
    if (
      (R && (!_ || !s) && (s = "none"),
      (e._ease = wl(s, Bc.ease)),
      (e._yEase = m ? OI(wl(m === !0 ? s : m, Bc.ease)) : 0),
      m &&
        e._yoyo &&
        !e._repeat &&
        ((m = e._yEase), (e._yEase = e._ease), (e._ease = m)),
      (e._from = !R && !!i.runBackwards),
      !R || (_ && !i.stagger))
    ) {
      if (
        ((k = S[0] ? Ml(S[0]).harness : 0),
        (N = k && i[k.prop]),
        (P = Ug(i, q1)),
        g &&
          (g._zTime < 0 && g.progress(1),
          t < 0 && p && a && !y ? g.render(-1, !0) : g.revert(p && x ? qm : lW),
          (g._lazy = 0)),
        o)
      ) {
        if (
          (Ma(
            (e._startAt = Pn.set(
              S,
              Hi(
                {
                  data: "isStart",
                  overwrite: !1,
                  parent: A,
                  immediateRender: !0,
                  lazy: !g && Vr(l),
                  startAt: null,
                  delay: 0,
                  onUpdate: u,
                  onUpdateParams: h,
                  callbackScope: d,
                  stagger: 0,
                },
                o
              )
            ))
          ),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (gr || (!a && !y)) && e._startAt.revert(qm),
          a && x && t <= 0 && r <= 0)
        ) {
          t && (e._zTime = t);
          return;
        }
      } else if (p && x && !g) {
        if (
          (t && (a = !1),
          (T = Hi(
            {
              overwrite: !1,
              data: "isFromStart",
              lazy: a && !g && Vr(l),
              immediateRender: a,
              stagger: 0,
              parent: A,
            },
            P
          )),
          N && (T[k.prop] = N),
          Ma((e._startAt = Pn.set(S, T))),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (gr ? e._startAt.revert(qm) : e._startAt.render(-1, !0)),
          (e._zTime = t),
          !a)
        )
          n(e._startAt, Gt, Gt);
        else if (!t) return;
      }
      for (
        e._pt = e._ptCache = 0, l = (x && Vr(l)) || (l && !x), L = 0;
        L < S.length;
        L++
      ) {
        if (
          ((D = S[L]),
          (F = D._gsap || $1(S)[L]._gsap),
          (e._ptLookup[L] = Z = {}),
          IS[F.id] && pa.length && Og(),
          (Q = E === S ? L : E.indexOf(D)),
          k &&
            (j = new k()).init(D, N || P, e, Q, E) !== !1 &&
            ((e._pt = B =
              new jr(e._pt, D, j.name, 0, 1, j.render, j, 0, j.priority)),
            j._props.forEach(function (G) {
              Z[G] = B;
            }),
            j.priority && (I = 1)),
          !k || N)
        )
          for (T in P)
            ii[T] && (j = HI(T, P, e, Q, D, E))
              ? j.priority && (I = 1)
              : (Z[T] = B =
                  eM.call(e, D, T, "get", P[T], Q, E, 0, i.stringFilter));
        e._op && e._op[L] && e.kill(D, e._op[L]),
          C &&
            e._pt &&
            ((qo = e),
            rn.killTweensOf(D, Z, e.globalTime(t)),
            (W = !e.parent),
            (qo = 0)),
          e._pt && l && (IS[F.id] = 1);
      }
      I && JI(e), e._onInit && e._onInit(e);
    }
    (e._onUpdate = u),
      (e._initted = (!e._op || e._pt) && !W),
      _ && t <= 0 && R.render(Di, !0, !0);
  },
  FW = function (e, t, r, i, s, o, a) {
    var l = ((e._pt && e._ptCache) || (e._ptCache = {}))[t],
      u,
      h,
      d,
      p;
    if (!l)
      for (
        l = e._ptCache[t] = [], d = e._ptLookup, p = e._targets.length;
        p--;

      ) {
        if (((u = d[p][t]), u && u.d && u.d._pt))
          for (u = u.d._pt; u && u.p !== t && u.fp !== t; ) u = u._next;
        if (!u) return (kS = 1), (e.vars[t] = "+=0"), tM(e, a), (kS = 0), 1;
        l.push(u);
      }
    for (p = l.length; p--; )
      (h = l[p]),
        (u = h._pt || h),
        (u.s = (i || i === 0) && !s ? i : u.s + (i || 0) + o * u.c),
        (u.c = r - u.s),
        h.e && (h.e = Sn(r) + pr(h.e)),
        h.b && (h.b = u.s + pr(h.b));
  },
  NW = function (e, t) {
    var r = e[0] ? Ml(e[0]).harness : 0,
      i = r && r.aliases,
      s,
      o,
      a,
      l;
    if (!i) return t;
    s = Nl({}, t);
    for (o in i)
      if (o in s) for (l = i[o].split(","), a = l.length; a--; ) s[l[a]] = s[o];
    return s;
  },
  OW = function (e, t, r, i) {
    var s = t.ease || i || "power1.inOut",
      o,
      a;
    if (_r(t))
      (a = r[e] || (r[e] = [])),
        t.forEach(function (l, u) {
          return a.push({ t: (u / (t.length - 1)) * 100, v: l, e: s });
        });
    else
      for (o in t)
        (a = r[o] || (r[o] = [])),
          o === "ease" || a.push({ t: parseFloat(e), v: t[o], e: s });
  },
  uh = function (e, t, r, i, s) {
    return vn(e)
      ? e.call(t, r, i, s)
      : Yn(e) && ~e.indexOf("random(")
      ? Wh(e)
      : e;
  },
  GI = Z1 + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
  VI = {};
Wr(GI + ",id,stagger,delay,duration,paused,scrollTrigger", function (n) {
  return (VI[n] = 1);
});
var Pn = (function (n) {
  aI(e, n);
  function e(r, i, s, o) {
    var a;
    typeof i == "number" && ((s.duration = i), (i = s), (s = null)),
      (a = n.call(this, o ? i : ah(i)) || this);
    var l = a.vars,
      u = l.duration,
      h = l.delay,
      d = l.immediateRender,
      p = l.stagger,
      m = l.overwrite,
      _ = l.keyframes,
      y = l.defaults,
      x = l.scrollTrigger,
      g = l.yoyoEase,
      S = i.parent || rn,
      A = (_r(r) || uI(r) ? yo(r[0]) : "length" in i) ? [r] : Fi(r),
      E,
      C,
      R,
      P,
      L,
      T,
      B,
      D;
    if (
      ((a._targets = A.length
        ? $1(A)
        : Ng(
            "GSAP target " + r + " not found. https://greensock.com",
            !ci.nullTargetWarn
          ) || []),
      (a._ptLookup = []),
      (a._overwrite = m),
      _ || p || Cm(u) || Cm(h))
    ) {
      if (
        ((i = a.vars),
        (E = a.timeline =
          new Or({
            data: "nested",
            defaults: y || {},
            targets: S && S.data === "nested" ? S.vars.targets : A,
          })),
        E.kill(),
        (E.parent = E._dp = no(a)),
        (E._start = 0),
        p || Cm(u) || Cm(h))
      ) {
        if (((P = A.length), (B = p && TI(p)), Us(p)))
          for (L in p) ~GI.indexOf(L) && (D || (D = {}), (D[L] = p[L]));
        for (C = 0; C < P; C++)
          (R = Ug(i, VI)),
            (R.stagger = 0),
            g && (R.yoyoEase = g),
            D && Nl(R, D),
            (T = A[C]),
            (R.duration = +uh(u, no(a), C, T, A)),
            (R.delay = (+uh(h, no(a), C, T, A) || 0) - a._delay),
            !p &&
              P === 1 &&
              R.delay &&
              ((a._delay = h = R.delay), (a._start += h), (R.delay = 0)),
            E.to(T, R, B ? B(C, T, A) : 0),
            (E._ease = Ct.none);
        E.duration() ? (u = h = 0) : (a.timeline = 0);
      } else if (_) {
        ah(Hi(E.vars.defaults, { ease: "none" })),
          (E._ease = wl(_.ease || i.ease || "none"));
        var I = 0,
          F,
          k,
          j;
        if (_r(_))
          _.forEach(function (Z) {
            return E.to(A, Z, ">");
          }),
            E.duration();
        else {
          R = {};
          for (L in _)
            L === "ease" || L === "easeEach" || OW(L, _[L], R, _.easeEach);
          for (L in R)
            for (
              F = R[L].sort(function (Z, Q) {
                return Z.t - Q.t;
              }),
                I = 0,
                C = 0;
              C < F.length;
              C++
            )
              (k = F[C]),
                (j = {
                  ease: k.e,
                  duration: ((k.t - (C ? F[C - 1].t : 0)) / 100) * u,
                }),
                (j[L] = k.v),
                E.to(A, j, I),
                (I += j.duration);
          E.duration() < u && E.to({}, { duration: u - E.duration() });
        }
      }
      u || a.duration((u = E.duration()));
    } else a.timeline = 0;
    return (
      m === !0 && !X1 && ((qo = no(a)), rn.killTweensOf(A), (qo = 0)),
      Es(S, no(a), s),
      i.reversed && a.reverse(),
      i.paused && a.paused(!0),
      (d ||
        (!u &&
          !_ &&
          a._start === $n(S._time) &&
          Vr(d) &&
          pW(no(a)) &&
          S.data !== "nested")) &&
        ((a._tTime = -Gt), a.render(Math.max(0, -h) || 0)),
      x && MI(no(a), x),
      a
    );
  }
  var t = e.prototype;
  return (
    (t.render = function (i, s, o) {
      var a = this._time,
        l = this._tDur,
        u = this._dur,
        h = i < 0,
        d = i > l - Gt && !h ? l : i < Gt ? 0 : i,
        p,
        m,
        _,
        y,
        x,
        g,
        S,
        A,
        E;
      if (!u) gW(this, i, s, o);
      else if (
        d !== this._tTime ||
        !i ||
        o ||
        (!this._initted && this._tTime) ||
        (this._startAt && this._zTime < 0 !== h)
      ) {
        if (((p = d), (A = this.timeline), this._repeat)) {
          if (((y = u + this._rDelay), this._repeat < -1 && h))
            return this.totalTime(y * 100 + i, s, o);
          if (
            ((p = $n(d % y)),
            d === l
              ? ((_ = this._repeat), (p = u))
              : ((_ = ~~(d / y)),
                _ && _ === d / y && ((p = u), _--),
                p > u && (p = u)),
            (g = this._yoyo && _ & 1),
            g && ((E = this._yEase), (p = u - p)),
            (x = Lc(this._tTime, y)),
            p === a && !o && this._initted)
          )
            return (this._tTime = d), this;
          _ !== x &&
            (A && this._yEase && UI(A, g),
            this.vars.repeatRefresh &&
              !g &&
              !this._lock &&
              ((this._lock = o = 1),
              (this.render($n(y * _), !0).invalidate()._lock = 0)));
        }
        if (!this._initted) {
          if (EI(this, h ? i : p, o, s, d)) return (this._tTime = 0), this;
          if (a !== this._time) return this;
          if (u !== this._dur) return this.render(i, s, o);
        }
        if (
          ((this._tTime = d),
          (this._time = p),
          !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
          (this.ratio = S = (E || this._ease)(p / u)),
          this._from && (this.ratio = S = 1 - S),
          p && !a && !s && !_ && (Ni(this, "onStart"), this._tTime !== d))
        )
          return this;
        for (m = this._pt; m; ) m.r(S, m.d), (m = m._next);
        (A &&
          A.render(
            i < 0 ? i : !p && g ? -Gt : A._dur * A._ease(p / this._dur),
            s,
            o
          )) ||
          (this._startAt && (this._zTime = i)),
          this._onUpdate &&
            !s &&
            (h && DS(this, i, s, o), Ni(this, "onUpdate")),
          this._repeat &&
            _ !== x &&
            this.vars.onRepeat &&
            !s &&
            this.parent &&
            Ni(this, "onRepeat"),
          (d === this._tDur || !d) &&
            this._tTime === d &&
            (h && !this._onUpdate && DS(this, i, !0, !0),
            (i || !u) &&
              ((d === this._tDur && this._ts > 0) || (!d && this._ts < 0)) &&
              Ma(this, 1),
            !s &&
              !(h && !a) &&
              (d || a || g) &&
              (Ni(this, d === l ? "onComplete" : "onReverseComplete", !0),
              this._prom && !(d < l && this.timeScale() > 0) && this._prom()));
      }
      return this;
    }),
    (t.targets = function () {
      return this._targets;
    }),
    (t.invalidate = function (i) {
      return (
        (!i || !this.vars.runBackwards) && (this._startAt = 0),
        (this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
        (this._ptLookup = []),
        this.timeline && this.timeline.invalidate(i),
        n.prototype.invalidate.call(this, i)
      );
    }),
    (t.resetTo = function (i, s, o, a) {
      jh || si.wake(), this._ts || this.play();
      var l = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        u;
      return (
        this._initted || tM(this, l),
        (u = this._ease(l / this._dur)),
        FW(this, i, s, o, a, u, l)
          ? this.resetTo(i, s, o, a)
          : (K0(this, 0),
            this.parent ||
              SI(
                this._dp,
                this,
                "_first",
                "_last",
                this._dp._sort ? "_start" : 0
              ),
            this.render(0))
      );
    }),
    (t.kill = function (i, s) {
      if ((s === void 0 && (s = "all"), !i && (!s || s === "all")))
        return (this._lazy = this._pt = 0), this.parent ? jf(this) : this;
      if (this.timeline) {
        var o = this.timeline.totalDuration();
        return (
          this.timeline.killTweensOf(i, s, qo && qo.vars.overwrite !== !0)
            ._first || jf(this),
          this.parent &&
            o !== this.timeline.totalDuration() &&
            Ic(this, (this._dur * this.timeline._tDur) / o, 0, 1),
          this
        );
      }
      var a = this._targets,
        l = i ? Fi(i) : a,
        u = this._ptLookup,
        h = this._pt,
        d,
        p,
        m,
        _,
        y,
        x,
        g;
      if ((!s || s === "all") && hW(a, l))
        return s === "all" && (this._pt = 0), jf(this);
      for (
        d = this._op = this._op || [],
          s !== "all" &&
            (Yn(s) &&
              ((y = {}),
              Wr(s, function (S) {
                return (y[S] = 1);
              }),
              (s = y)),
            (s = NW(a, s))),
          g = a.length;
        g--;

      )
        if (~l.indexOf(a[g])) {
          (p = u[g]),
            s === "all"
              ? ((d[g] = s), (_ = p), (m = {}))
              : ((m = d[g] = d[g] || {}), (_ = s));
          for (y in _)
            (x = p && p[y]),
              x &&
                ((!("kill" in x.d) || x.d.kill(y) === !0) && X0(this, x, "_pt"),
                delete p[y]),
              m !== "all" && (m[y] = 1);
        }
      return this._initted && !this._pt && h && jf(this), this;
    }),
    (e.to = function (i, s) {
      return new e(i, s, arguments[2]);
    }),
    (e.from = function (i, s) {
      return lh(1, arguments);
    }),
    (e.delayedCall = function (i, s, o, a) {
      return new e(s, 0, {
        immediateRender: !1,
        lazy: !1,
        overwrite: !1,
        delay: i,
        onComplete: s,
        onReverseComplete: s,
        onCompleteParams: o,
        onReverseCompleteParams: o,
        callbackScope: a,
      });
    }),
    (e.fromTo = function (i, s, o) {
      return lh(2, arguments);
    }),
    (e.set = function (i, s) {
      return (s.duration = 0), s.repeatDelay || (s.repeat = 0), new e(i, s);
    }),
    (e.killTweensOf = function (i, s, o) {
      return rn.killTweensOf(i, s, o);
    }),
    e
  );
})(Xh);
Hi(Pn.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
Wr("staggerTo,staggerFrom,staggerFromTo", function (n) {
  Pn[n] = function () {
    var e = new Or(),
      t = NS.call(arguments, 0);
    return t.splice(n === "staggerFromTo" ? 5 : 4, 0, 0), e[n].apply(e, t);
  };
});
var nM = function (e, t, r) {
    return (e[t] = r);
  },
  WI = function (e, t, r) {
    return e[t](r);
  },
  UW = function (e, t, r, i) {
    return e[t](i.fp, r);
  },
  kW = function (e, t, r) {
    return e.setAttribute(t, r);
  },
  rM = function (e, t) {
    return vn(e[t]) ? WI : J1(e[t]) && e.setAttribute ? kW : nM;
  },
  jI = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
  },
  zW = function (e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t);
  },
  XI = function (e, t) {
    var r = t._pt,
      i = "";
    if (!e && t.b) i = t.b;
    else if (e === 1 && t.e) i = t.e;
    else {
      for (; r; )
        (i =
          r.p +
          (r.m ? r.m(r.s + r.c * e) : Math.round((r.s + r.c * e) * 1e4) / 1e4) +
          i),
          (r = r._next);
      i += t.c;
    }
    t.set(t.t, t.p, i, t);
  },
  iM = function (e, t) {
    for (var r = t._pt; r; ) r.r(e, r.d), (r = r._next);
  },
  HW = function (e, t, r, i) {
    for (var s = this._pt, o; s; )
      (o = s._next), s.p === i && s.modifier(e, t, r), (s = o);
  },
  GW = function (e) {
    for (var t = this._pt, r, i; t; )
      (i = t._next),
        (t.p === e && !t.op) || t.op === e
          ? X0(this, t, "_pt")
          : t.dep || (r = 1),
        (t = i);
    return !r;
  },
  VW = function (e, t, r, i) {
    i.mSet(e, t, i.m.call(i.tween, r, i.mt), i);
  },
  JI = function (e) {
    for (var t = e._pt, r, i, s, o; t; ) {
      for (r = t._next, i = s; i && i.pr > t.pr; ) i = i._next;
      (t._prev = i ? i._prev : o) ? (t._prev._next = t) : (s = t),
        (t._next = i) ? (i._prev = t) : (o = t),
        (t = r);
    }
    e._pt = s;
  },
  jr = (function () {
    function n(t, r, i, s, o, a, l, u, h) {
      (this.t = r),
        (this.s = s),
        (this.c = o),
        (this.p = i),
        (this.r = a || jI),
        (this.d = l || this),
        (this.set = u || nM),
        (this.pr = h || 0),
        (this._next = t),
        t && (t._prev = this);
    }
    var e = n.prototype;
    return (
      (e.modifier = function (r, i, s) {
        (this.mSet = this.mSet || this.set),
          (this.set = VW),
          (this.m = r),
          (this.mt = s),
          (this.tween = i);
      }),
      n
    );
  })();
Wr(
  Z1 +
    "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
  function (n) {
    return (q1[n] = 1);
  }
);
di.TweenMax = di.TweenLite = Pn;
di.TimelineLite = di.TimelineMax = Or;
rn = new Or({
  sortChildren: !1,
  defaults: Bc,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0,
});
ci.stringFilter = NI;
var Cl = [],
  $m = {},
  WW = [],
  _b = 0,
  jW = 0,
  Iy = function (e) {
    return ($m[e] || WW).map(function (t) {
      return t();
    });
  },
  zS = function () {
    var e = Date.now(),
      t = [];
    e - _b > 2 &&
      (Iy("matchMediaInit"),
      Cl.forEach(function (r) {
        var i = r.queries,
          s = r.conditions,
          o,
          a,
          l,
          u;
        for (a in i)
          (o = bi.matchMedia(i[a]).matches),
            o && (l = 1),
            o !== s[a] && ((s[a] = o), (u = 1));
        u && (r.revert(), l && t.push(r));
      }),
      Iy("matchMediaRevert"),
      t.forEach(function (r) {
        return r.onMatch(r);
      }),
      (_b = e),
      Iy("matchMedia"));
  },
  KI = (function () {
    function n(t, r) {
      (this.selector = r && OS(r)),
        (this.data = []),
        (this._r = []),
        (this.isReverted = !1),
        (this.id = jW++),
        t && this.add(t);
    }
    var e = n.prototype;
    return (
      (e.add = function (r, i, s) {
        vn(r) && ((s = i), (i = r), (r = vn));
        var o = this,
          a = function () {
            var u = _n,
              h = o.selector,
              d;
            return (
              u && u !== o && u.data.push(o),
              s && (o.selector = OS(s)),
              (_n = o),
              (d = i.apply(o, arguments)),
              vn(d) && o._r.push(d),
              (_n = u),
              (o.selector = h),
              (o.isReverted = !1),
              d
            );
          };
        return (o.last = a), r === vn ? a(o) : r ? (o[r] = a) : a;
      }),
      (e.ignore = function (r) {
        var i = _n;
        (_n = null), r(this), (_n = i);
      }),
      (e.getTweens = function () {
        var r = [];
        return (
          this.data.forEach(function (i) {
            return i instanceof n
              ? r.push.apply(r, i.getTweens())
              : i instanceof Pn &&
                  !(i.parent && i.parent.data === "nested") &&
                  r.push(i);
          }),
          r
        );
      }),
      (e.clear = function () {
        this._r.length = this.data.length = 0;
      }),
      (e.kill = function (r, i) {
        var s = this;
        if (r) {
          var o = this.getTweens();
          this.data.forEach(function (l) {
            l.data === "isFlip" &&
              (l.revert(),
              l.getChildren(!0, !0, !1).forEach(function (u) {
                return o.splice(o.indexOf(u), 1);
              }));
          }),
            o
              .map(function (l) {
                return { g: l.globalTime(0), t: l };
              })
              .sort(function (l, u) {
                return u.g - l.g || -1 / 0;
              })
              .forEach(function (l) {
                return l.t.revert(r);
              }),
            this.data.forEach(function (l) {
              return !(l instanceof Pn) && l.revert && l.revert(r);
            }),
            this._r.forEach(function (l) {
              return l(r, s);
            }),
            (this.isReverted = !0);
        } else
          this.data.forEach(function (l) {
            return l.kill && l.kill();
          });
        if ((this.clear(), i))
          for (var a = Cl.length; a--; )
            Cl[a].id === this.id && Cl.splice(a, 1);
      }),
      (e.revert = function (r) {
        this.kill(r || {});
      }),
      n
    );
  })(),
  XW = (function () {
    function n(t) {
      (this.contexts = []), (this.scope = t);
    }
    var e = n.prototype;
    return (
      (e.add = function (r, i, s) {
        Us(r) || (r = { matches: r });
        var o = new KI(0, s || this.scope),
          a = (o.conditions = {}),
          l,
          u,
          h;
        _n && !o.selector && (o.selector = _n.selector),
          this.contexts.push(o),
          (i = o.add("onMatch", i)),
          (o.queries = r);
        for (u in r)
          u === "all"
            ? (h = 1)
            : ((l = bi.matchMedia(r[u])),
              l &&
                (Cl.indexOf(o) < 0 && Cl.push(o),
                (a[u] = l.matches) && (h = 1),
                l.addListener
                  ? l.addListener(zS)
                  : l.addEventListener("change", zS)));
        return h && i(o), this;
      }),
      (e.revert = function (r) {
        this.kill(r || {});
      }),
      (e.kill = function (r) {
        this.contexts.forEach(function (i) {
          return i.kill(r, !0);
        });
      }),
      n
    );
  })(),
  zg = {
    registerPlugin: function () {
      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
        t[r] = arguments[r];
      t.forEach(function (i) {
        return II(i);
      });
    },
    timeline: function (e) {
      return new Or(e);
    },
    getTweensOf: function (e, t) {
      return rn.getTweensOf(e, t);
    },
    getProperty: function (e, t, r, i) {
      Yn(e) && (e = Fi(e)[0]);
      var s = Ml(e || {}).get,
        o = r ? xI : yI;
      return (
        r === "native" && (r = ""),
        e &&
          (t
            ? o(((ii[t] && ii[t].get) || s)(e, t, r, i))
            : function (a, l, u) {
                return o(((ii[a] && ii[a].get) || s)(e, a, l, u));
              })
      );
    },
    quickSetter: function (e, t, r) {
      if (((e = Fi(e)), e.length > 1)) {
        var i = e.map(function (h) {
            return Xr.quickSetter(h, t, r);
          }),
          s = i.length;
        return function (h) {
          for (var d = s; d--; ) i[d](h);
        };
      }
      e = e[0] || {};
      var o = ii[t],
        a = Ml(e),
        l = (a.harness && (a.harness.aliases || {})[t]) || t,
        u = o
          ? function (h) {
              var d = new o();
              (Zu._pt = 0),
                d.init(e, r ? h + r : h, Zu, 0, [e]),
                d.render(1, d),
                Zu._pt && iM(1, Zu);
            }
          : a.set(e, l);
      return o
        ? u
        : function (h) {
            return u(e, l, r ? h + r : h, a, 1);
          };
    },
    quickTo: function (e, t, r) {
      var i,
        s = Xr.to(
          e,
          Nl(((i = {}), (i[t] = "+=0.1"), (i.paused = !0), i), r || {})
        ),
        o = function (l, u, h) {
          return s.resetTo(t, l, u, h);
        };
      return (o.tween = s), o;
    },
    isTweening: function (e) {
      return rn.getTweensOf(e, !0).length > 0;
    },
    defaults: function (e) {
      return e && e.ease && (e.ease = wl(e.ease, Bc.ease)), hb(Bc, e || {});
    },
    config: function (e) {
      return hb(ci, e || {});
    },
    registerEffect: function (e) {
      var t = e.name,
        r = e.effect,
        i = e.plugins,
        s = e.defaults,
        o = e.extendTimeline;
      (i || "").split(",").forEach(function (a) {
        return (
          a && !ii[a] && !di[a] && Ng(t + " effect requires " + a + " plugin.")
        );
      }),
        (Ry[t] = function (a, l, u) {
          return r(Fi(a), Hi(l || {}, s), u);
        }),
        o &&
          (Or.prototype[t] = function (a, l, u) {
            return this.add(Ry[t](a, Us(l) ? l : (u = l) && {}, this), u);
          });
    },
    registerEase: function (e, t) {
      Ct[e] = wl(t);
    },
    parseEase: function (e, t) {
      return arguments.length ? wl(e, t) : Ct;
    },
    getById: function (e) {
      return rn.getById(e);
    },
    exportRoot: function (e, t) {
      e === void 0 && (e = {});
      var r = new Or(e),
        i,
        s;
      for (
        r.smoothChildTiming = Vr(e.smoothChildTiming),
          rn.remove(r),
          r._dp = 0,
          r._time = r._tTime = rn._time,
          i = rn._first;
        i;

      )
        (s = i._next),
          (t ||
            !(
              !i._dur &&
              i instanceof Pn &&
              i.vars.onComplete === i._targets[0]
            )) &&
            Es(r, i, i._start - i._delay),
          (i = s);
      return Es(rn, r, 0), r;
    },
    context: function (e, t) {
      return e ? new KI(e, t) : _n;
    },
    matchMedia: function (e) {
      return new XW(e);
    },
    matchMediaRefresh: function () {
      return (
        Cl.forEach(function (e) {
          var t = e.conditions,
            r,
            i;
          for (i in t) t[i] && ((t[i] = !1), (r = 1));
          r && e.revert();
        }) || zS()
      );
    },
    addEventListener: function (e, t) {
      var r = $m[e] || ($m[e] = []);
      ~r.indexOf(t) || r.push(t);
    },
    removeEventListener: function (e, t) {
      var r = $m[e],
        i = r && r.indexOf(t);
      i >= 0 && r.splice(i, 1);
    },
    utils: {
      wrap: EW,
      wrapYoyo: wW,
      distribute: TI,
      random: RI,
      snap: bI,
      normalize: MW,
      getUnit: pr,
      clamp: yW,
      splitColor: DI,
      toArray: Fi,
      selector: OS,
      mapRange: BI,
      pipe: SW,
      unitize: AW,
      interpolate: CW,
      shuffle: CI,
    },
    install: pI,
    effects: Ry,
    ticker: si,
    updateRoot: Or.updateRoot,
    plugins: ii,
    globalTimeline: rn,
    core: {
      PropTween: jr,
      globals: mI,
      Tween: Pn,
      Timeline: Or,
      Animation: Xh,
      getCache: Ml,
      _removeLinkedListItem: X0,
      reverting: function () {
        return gr;
      },
      context: function (e) {
        return e && _n && (_n.data.push(e), (e._ctx = _n)), _n;
      },
      suppressOverwrites: function (e) {
        return (X1 = e);
      },
    },
  };
Wr("to,from,fromTo,delayedCall,set,killTweensOf", function (n) {
  return (zg[n] = Pn[n]);
});
si.add(Or.updateRoot);
Zu = zg.to({}, { duration: 0 });
var JW = function (e, t) {
    for (var r = e._pt; r && r.p !== t && r.op !== t && r.fp !== t; )
      r = r._next;
    return r;
  },
  KW = function (e, t) {
    var r = e._targets,
      i,
      s,
      o;
    for (i in t)
      for (s = r.length; s--; )
        (o = e._ptLookup[s][i]),
          o &&
            (o = o.d) &&
            (o._pt && (o = JW(o, i)),
            o && o.modifier && o.modifier(t[i], e, r[s], i));
  },
  Dy = function (e, t) {
    return {
      name: e,
      rawVars: 1,
      init: function (i, s, o) {
        o._onInit = function (a) {
          var l, u;
          if (
            (Yn(s) &&
              ((l = {}),
              Wr(s, function (h) {
                return (l[h] = 1);
              }),
              (s = l)),
            t)
          ) {
            l = {};
            for (u in s) l[u] = t(s[u]);
            s = l;
          }
          KW(a, s);
        };
      },
    };
  },
  Xr =
    zg.registerPlugin(
      {
        name: "attr",
        init: function (e, t, r, i, s) {
          var o, a, l;
          this.tween = r;
          for (o in t)
            (l = e.getAttribute(o) || ""),
              (a = this.add(
                e,
                "setAttribute",
                (l || 0) + "",
                t[o],
                i,
                s,
                0,
                0,
                o
              )),
              (a.op = o),
              (a.b = l),
              this._props.push(o);
        },
        render: function (e, t) {
          for (var r = t._pt; r; )
            gr ? r.set(r.t, r.p, r.b, r) : r.r(e, r.d), (r = r._next);
        },
      },
      {
        name: "endArray",
        init: function (e, t) {
          for (var r = t.length; r--; )
            this.add(e, r, e[r] || 0, t[r], 0, 0, 0, 0, 0, 1);
        },
      },
      Dy("roundProps", US),
      Dy("modifiers"),
      Dy("snap", bI)
    ) || zg;
Pn.version = Or.version = Xr.version = "3.12.2";
dI = 1;
K1() && Dc();
Ct.Power0;
Ct.Power1;
Ct.Power2;
Ct.Power3;
Ct.Power4;
Ct.Linear;
Ct.Quad;
Ct.Cubic;
Ct.Quart;
Ct.Quint;
Ct.Strong;
Ct.Elastic;
Ct.Back;
Ct.SteppedEase;
Ct.Bounce;
Ct.Sine;
Ct.Expo;
Ct.Circ;
/*!
 * CSSPlugin 3.12.2
 * https://greensock.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var vb,
  Zo,
  cc,
  sM,
  gl,
  yb,
  oM,
  YW = function () {
    return typeof window < "u";
  },
  xo = {},
  il = 180 / Math.PI,
  fc = Math.PI / 180,
  Bu = Math.atan2,
  xb = 1e8,
  aM = /([A-Z])/g,
  QW = /(left|right|width|margin|padding|x)/i,
  qW = /[\s,\(]\S/,
  bs = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity",
  },
  HS = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
  },
  ZW = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u,
      t
    );
  },
  $W = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b,
      t
    );
  },
  ej = function (e, t) {
    var r = t.s + t.c * e;
    t.set(t.t, t.p, ~~(r + (r < 0 ? -0.5 : 0.5)) + t.u, t);
  },
  YI = function (e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t);
  },
  QI = function (e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
  },
  tj = function (e, t, r) {
    return (e.style[t] = r);
  },
  nj = function (e, t, r) {
    return e.style.setProperty(t, r);
  },
  rj = function (e, t, r) {
    return (e._gsap[t] = r);
  },
  ij = function (e, t, r) {
    return (e._gsap.scaleX = e._gsap.scaleY = r);
  },
  sj = function (e, t, r, i, s) {
    var o = e._gsap;
    (o.scaleX = o.scaleY = r), o.renderTransform(s, o);
  },
  oj = function (e, t, r, i, s) {
    var o = e._gsap;
    (o[t] = r), o.renderTransform(s, o);
  },
  an = "transform",
  ss = an + "Origin",
  aj = function n(e, t) {
    var r = this,
      i = this.target,
      s = i.style;
    if (e in xo && s) {
      if (((this.tfm = this.tfm || {}), e !== "transform"))
        (e = bs[e] || e),
          ~e.indexOf(",")
            ? e.split(",").forEach(function (o) {
                return (r.tfm[o] = io(i, o));
              })
            : (this.tfm[e] = i._gsap.x ? i._gsap[e] : io(i, e));
      else
        return bs.transform.split(",").forEach(function (o) {
          return n.call(r, o, t);
        });
      if (this.props.indexOf(an) >= 0) return;
      i._gsap.svg &&
        ((this.svgo = i.getAttribute("data-svg-origin")),
        this.props.push(ss, t, "")),
        (e = an);
    }
    (s || t) && this.props.push(e, t, s[e]);
  },
  qI = function (e) {
    e.translate &&
      (e.removeProperty("translate"),
      e.removeProperty("scale"),
      e.removeProperty("rotate"));
  },
  lj = function () {
    var e = this.props,
      t = this.target,
      r = t.style,
      i = t._gsap,
      s,
      o;
    for (s = 0; s < e.length; s += 3)
      e[s + 1]
        ? (t[e[s]] = e[s + 2])
        : e[s + 2]
        ? (r[e[s]] = e[s + 2])
        : r.removeProperty(
            e[s].substr(0, 2) === "--"
              ? e[s]
              : e[s].replace(aM, "-$1").toLowerCase()
          );
    if (this.tfm) {
      for (o in this.tfm) i[o] = this.tfm[o];
      i.svg &&
        (i.renderTransform(),
        t.setAttribute("data-svg-origin", this.svgo || "")),
        (s = oM()),
        (!s || !s.isStart) && !r[an] && (qI(r), (i.uncache = 1));
    }
  },
  ZI = function (e, t) {
    var r = { target: e, props: [], revert: lj, save: aj };
    return (
      e._gsap || Xr.core.getCache(e),
      t &&
        t.split(",").forEach(function (i) {
          return r.save(i);
        }),
      r
    );
  },
  $I,
  GS = function (e, t) {
    var r = Zo.createElementNS
      ? Zo.createElementNS(
          (t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
          e
        )
      : Zo.createElement(e);
    return r.style ? r : Zo.createElement(e);
  },
  Ds = function n(e, t, r) {
    var i = getComputedStyle(e);
    return (
      i[t] ||
      i.getPropertyValue(t.replace(aM, "-$1").toLowerCase()) ||
      i.getPropertyValue(t) ||
      (!r && n(e, Fc(t) || t, 1)) ||
      ""
    );
  },
  Sb = "O,Moz,ms,Ms,Webkit".split(","),
  Fc = function (e, t, r) {
    var i = t || gl,
      s = i.style,
      o = 5;
    if (e in s && !r) return e;
    for (
      e = e.charAt(0).toUpperCase() + e.substr(1);
      o-- && !(Sb[o] + e in s);

    );
    return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? Sb[o] : "") + e;
  },
  VS = function () {
    YW() &&
      window.document &&
      ((vb = window),
      (Zo = vb.document),
      (cc = Zo.documentElement),
      (gl = GS("div") || { style: {} }),
      GS("div"),
      (an = Fc(an)),
      (ss = an + "Origin"),
      (gl.style.cssText =
        "border-width:0;line-height:0;position:absolute;padding:0"),
      ($I = !!Fc("perspective")),
      (oM = Xr.core.reverting),
      (sM = 1));
  },
  Fy = function n(e) {
    var t = GS(
        "svg",
        (this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns")) ||
          "http://www.w3.org/2000/svg"
      ),
      r = this.parentNode,
      i = this.nextSibling,
      s = this.style.cssText,
      o;
    if (
      (cc.appendChild(t),
      t.appendChild(this),
      (this.style.display = "block"),
      e)
    )
      try {
        (o = this.getBBox()),
          (this._gsapBBox = this.getBBox),
          (this.getBBox = n);
      } catch {}
    else this._gsapBBox && (o = this._gsapBBox());
    return (
      r && (i ? r.insertBefore(this, i) : r.appendChild(this)),
      cc.removeChild(t),
      (this.style.cssText = s),
      o
    );
  },
  Ab = function (e, t) {
    for (var r = t.length; r--; )
      if (e.hasAttribute(t[r])) return e.getAttribute(t[r]);
  },
  eD = function (e) {
    var t;
    try {
      t = e.getBBox();
    } catch {
      t = Fy.call(e, !0);
    }
    return (
      (t && (t.width || t.height)) || e.getBBox === Fy || (t = Fy.call(e, !0)),
      t && !t.width && !t.x && !t.y
        ? {
            x: +Ab(e, ["x", "cx", "x1"]) || 0,
            y: +Ab(e, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0,
          }
        : t
    );
  },
  tD = function (e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && eD(e));
  },
  Jh = function (e, t) {
    if (t) {
      var r = e.style;
      t in xo && t !== ss && (t = an),
        r.removeProperty
          ? ((t.substr(0, 2) === "ms" || t.substr(0, 6) === "webkit") &&
              (t = "-" + t),
            r.removeProperty(t.replace(aM, "-$1").toLowerCase()))
          : r.removeAttribute(t);
    }
  },
  $o = function (e, t, r, i, s, o) {
    var a = new jr(e._pt, t, r, 0, 1, o ? QI : YI);
    return (e._pt = a), (a.b = i), (a.e = s), e._props.push(r), a;
  },
  Mb = { deg: 1, rad: 1, turn: 1 },
  uj = { grid: 1, flex: 1 },
  Ea = function n(e, t, r, i) {
    var s = parseFloat(r) || 0,
      o = (r + "").trim().substr((s + "").length) || "px",
      a = gl.style,
      l = QW.test(t),
      u = e.tagName.toLowerCase() === "svg",
      h = (u ? "client" : "offset") + (l ? "Width" : "Height"),
      d = 100,
      p = i === "px",
      m = i === "%",
      _,
      y,
      x,
      g;
    return i === o || !s || Mb[i] || Mb[o]
      ? s
      : (o !== "px" && !p && (s = n(e, t, r, "px")),
        (g = e.getCTM && tD(e)),
        (m || o === "%") && (xo[t] || ~t.indexOf("adius"))
          ? ((_ = g ? e.getBBox()[l ? "width" : "height"] : e[h]),
            Sn(m ? (s / _) * d : (s / 100) * _))
          : ((a[l ? "width" : "height"] = d + (p ? o : i)),
            (y =
              ~t.indexOf("adius") || (i === "em" && e.appendChild && !u)
                ? e
                : e.parentNode),
            g && (y = (e.ownerSVGElement || {}).parentNode),
            (!y || y === Zo || !y.appendChild) && (y = Zo.body),
            (x = y._gsap),
            x && m && x.width && l && x.time === si.time && !x.uncache
              ? Sn((s / x.width) * d)
              : ((m || o === "%") &&
                  !uj[Ds(y, "display")] &&
                  (a.position = Ds(e, "position")),
                y === e && (a.position = "static"),
                y.appendChild(gl),
                (_ = gl[h]),
                y.removeChild(gl),
                (a.position = "absolute"),
                l && m && ((x = Ml(y)), (x.time = si.time), (x.width = y[h])),
                Sn(p ? (_ * s) / d : _ && s ? (d / _) * s : 0))));
  },
  io = function (e, t, r, i) {
    var s;
    return (
      sM || VS(),
      t in bs &&
        t !== "transform" &&
        ((t = bs[t]), ~t.indexOf(",") && (t = t.split(",")[0])),
      xo[t] && t !== "transform"
        ? ((s = Yh(e, i)),
          (s =
            t !== "transformOrigin"
              ? s[t]
              : s.svg
              ? s.origin
              : Gg(Ds(e, ss)) + " " + s.zOrigin + "px"))
        : ((s = e.style[t]),
          (!s || s === "auto" || i || ~(s + "").indexOf("calc(")) &&
            (s =
              (Hg[t] && Hg[t](e, t, r)) ||
              Ds(e, t) ||
              _I(e, t) ||
              (t === "opacity" ? 1 : 0))),
      r && !~(s + "").trim().indexOf(" ") ? Ea(e, t, s, r) + r : s
    );
  },
  cj = function (e, t, r, i) {
    if (!r || r === "none") {
      var s = Fc(t, e, 1),
        o = s && Ds(e, s, 1);
      o && o !== r
        ? ((t = s), (r = o))
        : t === "borderColor" && (r = Ds(e, "borderTopColor"));
    }
    var a = new jr(this._pt, e.style, t, 0, 1, XI),
      l = 0,
      u = 0,
      h,
      d,
      p,
      m,
      _,
      y,
      x,
      g,
      S,
      A,
      E,
      C;
    if (
      ((a.b = r),
      (a.e = i),
      (r += ""),
      (i += ""),
      i === "auto" && ((e.style[t] = i), (i = Ds(e, t) || i), (e.style[t] = r)),
      (h = [r, i]),
      NI(h),
      (r = h[0]),
      (i = h[1]),
      (p = r.match(qu) || []),
      (C = i.match(qu) || []),
      C.length)
    ) {
      for (; (d = qu.exec(i)); )
        (x = d[0]),
          (S = i.substring(l, d.index)),
          _
            ? (_ = (_ + 1) % 5)
            : (S.substr(-5) === "rgba(" || S.substr(-5) === "hsla(") && (_ = 1),
          x !== (y = p[u++] || "") &&
            ((m = parseFloat(y) || 0),
            (E = y.substr((m + "").length)),
            x.charAt(1) === "=" && (x = uc(m, x) + E),
            (g = parseFloat(x)),
            (A = x.substr((g + "").length)),
            (l = qu.lastIndex - A.length),
            A ||
              ((A = A || ci.units[t] || E),
              l === i.length && ((i += A), (a.e += A))),
            E !== A && (m = Ea(e, t, y, A) || 0),
            (a._pt = {
              _next: a._pt,
              p: S || u === 1 ? S : ",",
              s: m,
              c: g - m,
              m: (_ && _ < 4) || t === "zIndex" ? Math.round : 0,
            }));
      a.c = l < i.length ? i.substring(l, i.length) : "";
    } else a.r = t === "display" && i === "none" ? QI : YI;
    return fI.test(i) && (a.e = 0), (this._pt = a), a;
  },
  Eb = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" },
  fj = function (e) {
    var t = e.split(" "),
      r = t[0],
      i = t[1] || "50%";
    return (
      (r === "top" || r === "bottom" || i === "left" || i === "right") &&
        ((e = r), (r = i), (i = e)),
      (t[0] = Eb[r] || r),
      (t[1] = Eb[i] || i),
      t.join(" ")
    );
  },
  hj = function (e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
      var r = t.t,
        i = r.style,
        s = t.u,
        o = r._gsap,
        a,
        l,
        u;
      if (s === "all" || s === !0) (i.cssText = ""), (l = 1);
      else
        for (s = s.split(","), u = s.length; --u > -1; )
          (a = s[u]),
            xo[a] && ((l = 1), (a = a === "transformOrigin" ? ss : an)),
            Jh(r, a);
      l &&
        (Jh(r, an),
        o &&
          (o.svg && r.removeAttribute("transform"),
          Yh(r, 1),
          (o.uncache = 1),
          qI(i)));
    }
  },
  Hg = {
    clearProps: function (e, t, r, i, s) {
      if (s.data !== "isFromStart") {
        var o = (e._pt = new jr(e._pt, t, r, 0, 0, hj));
        return (o.u = i), (o.pr = -10), (o.tween = s), e._props.push(r), 1;
      }
    },
  },
  Kh = [1, 0, 0, 1, 0, 0],
  nD = {},
  rD = function (e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
  },
  wb = function (e) {
    var t = Ds(e, an);
    return rD(t) ? Kh : t.substr(7).match(cI).map(Sn);
  },
  lM = function (e, t) {
    var r = e._gsap || Ml(e),
      i = e.style,
      s = wb(e),
      o,
      a,
      l,
      u;
    return r.svg && e.getAttribute("transform")
      ? ((l = e.transform.baseVal.consolidate().matrix),
        (s = [l.a, l.b, l.c, l.d, l.e, l.f]),
        s.join(",") === "1,0,0,1,0,0" ? Kh : s)
      : (s === Kh &&
          !e.offsetParent &&
          e !== cc &&
          !r.svg &&
          ((l = i.display),
          (i.display = "block"),
          (o = e.parentNode),
          (!o || !e.offsetParent) &&
            ((u = 1), (a = e.nextElementSibling), cc.appendChild(e)),
          (s = wb(e)),
          l ? (i.display = l) : Jh(e, "display"),
          u &&
            (a
              ? o.insertBefore(e, a)
              : o
              ? o.appendChild(e)
              : cc.removeChild(e))),
        t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s);
  },
  WS = function (e, t, r, i, s, o) {
    var a = e._gsap,
      l = s || lM(e, !0),
      u = a.xOrigin || 0,
      h = a.yOrigin || 0,
      d = a.xOffset || 0,
      p = a.yOffset || 0,
      m = l[0],
      _ = l[1],
      y = l[2],
      x = l[3],
      g = l[4],
      S = l[5],
      A = t.split(" "),
      E = parseFloat(A[0]) || 0,
      C = parseFloat(A[1]) || 0,
      R,
      P,
      L,
      T;
    r
      ? l !== Kh &&
        (P = m * x - _ * y) &&
        ((L = E * (x / P) + C * (-y / P) + (y * S - x * g) / P),
        (T = E * (-_ / P) + C * (m / P) - (m * S - _ * g) / P),
        (E = L),
        (C = T))
      : ((R = eD(e)),
        (E = R.x + (~A[0].indexOf("%") ? (E / 100) * R.width : E)),
        (C = R.y + (~(A[1] || A[0]).indexOf("%") ? (C / 100) * R.height : C))),
      i || (i !== !1 && a.smooth)
        ? ((g = E - u),
          (S = C - h),
          (a.xOffset = d + (g * m + S * y) - g),
          (a.yOffset = p + (g * _ + S * x) - S))
        : (a.xOffset = a.yOffset = 0),
      (a.xOrigin = E),
      (a.yOrigin = C),
      (a.smooth = !!i),
      (a.origin = t),
      (a.originIsAbsolute = !!r),
      (e.style[ss] = "0px 0px"),
      o &&
        ($o(o, a, "xOrigin", u, E),
        $o(o, a, "yOrigin", h, C),
        $o(o, a, "xOffset", d, a.xOffset),
        $o(o, a, "yOffset", p, a.yOffset)),
      e.setAttribute("data-svg-origin", E + " " + C);
  },
  Yh = function (e, t) {
    var r = e._gsap || new zI(e);
    if ("x" in r && !t && !r.uncache) return r;
    var i = e.style,
      s = r.scaleX < 0,
      o = "px",
      a = "deg",
      l = getComputedStyle(e),
      u = Ds(e, ss) || "0",
      h,
      d,
      p,
      m,
      _,
      y,
      x,
      g,
      S,
      A,
      E,
      C,
      R,
      P,
      L,
      T,
      B,
      D,
      I,
      F,
      k,
      j,
      Z,
      Q,
      N,
      W,
      G,
      X,
      Y,
      de,
      ae,
      ye;
    return (
      (h = d = p = y = x = g = S = A = E = 0),
      (m = _ = 1),
      (r.svg = !!(e.getCTM && tD(e))),
      l.translate &&
        ((l.translate !== "none" ||
          l.scale !== "none" ||
          l.rotate !== "none") &&
          (i[an] =
            (l.translate !== "none"
              ? "translate3d(" +
                (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") +
                ") "
              : "") +
            (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") +
            (l.scale !== "none"
              ? "scale(" + l.scale.split(" ").join(",") + ") "
              : "") +
            (l[an] !== "none" ? l[an] : "")),
        (i.scale = i.rotate = i.translate = "none")),
      (P = lM(e, r.svg)),
      r.svg &&
        (r.uncache
          ? ((N = e.getBBox()),
            (u = r.xOrigin - N.x + "px " + (r.yOrigin - N.y) + "px"),
            (Q = ""))
          : (Q = !t && e.getAttribute("data-svg-origin")),
        WS(e, Q || u, !!Q || r.originIsAbsolute, r.smooth !== !1, P)),
      (C = r.xOrigin || 0),
      (R = r.yOrigin || 0),
      P !== Kh &&
        ((D = P[0]),
        (I = P[1]),
        (F = P[2]),
        (k = P[3]),
        (h = j = P[4]),
        (d = Z = P[5]),
        P.length === 6
          ? ((m = Math.sqrt(D * D + I * I)),
            (_ = Math.sqrt(k * k + F * F)),
            (y = D || I ? Bu(I, D) * il : 0),
            (S = F || k ? Bu(F, k) * il + y : 0),
            S && (_ *= Math.abs(Math.cos(S * fc))),
            r.svg && ((h -= C - (C * D + R * F)), (d -= R - (C * I + R * k))))
          : ((ye = P[6]),
            (de = P[7]),
            (G = P[8]),
            (X = P[9]),
            (Y = P[10]),
            (ae = P[11]),
            (h = P[12]),
            (d = P[13]),
            (p = P[14]),
            (L = Bu(ye, Y)),
            (x = L * il),
            L &&
              ((T = Math.cos(-L)),
              (B = Math.sin(-L)),
              (Q = j * T + G * B),
              (N = Z * T + X * B),
              (W = ye * T + Y * B),
              (G = j * -B + G * T),
              (X = Z * -B + X * T),
              (Y = ye * -B + Y * T),
              (ae = de * -B + ae * T),
              (j = Q),
              (Z = N),
              (ye = W)),
            (L = Bu(-F, Y)),
            (g = L * il),
            L &&
              ((T = Math.cos(-L)),
              (B = Math.sin(-L)),
              (Q = D * T - G * B),
              (N = I * T - X * B),
              (W = F * T - Y * B),
              (ae = k * B + ae * T),
              (D = Q),
              (I = N),
              (F = W)),
            (L = Bu(I, D)),
            (y = L * il),
            L &&
              ((T = Math.cos(L)),
              (B = Math.sin(L)),
              (Q = D * T + I * B),
              (N = j * T + Z * B),
              (I = I * T - D * B),
              (Z = Z * T - j * B),
              (D = Q),
              (j = N)),
            x &&
              Math.abs(x) + Math.abs(y) > 359.9 &&
              ((x = y = 0), (g = 180 - g)),
            (m = Sn(Math.sqrt(D * D + I * I + F * F))),
            (_ = Sn(Math.sqrt(Z * Z + ye * ye))),
            (L = Bu(j, Z)),
            (S = Math.abs(L) > 2e-4 ? L * il : 0),
            (E = ae ? 1 / (ae < 0 ? -ae : ae) : 0)),
        r.svg &&
          ((Q = e.getAttribute("transform")),
          (r.forceCSS = e.setAttribute("transform", "") || !rD(Ds(e, an))),
          Q && e.setAttribute("transform", Q))),
      Math.abs(S) > 90 &&
        Math.abs(S) < 270 &&
        (s
          ? ((m *= -1), (S += y <= 0 ? 180 : -180), (y += y <= 0 ? 180 : -180))
          : ((_ *= -1), (S += S <= 0 ? 180 : -180))),
      (t = t || r.uncache),
      (r.x =
        h -
        ((r.xPercent =
          h &&
          ((!t && r.xPercent) ||
            (Math.round(e.offsetWidth / 2) === Math.round(-h) ? -50 : 0)))
          ? (e.offsetWidth * r.xPercent) / 100
          : 0) +
        o),
      (r.y =
        d -
        ((r.yPercent =
          d &&
          ((!t && r.yPercent) ||
            (Math.round(e.offsetHeight / 2) === Math.round(-d) ? -50 : 0)))
          ? (e.offsetHeight * r.yPercent) / 100
          : 0) +
        o),
      (r.z = p + o),
      (r.scaleX = Sn(m)),
      (r.scaleY = Sn(_)),
      (r.rotation = Sn(y) + a),
      (r.rotationX = Sn(x) + a),
      (r.rotationY = Sn(g) + a),
      (r.skewX = S + a),
      (r.skewY = A + a),
      (r.transformPerspective = E + o),
      (r.zOrigin = parseFloat(u.split(" ")[2]) || 0) && (i[ss] = Gg(u)),
      (r.xOffset = r.yOffset = 0),
      (r.force3D = ci.force3D),
      (r.renderTransform = r.svg ? pj : $I ? iD : dj),
      (r.uncache = 0),
      r
    );
  },
  Gg = function (e) {
    return (e = e.split(" "))[0] + " " + e[1];
  },
  Ny = function (e, t, r) {
    var i = pr(t);
    return Sn(parseFloat(t) + parseFloat(Ea(e, "x", r + "px", i))) + i;
  },
  dj = function (e, t) {
    (t.z = "0px"),
      (t.rotationY = t.rotationX = "0deg"),
      (t.force3D = 0),
      iD(e, t);
  },
  Za = "0deg",
  Nf = "0px",
  $a = ") ",
  iD = function (e, t) {
    var r = t || this,
      i = r.xPercent,
      s = r.yPercent,
      o = r.x,
      a = r.y,
      l = r.z,
      u = r.rotation,
      h = r.rotationY,
      d = r.rotationX,
      p = r.skewX,
      m = r.skewY,
      _ = r.scaleX,
      y = r.scaleY,
      x = r.transformPerspective,
      g = r.force3D,
      S = r.target,
      A = r.zOrigin,
      E = "",
      C = (g === "auto" && e && e !== 1) || g === !0;
    if (A && (d !== Za || h !== Za)) {
      var R = parseFloat(h) * fc,
        P = Math.sin(R),
        L = Math.cos(R),
        T;
      (R = parseFloat(d) * fc),
        (T = Math.cos(R)),
        (o = Ny(S, o, P * T * -A)),
        (a = Ny(S, a, -Math.sin(R) * -A)),
        (l = Ny(S, l, L * T * -A + A));
    }
    x !== Nf && (E += "perspective(" + x + $a),
      (i || s) && (E += "translate(" + i + "%, " + s + "%) "),
      (C || o !== Nf || a !== Nf || l !== Nf) &&
        (E +=
          l !== Nf || C
            ? "translate3d(" + o + ", " + a + ", " + l + ") "
            : "translate(" + o + ", " + a + $a),
      u !== Za && (E += "rotate(" + u + $a),
      h !== Za && (E += "rotateY(" + h + $a),
      d !== Za && (E += "rotateX(" + d + $a),
      (p !== Za || m !== Za) && (E += "skew(" + p + ", " + m + $a),
      (_ !== 1 || y !== 1) && (E += "scale(" + _ + ", " + y + $a),
      (S.style[an] = E || "translate(0, 0)");
  },
  pj = function (e, t) {
    var r = t || this,
      i = r.xPercent,
      s = r.yPercent,
      o = r.x,
      a = r.y,
      l = r.rotation,
      u = r.skewX,
      h = r.skewY,
      d = r.scaleX,
      p = r.scaleY,
      m = r.target,
      _ = r.xOrigin,
      y = r.yOrigin,
      x = r.xOffset,
      g = r.yOffset,
      S = r.forceCSS,
      A = parseFloat(o),
      E = parseFloat(a),
      C,
      R,
      P,
      L,
      T;
    (l = parseFloat(l)),
      (u = parseFloat(u)),
      (h = parseFloat(h)),
      h && ((h = parseFloat(h)), (u += h), (l += h)),
      l || u
        ? ((l *= fc),
          (u *= fc),
          (C = Math.cos(l) * d),
          (R = Math.sin(l) * d),
          (P = Math.sin(l - u) * -p),
          (L = Math.cos(l - u) * p),
          u &&
            ((h *= fc),
            (T = Math.tan(u - h)),
            (T = Math.sqrt(1 + T * T)),
            (P *= T),
            (L *= T),
            h &&
              ((T = Math.tan(h)),
              (T = Math.sqrt(1 + T * T)),
              (C *= T),
              (R *= T))),
          (C = Sn(C)),
          (R = Sn(R)),
          (P = Sn(P)),
          (L = Sn(L)))
        : ((C = d), (L = p), (R = P = 0)),
      ((A && !~(o + "").indexOf("px")) || (E && !~(a + "").indexOf("px"))) &&
        ((A = Ea(m, "x", o, "px")), (E = Ea(m, "y", a, "px"))),
      (_ || y || x || g) &&
        ((A = Sn(A + _ - (_ * C + y * P) + x)),
        (E = Sn(E + y - (_ * R + y * L) + g))),
      (i || s) &&
        ((T = m.getBBox()),
        (A = Sn(A + (i / 100) * T.width)),
        (E = Sn(E + (s / 100) * T.height))),
      (T =
        "matrix(" + C + "," + R + "," + P + "," + L + "," + A + "," + E + ")"),
      m.setAttribute("transform", T),
      S && (m.style[an] = T);
  },
  mj = function (e, t, r, i, s) {
    var o = 360,
      a = Yn(s),
      l = parseFloat(s) * (a && ~s.indexOf("rad") ? il : 1),
      u = l - i,
      h = i + u + "deg",
      d,
      p;
    return (
      a &&
        ((d = s.split("_")[1]),
        d === "short" && ((u %= o), u !== u % (o / 2) && (u += u < 0 ? o : -o)),
        d === "cw" && u < 0
          ? (u = ((u + o * xb) % o) - ~~(u / o) * o)
          : d === "ccw" && u > 0 && (u = ((u - o * xb) % o) - ~~(u / o) * o)),
      (e._pt = p = new jr(e._pt, t, r, i, u, ZW)),
      (p.e = h),
      (p.u = "deg"),
      e._props.push(r),
      p
    );
  },
  Cb = function (e, t) {
    for (var r in t) e[r] = t[r];
    return e;
  },
  gj = function (e, t, r) {
    var i = Cb({}, r._gsap),
      s = "perspective,force3D,transformOrigin,svgOrigin",
      o = r.style,
      a,
      l,
      u,
      h,
      d,
      p,
      m,
      _;
    i.svg
      ? ((u = r.getAttribute("transform")),
        r.setAttribute("transform", ""),
        (o[an] = t),
        (a = Yh(r, 1)),
        Jh(r, an),
        r.setAttribute("transform", u))
      : ((u = getComputedStyle(r)[an]),
        (o[an] = t),
        (a = Yh(r, 1)),
        (o[an] = u));
    for (l in xo)
      (u = i[l]),
        (h = a[l]),
        u !== h &&
          s.indexOf(l) < 0 &&
          ((m = pr(u)),
          (_ = pr(h)),
          (d = m !== _ ? Ea(r, l, u, _) : parseFloat(u)),
          (p = parseFloat(h)),
          (e._pt = new jr(e._pt, a, l, d, p - d, HS)),
          (e._pt.u = _ || 0),
          e._props.push(l));
    Cb(a, i);
  };
Wr("padding,margin,Width,Radius", function (n, e) {
  var t = "Top",
    r = "Right",
    i = "Bottom",
    s = "Left",
    o = (e < 3 ? [t, r, i, s] : [t + s, t + r, i + r, i + s]).map(function (a) {
      return e < 2 ? n + a : "border" + a + n;
    });
  Hg[e > 1 ? "border" + n : n] = function (a, l, u, h, d) {
    var p, m;
    if (arguments.length < 4)
      return (
        (p = o.map(function (_) {
          return io(a, _, u);
        })),
        (m = p.join(" ")),
        m.split(p[0]).length === 5 ? p[0] : m
      );
    (p = (h + "").split(" ")),
      (m = {}),
      o.forEach(function (_, y) {
        return (m[_] = p[y] = p[y] || p[((y - 1) / 2) | 0]);
      }),
      a.init(l, m, d);
  };
});
var sD = {
  name: "css",
  register: VS,
  targetTest: function (e) {
    return e.style && e.nodeType;
  },
  init: function (e, t, r, i, s) {
    var o = this._props,
      a = e.style,
      l = r.vars.startAt,
      u,
      h,
      d,
      p,
      m,
      _,
      y,
      x,
      g,
      S,
      A,
      E,
      C,
      R,
      P,
      L;
    sM || VS(),
      (this.styles = this.styles || ZI(e)),
      (L = this.styles.props),
      (this.tween = r);
    for (y in t)
      if (y !== "autoRound" && ((h = t[y]), !(ii[y] && HI(y, t, r, i, e, s)))) {
        if (
          ((m = typeof h),
          (_ = Hg[y]),
          m === "function" && ((h = h.call(r, i, e, s)), (m = typeof h)),
          m === "string" && ~h.indexOf("random(") && (h = Wh(h)),
          _)
        )
          _(this, e, y, h, r) && (P = 1);
        else if (y.substr(0, 2) === "--")
          (u = (getComputedStyle(e).getPropertyValue(y) + "").trim()),
            (h += ""),
            (ma.lastIndex = 0),
            ma.test(u) || ((x = pr(u)), (g = pr(h))),
            g ? x !== g && (u = Ea(e, y, u, g) + g) : x && (h += x),
            this.add(a, "setProperty", u, h, i, s, 0, 0, y),
            o.push(y),
            L.push(y, 0, a[y]);
        else if (m !== "undefined") {
          if (
            (l && y in l
              ? ((u = typeof l[y] == "function" ? l[y].call(r, i, e, s) : l[y]),
                Yn(u) && ~u.indexOf("random(") && (u = Wh(u)),
                pr(u + "") || (u += ci.units[y] || pr(io(e, y)) || ""),
                (u + "").charAt(1) === "=" && (u = io(e, y)))
              : (u = io(e, y)),
            (p = parseFloat(u)),
            (S = m === "string" && h.charAt(1) === "=" && h.substr(0, 2)),
            S && (h = h.substr(2)),
            (d = parseFloat(h)),
            y in bs &&
              (y === "autoAlpha" &&
                (p === 1 && io(e, "visibility") === "hidden" && d && (p = 0),
                L.push("visibility", 0, a.visibility),
                $o(
                  this,
                  a,
                  "visibility",
                  p ? "inherit" : "hidden",
                  d ? "inherit" : "hidden",
                  !d
                )),
              y !== "scale" &&
                y !== "transform" &&
                ((y = bs[y]), ~y.indexOf(",") && (y = y.split(",")[0]))),
            (A = y in xo),
            A)
          ) {
            if (
              (this.styles.save(y),
              E ||
                ((C = e._gsap),
                (C.renderTransform && !t.parseTransform) ||
                  Yh(e, t.parseTransform),
                (R = t.smoothOrigin !== !1 && C.smooth),
                (E = this._pt =
                  new jr(this._pt, a, an, 0, 1, C.renderTransform, C, 0, -1)),
                (E.dep = 1)),
              y === "scale")
            )
              (this._pt = new jr(
                this._pt,
                C,
                "scaleY",
                C.scaleY,
                (S ? uc(C.scaleY, S + d) : d) - C.scaleY || 0,
                HS
              )),
                (this._pt.u = 0),
                o.push("scaleY", y),
                (y += "X");
            else if (y === "transformOrigin") {
              L.push(ss, 0, a[ss]),
                (h = fj(h)),
                C.svg
                  ? WS(e, h, 0, R, 0, this)
                  : ((g = parseFloat(h.split(" ")[2]) || 0),
                    g !== C.zOrigin && $o(this, C, "zOrigin", C.zOrigin, g),
                    $o(this, a, y, Gg(u), Gg(h)));
              continue;
            } else if (y === "svgOrigin") {
              WS(e, h, 1, R, 0, this);
              continue;
            } else if (y in nD) {
              mj(this, C, y, p, S ? uc(p, S + h) : h);
              continue;
            } else if (y === "smoothOrigin") {
              $o(this, C, "smooth", C.smooth, h);
              continue;
            } else if (y === "force3D") {
              C[y] = h;
              continue;
            } else if (y === "transform") {
              gj(this, h, e);
              continue;
            }
          } else y in a || (y = Fc(y) || y);
          if (A || ((d || d === 0) && (p || p === 0) && !qW.test(h) && y in a))
            (x = (u + "").substr((p + "").length)),
              d || (d = 0),
              (g = pr(h) || (y in ci.units ? ci.units[y] : x)),
              x !== g && (p = Ea(e, y, u, g)),
              (this._pt = new jr(
                this._pt,
                A ? C : a,
                y,
                p,
                (S ? uc(p, S + d) : d) - p,
                !A && (g === "px" || y === "zIndex") && t.autoRound !== !1
                  ? ej
                  : HS
              )),
              (this._pt.u = g || 0),
              x !== g && g !== "%" && ((this._pt.b = u), (this._pt.r = $W));
          else if (y in a) cj.call(this, e, y, u, S ? S + h : h);
          else if (y in e) this.add(e, y, u || e[y], S ? S + h : h, i, s);
          else if (y !== "parseTransform") {
            Q1(y, h);
            continue;
          }
          A || (y in a ? L.push(y, 0, a[y]) : L.push(y, 1, u || e[y])),
            o.push(y);
        }
      }
    P && JI(this);
  },
  render: function (e, t) {
    if (t.tween._time || !oM())
      for (var r = t._pt; r; ) r.r(e, r.d), (r = r._next);
    else t.styles.revert();
  },
  get: io,
  aliases: bs,
  getSetter: function (e, t, r) {
    var i = bs[t];
    return (
      i && i.indexOf(",") < 0 && (t = i),
      t in xo && t !== ss && (e._gsap.x || io(e, "x"))
        ? r && yb === r
          ? t === "scale"
            ? ij
            : rj
          : (yb = r || {}) && (t === "scale" ? sj : oj)
        : e.style && !J1(e.style[t])
        ? tj
        : ~t.indexOf("-")
        ? nj
        : rM(e, t)
    );
  },
  core: { _removeProperty: Jh, _getMatrix: lM },
};
Xr.utils.checkPrefix = Fc;
Xr.core.getStyleSaver = ZI;
(function (n, e, t, r) {
  var i = Wr(n + "," + e + "," + t, function (s) {
    xo[s] = 1;
  });
  Wr(e, function (s) {
    (ci.units[s] = "deg"), (nD[s] = 1);
  }),
    (bs[i[13]] = n + "," + e),
    Wr(r, function (s) {
      var o = s.split(":");
      bs[o[1]] = i[o[0]];
    });
})(
  "x,y,z,scale,scaleX,scaleY,xPercent,yPercent",
  "rotation,rotationX,rotationY,skewX,skewY",
  "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
  "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"
);
Wr(
  "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
  function (n) {
    ci.units[n] = "px";
  }
);
Xr.registerPlugin(sD);
var eg = Xr.registerPlugin(sD) || Xr;
eg.core.Tween;
const _j = "_forCanvas_1a99p_1",
  vj = "_checkout_1a99p_9",
  yj = "_exp_1a99p_23",
  Tb = { forCanvas: _j, checkout: vj, exp: yj };
function xj(n) {
  const e = te.useRef(),
    { nodes: t, materials: r } = j0("./assets/mytheater.glb"),
    { camera: i } = JL(),
    { url: s } = JA();
  let o = nd(),
    { ticket: a, setTicket: l } = g0();
  console.log(a), (i.position.z = 1.5);
  const u = [r["Red cloth"], new da({ name: "grey", color: 8421504 })],
    h = (d) => {
      var p;
      if (d.object.parent.children[0].material.name === "grey") {
        (a += 1),
          (d.object.parent.children[0].material = new da({
            name: "green",
            color: 65280,
          }));
        const m = new pd(0.1, 0.1, 32),
          _ = new kr({ color: 16776960 }),
          y = new kn(m, _);
        y.rotation.set(Math.PI / 2, Math.PI / 2, Math.PI / 2),
          (y.name = "cone"),
          (y.position.y = 1.2),
          d.object.parent.add(y);
      } else if (
        d.object.parent.children[0].material.name === "green" &&
        d.object.name !== "cone"
      )
        (a -= 1),
          (d.object.parent.children[0].material = new da({
            name: "grey",
            color: 8421504,
          })),
          d.object.parent.remove(d.object.parent.getObjectByName("cone"));
      else if (d.object.name === "cone") {
        const m = new eg.timeline(),
          _ = d.object.parent.localToWorld(new U());
        e.current.traverse((y) => {
          y.name === "cone" && (y.visible = !1);
        }),
          m.to(i.position, {
            x: _.x,
            y: _.y + 0.2,
            z: _.z,
            onUpdate: () => {
              i.lookAt(
                -0.382128835196221,
                -0.13527385671785375,
                8.35679292678833
              );
            },
            duration: 4,
          });
      }
      if (
        ((p = d.object.parent.getObjectByName("Screen")) == null
          ? void 0
          : p.name) === "Screen"
      ) {
        const m = new eg.timeline();
        e.current.traverse((_) => {
          _.name === "cone" && (_.visible = !0);
        }),
          m.to(i.position, {
            x: 0,
            y: 0,
            z: 1.5,
            onUpdate: () => {
              new eg.timeline().to(i.rotation, {
                x: 0,
                y: 0,
                z: 0,
                duration: 2,
              });
            },
            duration: 2,
            ease: "power1.out",
          });
      }
    };
  return J.jsxs("group", {
    ...n,
    ref: e,
    dispose: null,
    onClick: (d) => {
      d.stopPropagation(), h(d);
    },
    children: [
      J.jsxs(sb, {
        fullscreen: !0,
        children: [
          J.jsx("button", {
            className: Tb.exp,
            children:
              "Select seats and click on traingle for viewing experience",
          }),
          J.jsx("button", {
            className: Tb.checkout,
            onClick: () => {
              o("/payment"), l(a);
            },
            children: "Proceed to checkout",
          }),
        ],
      }),
      J.jsxs("group", {
        name: "Scene_1",
        position: [-0.73, -0.42, 0.58],
        scale: 0.18,
        children: [
          J.jsxs("group", {
            name: "Cylinder",
            position: [1.91, 5.62, 0.02],
            children: [
              J.jsx("mesh", {
                name: "Cylinder_1",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cylinder_1.geometry,
                material: r.lights,
              }),
              J.jsx("mesh", {
                name: "Cylinder_2",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cylinder_2.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cylinder_3",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cylinder_3.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cylinder001",
            position: [4, 4.03, -11.11],
            rotation: [Math.PI / 2, 0, 0],
            children: [
              J.jsx("mesh", {
                name: "Cylinder001_1",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cylinder001_1.geometry,
                material: r["black paint"],
              }),
              J.jsx("mesh", {
                name: "Cylinder001_2",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cylinder001_2.geometry,
                material: r.lights,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube003",
            position: [-2.21, -0.36, -1.46],
            children: [
              J.jsx("mesh", {
                name: "Cube013_1",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube013_1.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube013_2",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube013_2.geometry,
                material: r.lights,
              }),
              J.jsx("mesh", {
                name: "Cube013_3",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube013_3.geometry,
                material: r["black paint"],
              }),
              J.jsx("mesh", {
                name: "Cube013_4",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube013_4.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "",
            children: [
              J.jsx("mesh", {
                name: "Cube_1",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_1.geometry,
                material: r["Red cloth"],
              }),
              J.jsx("mesh", {
                name: "Cube_2",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_2.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_3",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_3.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Plane",
            position: [4, -0.93, 0],
            children: [
              J.jsx("mesh", {
                name: "Plane002",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Plane002.geometry,
                material: r.Material,
              }),
              J.jsx("mesh", {
                name: "Plane002_1",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Plane002_1.geometry,
                material: r.Copper,
              }),
              J.jsx("mesh", {
                name: "Plane002_2",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Plane002_2.geometry,
                material: r["black paint"],
              }),
              J.jsx("mesh", {
                name: "Screen",
                castShadow: !0,
                receiveShadow: !0,
                material: r["Material.002"],
                children: J.jsx(sb, {
                  rotation: [Math.PI, 0, -Math.PI],
                  position: [0, 3, 5.1],
                  center: !0,
                  children: J.jsx("div", {
                    className: "confirmationModal",
                    style: {
                      backgroundSize: "cover",
                      backgroundImage: `url(https://image.tmdb.org/t/p/w300${
                        s == null ? void 0 : s.backdrop_path
                      })`,
                    },
                    children: J.jsx("span", {
                      className: "btns",
                      children: J.jsx("button", {
                        className: "btn-yes",
                        children: "Back To Seat Selection",
                      }),
                    }),
                  }),
                }),
              }),
              J.jsx("mesh", {
                name: "Plane002_4",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Plane002_4.geometry,
                material: r.floor,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube001",
            position: [-2.16, 2.06, 0],
            children: [
              J.jsx("mesh", {
                name: "Cube005_1",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube005_1.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube005_2",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube005_2.geometry,
                material: r.lights,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube004",
            position: [0, 0.59, -1.93],
            children: [
              J.jsx("mesh", {
                name: "Cube_4",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_4.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_5",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_5.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_6",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_6.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube005",
            position: [0, 1.17, -3.77],
            children: [
              J.jsx("mesh", {
                name: "Cube_7",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_7.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_8",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_8.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_9",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_9.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube006",
            position: [0, 1.73, -6.36],
            children: [
              J.jsx("mesh", {
                name: "Cube_10",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_10.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_11",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_11.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_12",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_12.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube007",
            position: [0, 2.26, -8.27],
            children: [
              J.jsx("mesh", {
                name: "Cube_16",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_16.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_17",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_17.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_18",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_18.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube008",
            position: [1.7, 0, 0],
            children: [
              J.jsx("mesh", {
                name: "Cube_22",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_22.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_23",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_23.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_24",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_24.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube009",
            position: [1.7, 0.59, -1.93],
            children: [
              J.jsx("mesh", {
                name: "Cube_13",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_13.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_14",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_14.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_15",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_15.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube010",
            position: [1.7, 1.17, -3.77],
            children: [
              J.jsx("mesh", {
                name: "Cube_28",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_28.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_29",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_29.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_30",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_30.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube011",
            position: [1.7, 1.73, -6.36],
            children: [
              J.jsx("mesh", {
                name: "Cube_31",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_31.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_32",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_32.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_33",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_33.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube012",
            position: [1.7, 2.26, -8.27],
            children: [
              J.jsx("mesh", {
                name: "Cube_34",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_34.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_35",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_35.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_36",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_36.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube013",
            position: [3.32, 0, 0],
            children: [
              J.jsx("mesh", {
                name: "Cube_19",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_19.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_20",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_20.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_21",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_21.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube014",
            position: [3.32, 0.59, -1.93],
            children: [
              J.jsx("mesh", {
                name: "Cube_37",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_37.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_38",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_38.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_39",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_39.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube015",
            position: [3.32, 1.17, -3.77],
            children: [
              J.jsx("mesh", {
                name: "Cube_40",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_40.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_41",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_41.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_42",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_42.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube016",
            position: [3.32, 1.73, -6.36],
            children: [
              J.jsx("mesh", {
                name: "Cube_46",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_46.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_47",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_47.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_48",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_48.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube017",
            position: [3.32, 2.26, -8.27],
            children: [
              J.jsx("mesh", {
                name: "Cube_25",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_25.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_26",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_26.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_27",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_27.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube018",
            position: [4.95, 0, 0],
            children: [
              J.jsx("mesh", {
                name: "Cube_49",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_49.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_50",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_50.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_51",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_51.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube019",
            position: [4.95, 0.59, -1.93],
            children: [
              J.jsx("mesh", {
                name: "Cube_52",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_52.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_53",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_53.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_54",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_54.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube020",
            position: [4.95, 1.17, -3.77],
            children: [
              J.jsx("mesh", {
                name: "Cube_55",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_55.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_56",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_56.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_57",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_57.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube021",
            position: [4.95, 1.73, -6.36],
            children: [
              J.jsx("mesh", {
                name: "Cube_43",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_43.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_44",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_44.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_45",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_45.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube022",
            position: [4.95, 2.26, -8.27],
            children: [
              J.jsx("mesh", {
                name: "Cube_61",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_61.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_62",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_62.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_63",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_63.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube023",
            position: [6.58, 0, 0],
            children: [
              J.jsx("mesh", {
                name: "Cube_64",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_64.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_65",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_65.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_66",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_66.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube024",
            position: [6.58, 0.59, -1.93],
            children: [
              J.jsx("mesh", {
                name: "Cube_67",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_67.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_68",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_68.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_69",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_69.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube025",
            position: [6.58, 1.17, -3.77],
            children: [
              J.jsx("mesh", {
                name: "Cube_58",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_58.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_59",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_59.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_60",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_60.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube026",
            position: [6.58, 1.73, -6.36],
            children: [
              J.jsx("mesh", {
                name: "Cube_70",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_70.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_71",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_71.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_72",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_72.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube027",
            position: [6.58, 2.26, -8.27],
            children: [
              J.jsx("mesh", {
                name: "Cube_73",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_73.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_74",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_74.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_75",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_75.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube028",
            position: [8.2, 0, 0],
            children: [
              J.jsx("mesh", {
                name: "Cube_79",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_79.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_80",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_80.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_81",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_81.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube029",
            position: [8.2, 0.59, -1.93],
            children: [
              J.jsx("mesh", {
                name: "Cube_76",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_76.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_77",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_77.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_78",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_78.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube030",
            position: [8.2, 1.17, -3.77],
            children: [
              J.jsx("mesh", {
                name: "Cube_82",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_82.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_83",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_83.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_84",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_84.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube031",
            position: [8.2, 1.73, -6.36],
            children: [
              J.jsx("mesh", {
                name: "Cube_85",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_85.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_86",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_86.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_87",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_87.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsxs("group", {
            name: "Cube032",
            position: [8.2, 2.26, -8.27],
            children: [
              J.jsx("mesh", {
                name: "Cube_88",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_88.geometry,
                material: u[Math.floor(Math.random() * 2)],
              }),
              J.jsx("mesh", {
                name: "Cube_89",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_89.geometry,
                material: r["black plastid"],
              }),
              J.jsx("mesh", {
                name: "Cube_90",
                castShadow: !0,
                receiveShadow: !0,
                geometry: t.Cube_90.geometry,
                material: r.Copper,
              }),
            ],
          }),
          J.jsx("mesh", {
            name: "Cube002",
            castShadow: !0,
            receiveShadow: !0,
            geometry: t.Cube002.geometry,
            material: t.Cube002.material,
            position: [-2.16, -0.65, -0.22],
          }),
        ],
      }),
    ],
  });
}
j0.preload("./assets/mytheater.glb");
function Sj() {
  return (
    g0(),
    J.jsx(J.Fragment, {
      children: J.jsxs(l6, {
        style: { width: "100%", height: "100vh" },
        children: [J.jsx("directionalLight", {}), J.jsx(xj, {})],
      }),
    })
  );
}
const Aj = "_paymentcontainer_1wbbe_1",
  Mj = { paymentcontainer: Aj },
  Ej = "_container_4pgvh_1",
  wj = "_backdrop_4pgvh_6",
  Cj = "_detailscontainer_4pgvh_13",
  Tj = "_poster_4pgvh_17",
  bj = "_datacontainer_4pgvh_25",
  Rj = "_overview_4pgvh_33",
  Lu = {
    container: Ej,
    backdrop: wj,
    detailscontainer: Cj,
    poster: Tj,
    datacontainer: bj,
    overview: Rj,
  };
function Pj() {
  const { url: n } = JA(),
    { ticket: e } = g0();
  console.log(n);
  let r = new Date().toString().slice(0, 21);
  return J.jsx(J.Fragment, {
    children: J.jsxs("div", {
      className: Lu.container,
      children: [
        J.jsx("img", {
          className: Lu.backdrop,
          src: `https://image.tmdb.org/t/p/w300${
            n == null ? void 0 : n.backdrop_path
          }`,
          alt: "",
        }),
        J.jsxs("div", {
          className: Lu.detailscontainer,
          children: [
            J.jsx("div", {
              className: Lu.poster,
              children: J.jsx("img", {
                src: `https://image.tmdb.org/t/p/w300${
                  n == null ? void 0 : n.poster_path
                }`,
                alt: "",
              }),
            }),
            J.jsxs("div", {
              className: Lu.datacontainer,
              children: [
                J.jsx("h1", { children: n == null ? void 0 : n.title }),
                J.jsxs("div", {
                  className: Lu.overview,
                  children: [
                    J.jsx("h3", { children: "Order Summary" }),
                    J.jsx("p", {
                      children: `You have selected ${e} seats. For ${r}.`,
                    }),
                    J.jsx("h4", {
                      children:
                        "Please enter card details for payment completion",
                    }),
                  ],
                }),
              ],
            }),
          ],
        }),
      ],
    }),
  });
}
var oD = { exports: {} },
  Of = { exports: {} },
  bb;
function Bj() {
  return (
    bb ||
      ((bb = 1),
      typeof self < "u"
        ? (Of.exports = self)
        : typeof window < "u"
        ? (Of.exports = window)
        : (Of.exports = Function("return this")())),
    Of.exports
  );
}
var Oy, Rb;
function Lj() {
  if (Rb) return Oy;
  Rb = 1;
  var n = Bj();
  return (
    (Oy = function () {
      return typeof sl != "object" ||
        !sl ||
        sl.Math !== Math ||
        sl.Array !== Array
        ? n
        : sl;
    }),
    Oy
  );
}
var Uy = { exports: {} },
  Pb;
function Ij() {
  return (
    Pb ||
      ((Pb = 1),
      function () {
        var n, e, t;
        (n = function (r) {
          return n.isDOMElement(r) ? r : document.querySelectorAll(r);
        }),
          (n.isDOMElement = function (r) {
            return r && r.nodeName != null;
          }),
          (t = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g),
          (n.trim = function (r) {
            return r === null ? "" : (r + "").replace(t, "");
          }),
          (e = /\r/g),
          (n.val = function (r, i) {
            var s;
            return arguments.length > 1
              ? (r.value = i)
              : ((s = r.value),
                typeof s == "string" ? s.replace(e, "") : s === null ? "" : s);
          }),
          (n.preventDefault = function (r) {
            if (typeof r.preventDefault == "function") {
              r.preventDefault();
              return;
            }
            return (r.returnValue = !1), !1;
          }),
          (n.normalizeEvent = function (r) {
            var i;
            return (
              (i = r),
              (r = {
                which: i.which != null ? i.which : void 0,
                target: i.target || i.srcElement,
                preventDefault: function () {
                  return n.preventDefault(i);
                },
                originalEvent: i,
                data: i.data || i.detail,
              }),
              r.which == null &&
                (r.which = i.charCode != null ? i.charCode : i.keyCode),
              r
            );
          }),
          (n.on = function (r, i, s) {
            var o, a, l, u, h, d, p, m;
            if (r.length) {
              for (a = 0, u = r.length; a < u; a++) (o = r[a]), n.on(o, i, s);
              return;
            }
            if (i.match(" ")) {
              for (m = i.split(" "), l = 0, h = m.length; l < h; l++)
                (d = m[l]), n.on(r, d, s);
              return;
            }
            if (
              ((p = s),
              (s = function (_) {
                return (_ = n.normalizeEvent(_)), p(_);
              }),
              r.addEventListener)
            )
              return r.addEventListener(i, s, !1);
            if (r.attachEvent) return (i = "on" + i), r.attachEvent(i, s);
            r["on" + i] = s;
          }),
          (n.addClass = function (r, i) {
            var s;
            return r.length
              ? (function () {
                  var o, a, l;
                  for (l = [], o = 0, a = r.length; o < a; o++)
                    (s = r[o]), l.push(n.addClass(s, i));
                  return l;
                })()
              : r.classList
              ? r.classList.add(i)
              : (r.className += " " + i);
          }),
          (n.hasClass = function (r, i) {
            var s, o, a, l;
            if (r.length) {
              for (o = !0, a = 0, l = r.length; a < l; a++)
                (s = r[a]), (o = o && n.hasClass(s, i));
              return o;
            }
            return r.classList
              ? r.classList.contains(i)
              : new RegExp("(^| )" + i + "( |$)", "gi").test(r.className);
          }),
          (n.removeClass = function (r, i) {
            var s, o, a, l, u, h;
            if (r.length)
              return (function () {
                var d, p, m;
                for (m = [], d = 0, p = r.length; d < p; d++)
                  (o = r[d]), m.push(n.removeClass(o, i));
                return m;
              })();
            if (r.classList) {
              for (u = i.split(" "), h = [], a = 0, l = u.length; a < l; a++)
                (s = u[a]), h.push(r.classList.remove(s));
              return h;
            } else
              return (r.className = r.className.replace(
                new RegExp(
                  "(^|\\b)" + i.split(" ").join("|") + "(\\b|$)",
                  "gi"
                ),
                " "
              ));
          }),
          (n.toggleClass = function (r, i, s) {
            var o;
            if (r.length)
              return (function () {
                var a, l, u;
                for (u = [], a = 0, l = r.length; a < l; a++)
                  (o = r[a]), u.push(n.toggleClass(o, i, s));
                return u;
              })();
            if (s) {
              if (!n.hasClass(r, i)) return n.addClass(r, i);
            } else return n.removeClass(r, i);
          }),
          (n.append = function (r, i) {
            var s;
            return r.length
              ? (function () {
                  var o, a, l;
                  for (l = [], o = 0, a = r.length; o < a; o++)
                    (s = r[o]), l.push(n.append(s, i));
                  return l;
                })()
              : r.insertAdjacentHTML("beforeend", i);
          }),
          (n.find = function (r, i) {
            return (
              (r instanceof NodeList || r instanceof Array) && (r = r[0]),
              r.querySelectorAll(i)
            );
          }),
          (n.trigger = function (r, i, s) {
            var o;
            try {
              o = new CustomEvent(i, { detail: s });
            } catch {
              (o = document.createEvent("CustomEvent")),
                o.initCustomEvent
                  ? o.initCustomEvent(i, !0, !0, s)
                  : o.initEvent(i, !0, !0, s);
            }
            return r.dispatchEvent(o);
          }),
          (Uy.exports = n);
      }.call(sl)),
    Uy.exports
  );
}
(function () {
  var n,
    e,
    t,
    r,
    i,
    s,
    o,
    a,
    l,
    u,
    h,
    d,
    p,
    m,
    _,
    y,
    x,
    g,
    S,
    A,
    E,
    C,
    R,
    P,
    L,
    T,
    B =
      [].indexOf ||
      function (D) {
        for (var I = 0, F = this.length; I < F; I++)
          if (I in this && this[I] === D) return I;
        return -1;
      };
  (_ = Lj()()),
    (e = Ij()),
    (o = /(\d{1,4})/g),
    (i = [
      {
        type: "amex",
        pattern: /^3[47]/,
        format: /(\d{1,4})(\d{1,6})?(\d{1,5})?/,
        length: [15],
        cvcLength: [4],
        luhn: !0,
      },
      {
        type: "dankort",
        pattern: /^5019/,
        format: o,
        length: [16],
        cvcLength: [3],
        luhn: !0,
      },
      {
        type: "dinersclub",
        pattern: /^(36|38|30[0-5])/,
        format: /(\d{1,4})(\d{1,6})?(\d{1,4})?/,
        length: [14],
        cvcLength: [3],
        luhn: !0,
      },
      {
        type: "discover",
        pattern: /^(6011|65|64[4-9]|622)/,
        format: o,
        length: [16],
        cvcLength: [3],
        luhn: !0,
      },
      {
        type: "elo",
        pattern:
          /^401178|^401179|^431274|^438935|^451416|^457393|^457631|^457632|^504175|^627780|^636297|^636369|^636368|^(506699|5067[0-6]\d|50677[0-8])|^(50900\d|5090[1-9]\d|509[1-9]\d{2})|^65003[1-3]|^(65003[5-9]|65004\d|65005[0-1])|^(65040[5-9]|6504[1-3]\d)|^(65048[5-9]|65049\d|6505[0-2]\d|65053[0-8])|^(65054[1-9]|6505[5-8]\d|65059[0-8])|^(65070\d|65071[0-8])|^65072[0-7]|^(65090[1-9]|65091\d|650920)|^(65165[2-9]|6516[6-7]\d)|^(65500\d|65501\d)|^(65502[1-9]|6550[3-4]\d|65505[0-8])|^(65092[1-9]|65097[0-8])/,
        format: o,
        length: [16],
        cvcLength: [3],
        luhn: !0,
      },
      {
        type: "hipercard",
        pattern: /^(384100|384140|384160|606282|637095|637568|60(?!11))/,
        format: o,
        length: [14, 15, 16, 17, 18, 19],
        cvcLength: [3],
        luhn: !0,
      },
      {
        type: "jcb",
        pattern:
          /^(308[8-9]|309[0-3]|3094[0]{4}|309[6-9]|310[0-2]|311[2-9]|3120|315[8-9]|333[7-9]|334[0-9]|35)/,
        format: o,
        length: [16, 19],
        cvcLength: [3],
        luhn: !0,
      },
      {
        type: "laser",
        pattern: /^(6706|6771|6709)/,
        format: o,
        length: [16, 17, 18, 19],
        cvcLength: [3],
        luhn: !0,
      },
      {
        type: "maestro",
        pattern: /^(50|5[6-9]|6007|6220|6304|6703|6708|6759|676[1-3])/,
        format: o,
        length: [12, 13, 14, 15, 16, 17, 18, 19],
        cvcLength: [3],
        luhn: !0,
      },
      {
        type: "mastercard",
        pattern: /^(5[1-5]|677189)|^(222[1-9]|2[3-6]\d{2}|27[0-1]\d|2720)/,
        format: o,
        length: [16],
        cvcLength: [3],
        luhn: !0,
      },
      {
        type: "mir",
        pattern: /^220[0-4][0-9][0-9]\d{10}$/,
        format: o,
        length: [16],
        cvcLength: [3],
        luhn: !0,
      },
      {
        type: "troy",
        pattern: /^9792/,
        format: o,
        length: [16],
        cvcLength: [3],
        luhn: !0,
      },
      {
        type: "unionpay",
        pattern: /^62/,
        format: o,
        length: [16, 17, 18, 19],
        cvcLength: [3],
        luhn: !1,
      },
      {
        type: "visaelectron",
        pattern: /^4(026|17500|405|508|844|91[37])/,
        format: o,
        length: [16],
        cvcLength: [3],
        luhn: !0,
      },
      {
        type: "visa",
        pattern: /^4/,
        format: o,
        length: [13, 16],
        cvcLength: [3],
        luhn: !0,
      },
    ]),
    (t = function (D) {
      var I, F, k, j, Z;
      for (
        D = (D + "").replace(/\D/g, ""), F = void 0, k = 0, j = i.length;
        k < j;
        k++
      )
        (I = i[k]),
          (Z = D.match(I.pattern)) &&
            (!F || Z[0].length > F[1][0].length) &&
            (F = [I, Z]);
      return F && F[0];
    }),
    (r = function (D) {
      var I, F, k;
      for (F = 0, k = i.length; F < k; F++)
        if (((I = i[F]), I.type === D)) return I;
    }),
    (x = function (D) {
      var I, F, k, j, Z, Q;
      for (
        Z = !0, Q = 0, F = (D + "").split("").reverse(), k = 0, j = F.length;
        k < j;
        k++
      )
        (I = F[k]),
          (I = parseInt(I, 10)),
          (Z = !Z) && (I *= 2),
          I > 9 && (I -= 9),
          (Q += I);
      return Q % 10 === 0;
    }),
    (y = function (D) {
      var I;
      try {
        if (
          (D.selectionStart != null && D.selectionStart !== D.selectionEnd) ||
          ((typeof document < "u" &&
          document !== null &&
          (I = document.selection) != null
            ? I.createRange
            : void 0) != null &&
            document.selection.createRange().text)
        )
          return !0;
      } catch {}
      return !1;
    }),
    (g = function (D) {
      return setTimeout(
        (function (I) {
          return function () {
            var F, k;
            return (
              (F = D.target),
              (k = e.val(F)),
              (k = n.fns.formatCardNumber(k)),
              s(F, k),
              e.trigger(F, "change")
            );
          };
        })()
      );
    }),
    (u = function (D) {
      return function (I) {
        var F, k, j, Z, Q, N, W, G, X, Y, de;
        if (
          (I.which > 0
            ? ((k = String.fromCharCode(I.which)), (de = e.val(I.target) + k))
            : ((k = I.data), (de = e.val(I.target))),
          !!/^\d+$/.test(k))
        ) {
          for (
            G = I.target,
              F = t(de),
              N = de.replace(/\D/g, "").length,
              Y = [16],
              F && (Y = F.length),
              D &&
                (Y = Y.filter(function (ae) {
                  return ae <= D;
                })),
              j = Z = 0,
              Q = Y.length;
            Z < Q;
            j = ++Z
          )
            if (((X = Y[j]), !(N >= X && Y[j + 1]) && N >= X)) return;
          if (
            !y(G) &&
            (F && F.type === "amex"
              ? (W = /^(\d{4}|\d{4}\s\d{6})$/)
              : (W = /(?:^|\s)(\d{4})$/),
            (de = de.substring(0, de.length - 1)),
            W.test(de))
          )
            return (
              I.preventDefault(), e.val(G, de + " " + k), e.trigger(G, "change")
            );
        }
      };
    }),
    (a = function (D) {
      var I, F;
      if (((I = D.target), (F = e.val(I)), !D.meta && D.which === 8 && !y(I))) {
        if (/\d\s$/.test(F))
          return (
            D.preventDefault(),
            e.val(I, F.replace(/\d\s$/, "")),
            e.trigger(I, "change")
          );
        if (/\s\d?$/.test(F))
          return (
            D.preventDefault(),
            e.val(I, F.replace(/\s\d?$/, "")),
            e.trigger(I, "change")
          );
      }
    }),
    (h = function (D) {
      var I, F, k;
      if (
        ((F = D.target),
        D.which > 0
          ? ((I = String.fromCharCode(D.which)), (k = e.val(F) + I))
          : ((I = D.data), (k = e.val(F))),
        !!/^\d+$/.test(I))
      ) {
        if (/^\d$/.test(k) && k !== "0" && k !== "1")
          return (
            D.preventDefault(),
            e.val(F, "0" + k + " / "),
            e.trigger(F, "change")
          );
        if (/^\d\d$/.test(k))
          return (
            D.preventDefault(), e.val(F, k + " / "), e.trigger(F, "change")
          );
      }
    }),
    (m = function (D) {
      var I, F, k;
      if (((I = String.fromCharCode(D.which)), !!/^\d+$/.test(I))) {
        if (
          ((F = D.target),
          (k = e.val(F) + I),
          /^\d$/.test(k) && k !== "0" && k !== "1")
        )
          return D.preventDefault(), e.val(F, "0" + k), e.trigger(F, "change");
        if (/^\d\d$/.test(k))
          return D.preventDefault(), e.val(F, "" + k), e.trigger(F, "change");
      }
    }),
    (d = function (D) {
      var I, F, k;
      if (
        ((I = String.fromCharCode(D.which)),
        !!/^\d+$/.test(I) && ((F = D.target), (k = e.val(F)), /^\d\d$/.test(k)))
      )
        return e.val(F, k + " / "), e.trigger(F, "change");
    }),
    (p = function (D) {
      var I, F, k;
      if (
        ((I = String.fromCharCode(D.which)),
        I === "/" &&
          ((F = D.target), (k = e.val(F)), /^\d$/.test(k) && k !== "0"))
      )
        return e.val(F, "0" + k + " / "), e.trigger(F, "change");
    }),
    (l = function (D) {
      var I, F;
      if (
        !D.metaKey &&
        ((I = D.target), (F = e.val(I)), D.which === 8 && !y(I))
      ) {
        if (/\d(\s|\/)+$/.test(F))
          return (
            D.preventDefault(),
            e.val(I, F.replace(/\d(\s|\/)*$/, "")),
            e.trigger(I, "change")
          );
        if (/\s\/\s?\d?$/.test(F))
          return (
            D.preventDefault(),
            e.val(I, F.replace(/\s\/\s?\d?$/, "")),
            e.trigger(I, "change")
          );
      }
    }),
    (P = function (D) {
      var I;
      if (D.metaKey || D.ctrlKey) return !0;
      if (D.which === 32) return D.preventDefault();
      if (D.which === 0 || D.which < 33) return !0;
      if (((I = String.fromCharCode(D.which)), !/[\d\s]/.test(I)))
        return D.preventDefault();
    }),
    (A = function (D) {
      return function (I) {
        var F, k, j, Z, Q;
        if (
          ((Z = I.target),
          (k = String.fromCharCode(I.which)),
          !!/^\d+$/.test(k) &&
            !y(Z) &&
            ((Q = (e.val(Z) + k).replace(/\D/g, "")),
            (F = t(Q)),
            (j = 16),
            F && (j = F.length[F.length.length - 1]),
            D && (j = Math.min(j, D)),
            !(Q.length <= j)))
        )
          return I.preventDefault();
      };
    }),
    (C = function (D, I) {
      var F, k, j;
      if (
        ((k = D.target),
        (F = String.fromCharCode(D.which)),
        !!/^\d+$/.test(F) &&
          !y(k) &&
          ((j = e.val(k) + F), (j = j.replace(/\D/g, "")), j.length > I))
      )
        return D.preventDefault();
    }),
    (E = function (D) {
      return C(D, 6);
    }),
    (R = function (D) {
      return C(D, 2);
    }),
    (L = function (D) {
      return C(D, 4);
    }),
    (S = function (D) {
      var I, F, k;
      if (
        ((F = D.target),
        (I = String.fromCharCode(D.which)),
        !!/^\d+$/.test(I) && !y(F) && ((k = e.val(F) + I), !(k.length <= 4)))
      )
        return D.preventDefault();
    }),
    (T = function (D) {
      var I, F, k, j, Z;
      if (
        ((j = D.target),
        (Z = e.val(j)),
        (k = n.fns.cardType(Z) || "unknown"),
        !e.hasClass(j, k))
      )
        return (
          (I = (function () {
            var Q, N, W;
            for (W = [], Q = 0, N = i.length; Q < N; Q++)
              (F = i[Q]), W.push(F.type);
            return W;
          })()),
          e.removeClass(j, "unknown"),
          e.removeClass(j, I.join(" ")),
          e.addClass(j, k),
          e.toggleClass(j, "identified", k !== "unknown"),
          e.trigger(j, "payment.cardType", k)
        );
    }),
    (s = function (D, I) {
      var F;
      if (((F = D.selectionEnd), e.val(D, I), F)) return (D.selectionEnd = F);
    }),
    (n = (function () {
      function D() {}
      return (
        (D.J = e),
        (D.fns = {
          cardExpiryVal: function (I) {
            var F, k, j, Z;
            return (
              (I = I.replace(/\s/g, "")),
              (j = I.split("/", 2)),
              (F = j[0]),
              (Z = j[1]),
              (Z != null ? Z.length : void 0) === 2 &&
                /^\d+$/.test(Z) &&
                ((k = new Date().getFullYear()),
                (k = k.toString().slice(0, 2)),
                (Z = k + Z)),
              (F = parseInt(F, 10)),
              (Z = parseInt(Z, 10)),
              { month: F, year: Z }
            );
          },
          validateCardNumber: function (I) {
            var F, k;
            return (
              (I = (I + "").replace(/\s+|-/g, "")),
              !/^\d+$/.test(I) || ((F = t(I)), !F)
                ? !1
                : ((k = I.length),
                  B.call(F.length, k) >= 0 && (F.luhn === !1 || x(I)))
            );
          },
          validateCardExpiry: function (I, F) {
            var k, j, Z, Q, N;
            return (
              typeof I == "object" && "month" in I
                ? ((Q = I), (I = Q.month), (F = Q.year))
                : typeof I == "string" &&
                  B.call(I, "/") >= 0 &&
                  ((N = D.fns.cardExpiryVal(I)), (I = N.month), (F = N.year)),
              !(I && F) ||
              ((I = e.trim(I)), (F = e.trim(F)), !/^\d+$/.test(I)) ||
              !/^\d+$/.test(F) ||
              ((I = parseInt(I, 10)), !(I && I <= 12))
                ? !1
                : (F.length === 2 &&
                    ((Z = new Date().getFullYear()),
                    (Z = Z.toString().slice(0, 2)),
                    (F = Z + F)),
                  (j = new Date(F, I)),
                  (k = new Date()),
                  j.setMonth(j.getMonth() - 1),
                  j.setMonth(j.getMonth() + 1, 1),
                  j > k)
            );
          },
          validateCardCVC: function (I, F) {
            var k, j;
            return (
              (I = e.trim(I)),
              /^\d+$/.test(I)
                ? F && r(F)
                  ? ((k = I.length),
                    B.call((j = r(F)) != null ? j.cvcLength : void 0, k) >= 0)
                  : I.length >= 3 && I.length <= 4
                : !1
            );
          },
          cardType: function (I) {
            var F;
            return (I && ((F = t(I)) != null ? F.type : void 0)) || null;
          },
          formatCardNumber: function (I) {
            var F, k, j, Z;
            return (
              (F = t(I)),
              F
                ? ((Z = F.length[F.length.length - 1]),
                  (I = I.replace(/\D/g, "")),
                  (I = I.slice(0, Z)),
                  F.format.global
                    ? (j = I.match(F.format)) != null
                      ? j.join(" ")
                      : void 0
                    : ((k = F.format.exec(I)),
                      k == null
                        ? void 0
                        : (k.shift(),
                          (k = k.filter(function (Q) {
                            return Q;
                          })),
                          k.join(" "))))
                : I
            );
          },
        }),
        (D.restrictNumeric = function (I) {
          return e.on(I, "keypress", P), e.on(I, "input", P);
        }),
        (D.cardExpiryVal = function (I) {
          return D.fns.cardExpiryVal(e.val(I));
        }),
        (D.formatCardCVC = function (I) {
          return (
            D.restrictNumeric(I), e.on(I, "keypress", S), e.on(I, "input", S), I
          );
        }),
        (D.formatCardExpiry = function (I) {
          var F, k;
          return (
            D.restrictNumeric(I),
            I.length && I.length === 2
              ? ((F = I[0]), (k = I[1]), this.formatCardExpiryMultiple(F, k))
              : (e.on(I, "keypress", E),
                e.on(I, "keypress", h),
                e.on(I, "keypress", p),
                e.on(I, "keypress", d),
                e.on(I, "keydown", l),
                e.on(I, "input", h)),
            I
          );
        }),
        (D.formatCardExpiryMultiple = function (I, F) {
          return (
            e.on(I, "keypress", R),
            e.on(I, "keypress", m),
            e.on(I, "input", m),
            e.on(F, "keypress", L),
            e.on(F, "input", L)
          );
        }),
        (D.formatCardNumber = function (I, F) {
          return (
            D.restrictNumeric(I),
            e.on(I, "keypress", A(F)),
            e.on(I, "keypress", u(F)),
            e.on(I, "keydown", a),
            e.on(I, "keyup blur", T),
            e.on(I, "blur", u(F)),
            e.on(I, "paste", g),
            e.on(I, "input", u(F)),
            I
          );
        }),
        (D.getCardArray = function () {
          return i;
        }),
        (D.setCardArray = function (I) {
          return (i = I), !0;
        }),
        (D.addToCardArray = function (I) {
          return i.push(I);
        }),
        (D.removeFromCardArray = function (I) {
          var F, k;
          for (F in i) (k = i[F]), k.type === I && i.splice(F, 1);
          return !0;
        }),
        D
      );
    })()),
    (oD.exports = n),
    (_.Payment = n);
}).call(sl);
var Dj = oD.exports;
const Uf = Nc(Dj);
function tg(n) {
  "@babel/helpers - typeof";
  return (
    typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
      ? (tg = function (t) {
          return typeof t;
        })
      : (tg = function (t) {
          return t &&
            typeof Symbol == "function" &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? "symbol"
            : typeof t;
        }),
    tg(n)
  );
}
function Fj(n, e) {
  return kj(n) || Uj(n, e) || Oj(n, e) || Nj();
}
function Nj() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Oj(n, e) {
  if (n) {
    if (typeof n == "string") return Bb(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (
      (t === "Object" && n.constructor && (t = n.constructor.name),
      t === "Map" || t === "Set")
    )
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return Bb(n, e);
  }
}
function Bb(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, r = new Array(e); t < e; t++) r[t] = n[t];
  return r;
}
function Uj(n, e) {
  if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(n)))) {
    var t = [],
      r = !0,
      i = !1,
      s = void 0;
    try {
      for (
        var o = n[Symbol.iterator](), a;
        !(r = (a = o.next()).done) && (t.push(a.value), !(e && t.length === e));
        r = !0
      );
    } catch (l) {
      (i = !0), (s = l);
    } finally {
      try {
        !r && o.return != null && o.return();
      } finally {
        if (i) throw s;
      }
    }
    return t;
  }
}
function kj(n) {
  if (Array.isArray(n)) return n;
}
function zj(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function Lb(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    (r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(n, r.key, r);
  }
}
function Hj(n, e, t) {
  return e && Lb(n.prototype, e), t && Lb(n, t), n;
}
function Gj(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  (n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 },
  })),
    e && jS(n, e);
}
function jS(n, e) {
  return (
    (jS =
      Object.setPrototypeOf ||
      function (r, i) {
        return (r.__proto__ = i), r;
      }),
    jS(n, e)
  );
}
function Vj(n) {
  var e = Xj();
  return function () {
    var r = Vg(n),
      i;
    if (e) {
      var s = Vg(this).constructor;
      i = Reflect.construct(r, arguments, s);
    } else i = r.apply(this, arguments);
    return Wj(this, i);
  };
}
function Wj(n, e) {
  return e && (tg(e) === "object" || typeof e == "function") ? e : jj(n);
}
function jj(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return n;
}
function Xj() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return (
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {})),
      !0
    );
  } catch {
    return !1;
  }
}
function Vg(n) {
  return (
    (Vg = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        }),
    Vg(n)
  );
}
function aD(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
var uM = (function (n) {
  Gj(t, n);
  var e = Vj(t);
  function t(r) {
    var i;
    return zj(this, t), (i = e.call(this, r)), i.setCards(), i;
  }
  return (
    Hj(t, [
      {
        key: "componentDidUpdate",
        value: function (i) {
          var s = this.props,
            o = s.acceptedCards,
            a = s.callback,
            l = s.number;
          i.number !== l &&
            typeof a == "function" &&
            a(this.options, Uf.fns.validateCardNumber(l)),
            i.acceptedCards.toString() !== o.toString() && this.setCards();
        },
      },
      {
        key: "setCards",
        value: function () {
          var i = this.props.acceptedCards,
            s = [];
          i.length
            ? Uf.getCardArray().forEach(function (o) {
                i.indexOf(o.type) !== -1 && s.push(o);
              })
            : (s = s.concat(Uf.getCardArray())),
            Uf.setCardArray(s);
        },
      },
      {
        key: "render",
        value: function () {
          var i = this.props,
            s = i.cvc,
            o = i.focused,
            a = i.locale,
            l = i.name,
            u = i.placeholders,
            h = this.number,
            d = this.expiry;
          return Rn.createElement(
            "div",
            { key: "Cards", className: "rccs" },
            Rn.createElement(
              "div",
              {
                className: [
                  "rccs__card",
                  "rccs__card--".concat(this.issuer),
                  o === "cvc" && this.issuer !== "amex"
                    ? "rccs__card--flipped"
                    : "",
                ]
                  .join(" ")
                  .trim(),
              },
              Rn.createElement(
                "div",
                { className: "rccs__card--front" },
                Rn.createElement("div", {
                  className: "rccs__card__background",
                }),
                Rn.createElement("div", { className: "rccs__issuer" }),
                Rn.createElement(
                  "div",
                  {
                    className: [
                      "rccs__cvc__front",
                      o === "cvc" ? "rccs--focused" : "",
                    ]
                      .join(" ")
                      .trim(),
                  },
                  s
                ),
                Rn.createElement(
                  "div",
                  {
                    className: [
                      "rccs__number",
                      h.replace(/ /g, "").length > 16
                        ? "rccs__number--large"
                        : "",
                      o === "number" ? "rccs--focused" : "",
                      h.substr(0, 1) !== "•" ? "rccs--filled" : "",
                    ]
                      .join(" ")
                      .trim(),
                  },
                  h
                ),
                Rn.createElement(
                  "div",
                  {
                    className: [
                      "rccs__name",
                      o === "name" ? "rccs--focused" : "",
                      l ? "rccs--filled" : "",
                    ]
                      .join(" ")
                      .trim(),
                  },
                  l || u.name
                ),
                Rn.createElement(
                  "div",
                  {
                    className: [
                      "rccs__expiry",
                      o === "expiry" ? "rccs--focused" : "",
                      d.substr(0, 1) !== "•" ? "rccs--filled" : "",
                    ]
                      .join(" ")
                      .trim(),
                  },
                  Rn.createElement(
                    "div",
                    { className: "rccs__expiry__valid" },
                    a.valid
                  ),
                  Rn.createElement(
                    "div",
                    { className: "rccs__expiry__value" },
                    d
                  )
                ),
                Rn.createElement("div", { className: "rccs__chip" })
              ),
              Rn.createElement(
                "div",
                { className: "rccs__card--back" },
                Rn.createElement("div", {
                  className: "rccs__card__background",
                }),
                Rn.createElement("div", { className: "rccs__stripe" }),
                Rn.createElement("div", { className: "rccs__signature" }),
                Rn.createElement(
                  "div",
                  {
                    className: ["rccs__cvc", o === "cvc" ? "rccs--focused" : ""]
                      .join(" ")
                      .trim(),
                  },
                  s
                ),
                Rn.createElement("div", { className: "rccs__issuer" })
              )
            )
          );
        },
      },
      {
        key: "issuer",
        get: function () {
          var i = this.props,
            s = i.issuer,
            o = i.preview;
          return o && s ? s.toLowerCase() : this.options.issuer;
        },
      },
      {
        key: "number",
        get: function () {
          var i = this.props,
            s = i.number,
            o = i.preview,
            a = o ? 19 : this.options.maxLength,
            l =
              typeof s == "number"
                ? s.toString()
                : s.replace(/[A-Za-z]| /g, "");
          for (
            isNaN(parseInt(l, 10)) && !o && (l = ""),
              a > 16 && (a = l.length <= 16 ? 16 : a),
              l.length > a && (l = l.slice(0, a));
            l.length < a;

          )
            l += "•";
          if (["amex", "dinersclub"].indexOf(this.issuer) !== -1) {
            var u = [0, 4, 10],
              h = [4, 6, 5];
            l = ""
              .concat(l.substr(u[0], h[0]), " ")
              .concat(l.substr(u[1], h[1]), " ")
              .concat(l.substr(u[2], h[2]));
          } else if (l.length > 16) {
            var d = [0, 4, 8, 12],
              p = [4, 7];
            l = ""
              .concat(l.substr(d[0], p[0]), " ")
              .concat(l.substr(d[1], p[0]), " ")
              .concat(l.substr(d[2], p[0]), " ")
              .concat(l.substr(d[3], p[1]));
          } else
            for (var m = 1; m < a / 4; m++) {
              var _ = m * 4 + (m - 1);
              l = "".concat(l.slice(0, _), " ").concat(l.slice(_));
            }
          return l;
        },
      },
      {
        key: "expiry",
        get: function () {
          var i = this.props.expiry,
            s = i === void 0 ? "" : i,
            o = typeof s == "number" ? s.toString() : s,
            a = "",
            l = "";
          if (o.indexOf("/") !== -1) {
            var u = o.split("/"),
              h = Fj(u, 2);
            (a = h[0]), (l = h[1]);
          } else o.length && ((a = o.substr(0, 2)), (l = o.substr(2, 6)));
          for (; a.length < 2; ) a += "•";
          for (l.length > 2 && (l = l.substr(2, 4)); l.length < 2; ) l += "•";
          return "".concat(a, "/").concat(l);
        },
      },
      {
        key: "options",
        get: function () {
          var i = this.props.number,
            s = Uf.fns.cardType(i) || "unknown",
            o = 16;
          return (
            s === "amex"
              ? (o = 15)
              : s === "dinersclub"
              ? (o = 14)
              : ["hipercard", "mastercard", "visa"].indexOf(s) !== -1 &&
                (o = 19),
            { issuer: s, maxLength: o }
          );
        },
      },
    ]),
    t
  );
})(Rn.Component);
aD(uM, "propTypes", {
  acceptedCards: Nn.array,
  callback: Nn.func,
  cvc: Nn.oneOfType([Nn.string, Nn.number]).isRequired,
  expiry: Nn.oneOfType([Nn.string, Nn.number]).isRequired,
  focused: Nn.string,
  issuer: Nn.string,
  locale: Nn.shape({ valid: Nn.string }),
  name: Nn.string.isRequired,
  number: Nn.oneOfType([Nn.string, Nn.number]).isRequired,
  placeholders: Nn.shape({ name: Nn.string }),
  preview: Nn.bool,
});
aD(uM, "defaultProps", {
  acceptedCards: [],
  locale: { valid: "valid thru" },
  placeholders: { name: "YOUR NAME HERE" },
  preview: !1,
});
const Jj = "_paymentcontainer_1pzgy_1",
  Kj = "_divInputs_1pzgy_11",
  Yj = "_inputsRow_1pzgy_19",
  Qj = "_inputs_1pzgy_19",
  qj = "_pay_1pzgy_1",
  eo = {
    paymentcontainer: Jj,
    divInputs: Kj,
    inputsRow: Yj,
    inputs: Qj,
    pay: qj,
  };
function Zj() {
  let { ticket: n } = g0(),
    e = nd();
  const [t, r] = te.useState({
      cvc: "",
      expiry: "",
      focus: "",
      name: "",
      number: "",
    }),
    i = (s) => {
      t.focus = s.target.name;
    };
  return J.jsx(J.Fragment, {
    children: J.jsx("div", {
      className: eo.paymentcontainer,
      children: J.jsxs("div", {
        className: eo.paymentform,
        children: [
          J.jsx(uM, {
            cvc: t.cvc,
            expiry: t.expiry,
            focused: t.focus,
            name: t.name,
            number: t.number,
            acceptedCards: ["visa", "mastercard"],
            placeholders: { name: "Your name" },
            locale: { valid: "Expiry" },
          }),
          J.jsx("form", {
            className: eo.form,
            onSubmit: (s) => {
              s.preventDefault();
            },
            children: J.jsxs("div", {
              className: eo.divInputs,
              children: [
                J.jsx("input", {
                  className: eo.inputs,
                  placeholder: "Card Number",
                  name: "number",
                  type: "number",
                  onChange: (s) => r({ ...t, number: s.target.value }),
                  onFocus: i,
                  required: !0,
                }),
                J.jsx("input", {
                  className: eo.inputs,
                  placeholder: "Name on Card",
                  name: "name",
                  onChange: (s) => r({ ...t, name: s.target.value }),
                  onFocus: i,
                  required: !0,
                }),
                J.jsx("input", {
                  className: eo.inputs,
                  placeholder: "MM/YY",
                  name: "expiry",
                  onChange: (s) => r({ ...t, expiry: s.target.value }),
                  maxlength: "4",
                  onFocus: i,
                  maxLength: 6,
                  required: !0,
                }),
                J.jsx("input", {
                  className: eo.inputs,
                  placeholder: "CVV",
                  name: "cvc",
                  type: "number",
                  maxlength: "3",
                  onChange: (s) => {
                    r({ ...t, cvc: s.target.value });
                  },
                  onFocus: i,
                  maxLength: 4,
                  required: !0,
                }),
                J.jsx("button", {
                  className: eo.pay,
                  onClick: () => e("/success"),
                  children: `To Pay Rs:${n * 250}`,
                }),
              ],
            }),
          }),
        ],
      }),
    }),
  });
}
function $j() {
  return J.jsx(J.Fragment, {
    children: J.jsxs("div", {
      className: Mj.paymentcontainer,
      children: [J.jsx(Pj, {}), J.jsx(Zj, {})],
    }),
  });
}
const eX = "_successcontainer_sb7xo_1",
  tX = "_successmessage_sb7xo_7",
  Ib = { successcontainer: eX, successmessage: tX };
function nX() {
  let n = nd();
  return J.jsx(J.Fragment, {
    children: J.jsx("div", {
      className: Ib.successcontainer,
      children: J.jsxs("div", {
        className: Ib.successmessage,
        children: [
          J.jsx("h1", { children: "Your Payment was Success!!" }),
          J.jsx("h3", { children: "Thank You for Booking with us." }),
          J.jsx("button", {
            onClick: () => n("/"),
            children: "Continue Browsing",
          }),
        ],
      }),
    }),
  });
}
function rX() {
  return J.jsx(J.Fragment, {
    children: J.jsx(AO, {
      children: J.jsxs(_O, {
        children: [
          J.jsxs(nl, {
            element: J.jsx(CO, {}),
            children: [
              J.jsx(nl, { path: "/", element: J.jsx(QU, {}) }),
              J.jsx(nl, { path: "/:id", element: J.jsx(Ck, {}) }),
              J.jsx(nl, { path: "/payment", element: J.jsx($j, {}) }),
              J.jsx(nl, { path: "/success", element: J.jsx(nX, {}) }),
            ],
          }),
          J.jsx(nl, { path: "/seat", element: J.jsx(Sj, {}) }),
        ],
      }),
    }),
  });
}
ky.createRoot(document.getElementById("root")).render(
  J.jsx(Rn.StrictMode, { children: J.jsx(rX, {}) })
);
